/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PACKAGE: &'static [u8; 10usize] = b"wireshark\0";
pub const VERSION_EXTRA: &'static [u8; 1usize] = b"\0";
pub const VERSION: &'static [u8; 6usize] = b"3.2.4\0";
pub const VERSION_MAJOR: u32 = 3;
pub const VERSION_MINOR: u32 = 2;
pub const VERSION_MICRO: u32 = 4;
pub const PLUGIN_PATH_ID: &'static [u8; 4usize] = b"3.2\0";
pub const VERSION_FLAVOR: &'static [u8; 1usize] = b"\0";
pub const HAVE_SSE4_2: u32 = 1;
pub const HAVE_PLUGINS: u32 = 1;
pub const HAVE_AIRPCAP: u32 = 1;
pub const HAVE_BPF_IMAGE: u32 = 1;
pub const HAVE_C_ARES: u32 = 1;
pub const HAVE_FCNTL_H: u32 = 1;
pub const HAVE_MAXMINDDB: u32 = 1;
pub const HAVE_LIBSSH: u32 = 1;
pub const HAVE_FLOORL: u32 = 1;
pub const HAVE_INFLATEPRIME: u32 = 1;
pub const HAVE_KERBEROS: u32 = 1;
pub const HAVE_NGHTTP2: u32 = 1;
pub const HAVE_LIBGNUTLS: u32 = 1;
pub const HAVE_GNUTLS_PKCS11: u32 = 1;
pub const HAVE_LIBPCAP: u32 = 1;
pub const HAVE_LIBSMI: u32 = 1;
pub const HAVE_ZLIB: u32 = 1;
pub const HAVE_MINIZIP: u32 = 1;
pub const HAVE_BROTLI: u32 = 1;
pub const HAVE_LZ4: u32 = 1;
pub const HAVE_LZ4FRAME_H: u32 = 1;
pub const HAVE_SNAPPY: u32 = 1;
pub const HAVE_ZSTD: u32 = 1;
pub const HAVE_LUA: u32 = 1;
pub const HAVE_MIT_KERBEROS: u32 = 1;
pub const HAVE_PCAP_BREAKLOOP: u32 = 1;
pub const HAVE_PCAP_CREATE: u32 = 1;
pub const CAN_SET_CAPTURE_BUFFER_SIZE: u32 = 1;
pub const HAVE_PCAP_DATALINK_NAME_TO_VAL: u32 = 1;
pub const HAVE_PCAP_DATALINK_VAL_TO_DESCRIPTION: u32 = 1;
pub const HAVE_PCAP_DATALINK_VAL_TO_NAME: u32 = 1;
pub const HAVE_PCAP_FINDALLDEVS: u32 = 1;
pub const HAVE_PCAP_FREECODE: u32 = 1;
pub const HAVE_PCAP_FREE_DATALINKS: u32 = 1;
pub const HAVE_PCAP_LIB_VERSION: u32 = 1;
pub const HAVE_PCAP_LIST_DATALINKS: u32 = 1;
pub const HAVE_PCAP_OPEN: u32 = 1;
pub const HAVE_PCAP_OPEN_DEAD: u32 = 1;
pub const HAVE_PCAP_REMOTE: u32 = 1;
pub const HAVE_PCAP_SET_DATALINK: u32 = 1;
pub const HAVE_PCAP_SETSAMPLING: u32 = 1;
pub const HAVE_SBC: u32 = 1;
pub const HAVE_SPANDSP: u32 = 1;
pub const HAVE_BCG729: u32 = 1;
pub const HAVE_LIBXML2: u32 = 1;
pub const HAVE_SOFTWARE_UPDATE: u32 = 1;
pub const PCAP_NG_DEFAULT: u32 = 1;
pub const QT_MULTIMEDIA_LIB: u32 = 1;
pub const WIN32: u32 = 1;
pub const __STDC__: u32 = 0;
pub const UNICODE: u32 = 1;
pub const _UNICODE: u32 = 1;
pub const NEED_STRPTIME_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const G_GNUC_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_GNUC_PRETTY_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const DBL_DECIMAL_DIG: u32 = 17;
pub const DBL_DIG: u32 = 15;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const DBL_MANT_DIG: u32 = 53;
pub const DBL_MAX_10_EXP: u32 = 308;
pub const DBL_MAX_EXP: u32 = 1024;
pub const DBL_MIN_10_EXP: i32 = -307;
pub const DBL_MIN_EXP: i32 = -1021;
pub const _DBL_RADIX: u32 = 2;
pub const FLT_DECIMAL_DIG: u32 = 9;
pub const FLT_DIG: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const FLT_GUARD: u32 = 0;
pub const FLT_MANT_DIG: u32 = 24;
pub const FLT_MAX_10_EXP: u32 = 38;
pub const FLT_MAX_EXP: u32 = 128;
pub const FLT_MIN_10_EXP: i32 = -37;
pub const FLT_MIN_EXP: i32 = -125;
pub const FLT_NORMALIZE: u32 = 0;
pub const FLT_RADIX: u32 = 2;
pub const LDBL_DIG: u32 = 15;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_MANT_DIG: u32 = 53;
pub const LDBL_MAX_10_EXP: u32 = 308;
pub const LDBL_MAX_EXP: u32 = 1024;
pub const LDBL_MIN_10_EXP: i32 = -307;
pub const LDBL_MIN_EXP: i32 = -1021;
pub const _LDBL_RADIX: u32 = 2;
pub const DECIMAL_DIG: u32 = 17;
pub const _SW_INEXACT: u32 = 1;
pub const _SW_UNDERFLOW: u32 = 2;
pub const _SW_OVERFLOW: u32 = 4;
pub const _SW_ZERODIVIDE: u32 = 8;
pub const _SW_INVALID: u32 = 16;
pub const _SW_DENORMAL: u32 = 524288;
pub const _EM_AMBIGUIOUS: u32 = 2147483648;
pub const _EM_AMBIGUOUS: u32 = 2147483648;
pub const _MCW_EM: u32 = 524319;
pub const _EM_INEXACT: u32 = 1;
pub const _EM_UNDERFLOW: u32 = 2;
pub const _EM_OVERFLOW: u32 = 4;
pub const _EM_ZERODIVIDE: u32 = 8;
pub const _EM_INVALID: u32 = 16;
pub const _EM_DENORMAL: u32 = 524288;
pub const _MCW_RC: u32 = 768;
pub const _RC_NEAR: u32 = 0;
pub const _RC_DOWN: u32 = 256;
pub const _RC_UP: u32 = 512;
pub const _RC_CHOP: u32 = 768;
pub const _MCW_PC: u32 = 196608;
pub const _PC_64: u32 = 0;
pub const _PC_53: u32 = 65536;
pub const _PC_24: u32 = 131072;
pub const _MCW_IC: u32 = 262144;
pub const _IC_AFFINE: u32 = 262144;
pub const _IC_PROJECTIVE: u32 = 0;
pub const _MCW_DN: u32 = 50331648;
pub const _DN_SAVE: u32 = 0;
pub const _DN_FLUSH: u32 = 16777216;
pub const _DN_FLUSH_OPERANDS_SAVE_RESULTS: u32 = 33554432;
pub const _DN_SAVE_OPERANDS_FLUSH_RESULTS: u32 = 50331648;
pub const _SW_UNEMULATED: u32 = 64;
pub const _SW_SQRTNEG: u32 = 128;
pub const _SW_STACKOVERFLOW: u32 = 512;
pub const _SW_STACKUNDERFLOW: u32 = 1024;
pub const _FPE_INVALID: u32 = 129;
pub const _FPE_DENORMAL: u32 = 130;
pub const _FPE_ZERODIVIDE: u32 = 131;
pub const _FPE_OVERFLOW: u32 = 132;
pub const _FPE_UNDERFLOW: u32 = 133;
pub const _FPE_INEXACT: u32 = 134;
pub const _FPE_UNEMULATED: u32 = 135;
pub const _FPE_SQRTNEG: u32 = 136;
pub const _FPE_STACKOVERFLOW: u32 = 138;
pub const _FPE_STACKUNDERFLOW: u32 = 139;
pub const _FPE_EXPLICITGEN: u32 = 140;
pub const _FPE_MULTIPLE_TRAPS: u32 = 141;
pub const _FPE_MULTIPLE_FAULTS: u32 = 142;
pub const _FPCLASS_SNAN: u32 = 1;
pub const _FPCLASS_QNAN: u32 = 2;
pub const _FPCLASS_NINF: u32 = 4;
pub const _FPCLASS_NN: u32 = 8;
pub const _FPCLASS_ND: u32 = 16;
pub const _FPCLASS_NZ: u32 = 32;
pub const _FPCLASS_PZ: u32 = 64;
pub const _FPCLASS_PD: u32 = 128;
pub const _FPCLASS_PN: u32 = 256;
pub const _FPCLASS_PINF: u32 = 512;
pub const _CW_DEFAULT: u32 = 524319;
pub const DBL_RADIX: u32 = 2;
pub const LDBL_RADIX: u32 = 2;
pub const EM_AMBIGUIOUS: u32 = 2147483648;
pub const EM_AMBIGUOUS: u32 = 2147483648;
pub const MCW_EM: u32 = 524319;
pub const EM_INVALID: u32 = 16;
pub const EM_DENORMAL: u32 = 524288;
pub const EM_ZERODIVIDE: u32 = 8;
pub const EM_OVERFLOW: u32 = 4;
pub const EM_UNDERFLOW: u32 = 2;
pub const EM_INEXACT: u32 = 1;
pub const MCW_IC: u32 = 262144;
pub const IC_AFFINE: u32 = 262144;
pub const IC_PROJECTIVE: u32 = 0;
pub const MCW_RC: u32 = 768;
pub const RC_CHOP: u32 = 768;
pub const RC_UP: u32 = 512;
pub const RC_DOWN: u32 = 256;
pub const RC_NEAR: u32 = 0;
pub const MCW_PC: u32 = 196608;
pub const PC_24: u32 = 131072;
pub const PC_53: u32 = 65536;
pub const PC_64: u32 = 0;
pub const CW_DEFAULT: u32 = 524319;
pub const SW_INVALID: u32 = 16;
pub const SW_DENORMAL: u32 = 524288;
pub const SW_ZERODIVIDE: u32 = 8;
pub const SW_OVERFLOW: u32 = 4;
pub const SW_UNDERFLOW: u32 = 2;
pub const SW_INEXACT: u32 = 1;
pub const SW_UNEMULATED: u32 = 64;
pub const SW_SQRTNEG: u32 = 128;
pub const SW_STACKOVERFLOW: u32 = 512;
pub const SW_STACKUNDERFLOW: u32 = 1024;
pub const FPE_INVALID: u32 = 129;
pub const FPE_DENORMAL: u32 = 130;
pub const FPE_ZERODIVIDE: u32 = 131;
pub const FPE_OVERFLOW: u32 = 132;
pub const FPE_UNDERFLOW: u32 = 133;
pub const FPE_INEXACT: u32 = 134;
pub const FPE_UNEMULATED: u32 = 135;
pub const FPE_SQRTNEG: u32 = 136;
pub const FPE_STACKOVERFLOW: u32 = 138;
pub const FPE_STACKUNDERFLOW: u32 = 139;
pub const FPE_EXPLICITGEN: u32 = 140;
pub const G_MINSHORT: i32 = -32768;
pub const G_MAXSHORT: u32 = 32767;
pub const G_MAXUSHORT: u32 = 65535;
pub const G_MININT: i32 = -2147483648;
pub const G_MAXINT: u32 = 2147483647;
pub const G_MAXUINT: u32 = 4294967295;
pub const G_MINLONG: i32 = -2147483648;
pub const G_MAXLONG: u32 = 2147483647;
pub const G_MAXULONG: u32 = 4294967295;
pub const G_GINT16_MODIFIER: &'static [u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &'static [u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &'static [u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &'static [u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &'static [u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &'static [u8; 4usize] = b"I64\0";
pub const G_GINT64_FORMAT: &'static [u8; 5usize] = b"I64i\0";
pub const G_GUINT64_FORMAT: &'static [u8; 5usize] = b"I64u\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 4;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &'static [u8; 4usize] = b"I64\0";
pub const G_GSSIZE_MODIFIER: &'static [u8; 4usize] = b"I64\0";
pub const G_GSIZE_FORMAT: &'static [u8; 5usize] = b"I64u\0";
pub const G_GSSIZE_FORMAT: &'static [u8; 5usize] = b"I64d\0";
pub const G_GOFFSET_MODIFIER: &'static [u8; 4usize] = b"I64\0";
pub const G_GOFFSET_FORMAT: &'static [u8; 5usize] = b"I64i\0";
pub const G_POLLFD_FORMAT: &'static [u8; 7usize] = b"%#I64x\0";
pub const G_GINTPTR_MODIFIER: &'static [u8; 4usize] = b"I64\0";
pub const G_GINTPTR_FORMAT: &'static [u8; 5usize] = b"I64i\0";
pub const G_GUINTPTR_FORMAT: &'static [u8; 5usize] = b"I64u\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 52;
pub const GLIB_MICRO_VERSION: u32 = 3;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_MODULE_SUFFIX: &'static [u8; 4usize] = b"dll\0";
pub const G_PID_FORMAT: &'static [u8; 2usize] = b"p\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 23;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const NSIG: u32 = 23;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGBREAK: u32 = 21;
pub const SIGABRT: u32 = 22;
pub const SIGABRT_COMPAT: u32 = 6;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const G_DIR_SEPARATOR: u8 = 92u8;
pub const G_DIR_SEPARATOR_S: &'static [u8; 2usize] = b"\\\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 59u8;
pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8; 2usize] = b";\0";
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_WIN32_MSG_HANDLE: u32 = 19981206;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &'static [u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &'static [u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &'static [u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &'static [u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &'static [u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &'static [u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &'static [u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &'static [u8; 13usize] = b"!$&'()*+,;=:\0";
pub const MAXPATHLEN: u32 = 1024;
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const WMEM_TREE_STRING_NOCASE: u32 = 1;
pub const GUID_LEN: u32 = 16;
pub const IPv6_ADDR_SIZE: u32 = 16;
pub const IPv6_HDR_SIZE: u32 = 40;
pub const IPv6_FRAGMENT_HDR_SIZE: u32 = 8;
pub const IP6F_OFF_MASK: u32 = 65528;
pub const IP6F_RESERVED_MASK: u32 = 6;
pub const IP6F_MORE_FRAG: u32 = 1;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const WS_INET_ADDRSTRLEN: u32 = 16;
pub const WS_INET6_ADDRSTRLEN: u32 = 46;
pub const OPT_EOFOPT: u32 = 0;
pub const OPT_COMMENT: u32 = 1;
pub const OPT_SHB_HARDWARE: u32 = 2;
pub const OPT_SHB_OS: u32 = 3;
pub const OPT_SHB_USERAPPL: u32 = 4;
pub const OPT_IDB_NAME: u32 = 2;
pub const OPT_IDB_DESCR: u32 = 3;
pub const OPT_IDB_IP4ADDR: u32 = 4;
pub const OPT_IDB_IP6ADDR: u32 = 5;
pub const OPT_IDB_MACADDR: u32 = 6;
pub const OPT_IDB_EUIADDR: u32 = 7;
pub const OPT_IDB_SPEED: u32 = 8;
pub const OPT_IDB_TSRESOL: u32 = 9;
pub const OPT_IDB_TZONE: u32 = 10;
pub const OPT_IDB_FILTER: u32 = 11;
pub const OPT_IDB_OS: u32 = 12;
pub const OPT_IDB_FCSLEN: u32 = 13;
pub const OPT_IDB_TSOFFSET: u32 = 14;
pub const OPT_IDB_HARDWARE: u32 = 15;
pub const OPT_NS_DNSNAME: u32 = 2;
pub const OPT_NS_DNSIP4ADDR: u32 = 3;
pub const OPT_NS_DNSIP6ADDR: u32 = 4;
pub const OPT_ISB_STARTTIME: u32 = 2;
pub const OPT_ISB_ENDTIME: u32 = 3;
pub const OPT_ISB_IFRECV: u32 = 4;
pub const OPT_ISB_IFDROP: u32 = 5;
pub const OPT_ISB_FILTERACCEPT: u32 = 6;
pub const OPT_ISB_OSDROP: u32 = 7;
pub const OPT_ISB_USRDELIV: u32 = 8;
pub const WTAP_ENCAP_PER_PACKET: i32 = -1;
pub const WTAP_ENCAP_UNKNOWN: u32 = 0;
pub const WTAP_ENCAP_ETHERNET: u32 = 1;
pub const WTAP_ENCAP_TOKEN_RING: u32 = 2;
pub const WTAP_ENCAP_SLIP: u32 = 3;
pub const WTAP_ENCAP_PPP: u32 = 4;
pub const WTAP_ENCAP_FDDI: u32 = 5;
pub const WTAP_ENCAP_FDDI_BITSWAPPED: u32 = 6;
pub const WTAP_ENCAP_RAW_IP: u32 = 7;
pub const WTAP_ENCAP_ARCNET: u32 = 8;
pub const WTAP_ENCAP_ARCNET_LINUX: u32 = 9;
pub const WTAP_ENCAP_ATM_RFC1483: u32 = 10;
pub const WTAP_ENCAP_LINUX_ATM_CLIP: u32 = 11;
pub const WTAP_ENCAP_LAPB: u32 = 12;
pub const WTAP_ENCAP_ATM_PDUS: u32 = 13;
pub const WTAP_ENCAP_ATM_PDUS_UNTRUNCATED: u32 = 14;
pub const WTAP_ENCAP_NULL: u32 = 15;
pub const WTAP_ENCAP_ASCEND: u32 = 16;
pub const WTAP_ENCAP_ISDN: u32 = 17;
pub const WTAP_ENCAP_IP_OVER_FC: u32 = 18;
pub const WTAP_ENCAP_PPP_WITH_PHDR: u32 = 19;
pub const WTAP_ENCAP_IEEE_802_11: u32 = 20;
pub const WTAP_ENCAP_IEEE_802_11_PRISM: u32 = 21;
pub const WTAP_ENCAP_IEEE_802_11_WITH_RADIO: u32 = 22;
pub const WTAP_ENCAP_IEEE_802_11_RADIOTAP: u32 = 23;
pub const WTAP_ENCAP_IEEE_802_11_AVS: u32 = 24;
pub const WTAP_ENCAP_SLL: u32 = 25;
pub const WTAP_ENCAP_FRELAY: u32 = 26;
pub const WTAP_ENCAP_FRELAY_WITH_PHDR: u32 = 27;
pub const WTAP_ENCAP_CHDLC: u32 = 28;
pub const WTAP_ENCAP_CISCO_IOS: u32 = 29;
pub const WTAP_ENCAP_LOCALTALK: u32 = 30;
pub const WTAP_ENCAP_OLD_PFLOG: u32 = 31;
pub const WTAP_ENCAP_HHDLC: u32 = 32;
pub const WTAP_ENCAP_DOCSIS: u32 = 33;
pub const WTAP_ENCAP_COSINE: u32 = 34;
pub const WTAP_ENCAP_WFLEET_HDLC: u32 = 35;
pub const WTAP_ENCAP_SDLC: u32 = 36;
pub const WTAP_ENCAP_TZSP: u32 = 37;
pub const WTAP_ENCAP_ENC: u32 = 38;
pub const WTAP_ENCAP_PFLOG: u32 = 39;
pub const WTAP_ENCAP_CHDLC_WITH_PHDR: u32 = 40;
pub const WTAP_ENCAP_BLUETOOTH_H4: u32 = 41;
pub const WTAP_ENCAP_MTP2: u32 = 42;
pub const WTAP_ENCAP_MTP3: u32 = 43;
pub const WTAP_ENCAP_IRDA: u32 = 44;
pub const WTAP_ENCAP_USER0: u32 = 45;
pub const WTAP_ENCAP_USER1: u32 = 46;
pub const WTAP_ENCAP_USER2: u32 = 47;
pub const WTAP_ENCAP_USER3: u32 = 48;
pub const WTAP_ENCAP_USER4: u32 = 49;
pub const WTAP_ENCAP_USER5: u32 = 50;
pub const WTAP_ENCAP_USER6: u32 = 51;
pub const WTAP_ENCAP_USER7: u32 = 52;
pub const WTAP_ENCAP_USER8: u32 = 53;
pub const WTAP_ENCAP_USER9: u32 = 54;
pub const WTAP_ENCAP_USER10: u32 = 55;
pub const WTAP_ENCAP_USER11: u32 = 56;
pub const WTAP_ENCAP_USER12: u32 = 57;
pub const WTAP_ENCAP_USER13: u32 = 58;
pub const WTAP_ENCAP_USER14: u32 = 59;
pub const WTAP_ENCAP_USER15: u32 = 60;
pub const WTAP_ENCAP_SYMANTEC: u32 = 61;
pub const WTAP_ENCAP_APPLE_IP_OVER_IEEE1394: u32 = 62;
pub const WTAP_ENCAP_BACNET_MS_TP: u32 = 63;
pub const WTAP_ENCAP_NETTL_RAW_ICMP: u32 = 64;
pub const WTAP_ENCAP_NETTL_RAW_ICMPV6: u32 = 65;
pub const WTAP_ENCAP_GPRS_LLC: u32 = 66;
pub const WTAP_ENCAP_JUNIPER_ATM1: u32 = 67;
pub const WTAP_ENCAP_JUNIPER_ATM2: u32 = 68;
pub const WTAP_ENCAP_REDBACK: u32 = 69;
pub const WTAP_ENCAP_NETTL_RAW_IP: u32 = 70;
pub const WTAP_ENCAP_NETTL_ETHERNET: u32 = 71;
pub const WTAP_ENCAP_NETTL_TOKEN_RING: u32 = 72;
pub const WTAP_ENCAP_NETTL_FDDI: u32 = 73;
pub const WTAP_ENCAP_NETTL_UNKNOWN: u32 = 74;
pub const WTAP_ENCAP_MTP2_WITH_PHDR: u32 = 75;
pub const WTAP_ENCAP_JUNIPER_PPPOE: u32 = 76;
pub const WTAP_ENCAP_GCOM_TIE1: u32 = 77;
pub const WTAP_ENCAP_GCOM_SERIAL: u32 = 78;
pub const WTAP_ENCAP_NETTL_X25: u32 = 79;
pub const WTAP_ENCAP_K12: u32 = 80;
pub const WTAP_ENCAP_JUNIPER_MLPPP: u32 = 81;
pub const WTAP_ENCAP_JUNIPER_MLFR: u32 = 82;
pub const WTAP_ENCAP_JUNIPER_ETHER: u32 = 83;
pub const WTAP_ENCAP_JUNIPER_PPP: u32 = 84;
pub const WTAP_ENCAP_JUNIPER_FRELAY: u32 = 85;
pub const WTAP_ENCAP_JUNIPER_CHDLC: u32 = 86;
pub const WTAP_ENCAP_JUNIPER_GGSN: u32 = 87;
pub const WTAP_ENCAP_LINUX_LAPD: u32 = 88;
pub const WTAP_ENCAP_CATAPULT_DCT2000: u32 = 89;
pub const WTAP_ENCAP_BER: u32 = 90;
pub const WTAP_ENCAP_JUNIPER_VP: u32 = 91;
pub const WTAP_ENCAP_USB_FREEBSD: u32 = 92;
pub const WTAP_ENCAP_IEEE802_16_MAC_CPS: u32 = 93;
pub const WTAP_ENCAP_NETTL_RAW_TELNET: u32 = 94;
pub const WTAP_ENCAP_USB_LINUX: u32 = 95;
pub const WTAP_ENCAP_MPEG: u32 = 96;
pub const WTAP_ENCAP_PPI: u32 = 97;
pub const WTAP_ENCAP_ERF: u32 = 98;
pub const WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR: u32 = 99;
pub const WTAP_ENCAP_SITA: u32 = 100;
pub const WTAP_ENCAP_SCCP: u32 = 101;
pub const WTAP_ENCAP_BLUETOOTH_HCI: u32 = 102;
pub const WTAP_ENCAP_IPMB_KONTRON: u32 = 103;
pub const WTAP_ENCAP_IEEE802_15_4: u32 = 104;
pub const WTAP_ENCAP_X2E_XORAYA: u32 = 105;
pub const WTAP_ENCAP_FLEXRAY: u32 = 106;
pub const WTAP_ENCAP_LIN: u32 = 107;
pub const WTAP_ENCAP_MOST: u32 = 108;
pub const WTAP_ENCAP_CAN20B: u32 = 109;
pub const WTAP_ENCAP_LAYER1_EVENT: u32 = 110;
pub const WTAP_ENCAP_X2E_SERIAL: u32 = 111;
pub const WTAP_ENCAP_I2C_LINUX: u32 = 112;
pub const WTAP_ENCAP_IEEE802_15_4_NONASK_PHY: u32 = 113;
pub const WTAP_ENCAP_TNEF: u32 = 114;
pub const WTAP_ENCAP_USB_LINUX_MMAPPED: u32 = 115;
pub const WTAP_ENCAP_GSM_UM: u32 = 116;
pub const WTAP_ENCAP_DPNSS: u32 = 117;
pub const WTAP_ENCAP_PACKETLOGGER: u32 = 118;
pub const WTAP_ENCAP_NSTRACE_1_0: u32 = 119;
pub const WTAP_ENCAP_NSTRACE_2_0: u32 = 120;
pub const WTAP_ENCAP_FIBRE_CHANNEL_FC2: u32 = 121;
pub const WTAP_ENCAP_FIBRE_CHANNEL_FC2_WITH_FRAME_DELIMS: u32 = 122;
pub const WTAP_ENCAP_JPEG_JFIF: u32 = 123;
pub const WTAP_ENCAP_IPNET: u32 = 124;
pub const WTAP_ENCAP_SOCKETCAN: u32 = 125;
pub const WTAP_ENCAP_IEEE_802_11_NETMON: u32 = 126;
pub const WTAP_ENCAP_IEEE802_15_4_NOFCS: u32 = 127;
pub const WTAP_ENCAP_RAW_IPFIX: u32 = 128;
pub const WTAP_ENCAP_RAW_IP4: u32 = 129;
pub const WTAP_ENCAP_RAW_IP6: u32 = 130;
pub const WTAP_ENCAP_LAPD: u32 = 131;
pub const WTAP_ENCAP_DVBCI: u32 = 132;
pub const WTAP_ENCAP_MUX27010: u32 = 133;
pub const WTAP_ENCAP_MIME: u32 = 134;
pub const WTAP_ENCAP_NETANALYZER: u32 = 135;
pub const WTAP_ENCAP_NETANALYZER_TRANSPARENT: u32 = 136;
pub const WTAP_ENCAP_IP_OVER_IB_SNOOP: u32 = 137;
pub const WTAP_ENCAP_MPEG_2_TS: u32 = 138;
pub const WTAP_ENCAP_PPP_ETHER: u32 = 139;
pub const WTAP_ENCAP_NFC_LLCP: u32 = 140;
pub const WTAP_ENCAP_NFLOG: u32 = 141;
pub const WTAP_ENCAP_V5_EF: u32 = 142;
pub const WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR: u32 = 143;
pub const WTAP_ENCAP_IXVERIWAVE: u32 = 144;
pub const WTAP_ENCAP_SDH: u32 = 145;
pub const WTAP_ENCAP_DBUS: u32 = 146;
pub const WTAP_ENCAP_AX25_KISS: u32 = 147;
pub const WTAP_ENCAP_AX25: u32 = 148;
pub const WTAP_ENCAP_SCTP: u32 = 149;
pub const WTAP_ENCAP_INFINIBAND: u32 = 150;
pub const WTAP_ENCAP_JUNIPER_SVCS: u32 = 151;
pub const WTAP_ENCAP_USBPCAP: u32 = 152;
pub const WTAP_ENCAP_RTAC_SERIAL: u32 = 153;
pub const WTAP_ENCAP_BLUETOOTH_LE_LL: u32 = 154;
pub const WTAP_ENCAP_WIRESHARK_UPPER_PDU: u32 = 155;
pub const WTAP_ENCAP_STANAG_4607: u32 = 156;
pub const WTAP_ENCAP_STANAG_5066_D_PDU: u32 = 157;
pub const WTAP_ENCAP_NETLINK: u32 = 158;
pub const WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR: u32 = 159;
pub const WTAP_ENCAP_BLUETOOTH_BREDR_BB: u32 = 160;
pub const WTAP_ENCAP_BLUETOOTH_LE_LL_WITH_PHDR: u32 = 161;
pub const WTAP_ENCAP_NSTRACE_3_0: u32 = 162;
pub const WTAP_ENCAP_LOGCAT: u32 = 163;
pub const WTAP_ENCAP_LOGCAT_BRIEF: u32 = 164;
pub const WTAP_ENCAP_LOGCAT_PROCESS: u32 = 165;
pub const WTAP_ENCAP_LOGCAT_TAG: u32 = 166;
pub const WTAP_ENCAP_LOGCAT_THREAD: u32 = 167;
pub const WTAP_ENCAP_LOGCAT_TIME: u32 = 168;
pub const WTAP_ENCAP_LOGCAT_THREADTIME: u32 = 169;
pub const WTAP_ENCAP_LOGCAT_LONG: u32 = 170;
pub const WTAP_ENCAP_PKTAP: u32 = 171;
pub const WTAP_ENCAP_EPON: u32 = 172;
pub const WTAP_ENCAP_IPMI_TRACE: u32 = 173;
pub const WTAP_ENCAP_LOOP: u32 = 174;
pub const WTAP_ENCAP_JSON: u32 = 175;
pub const WTAP_ENCAP_NSTRACE_3_5: u32 = 176;
pub const WTAP_ENCAP_ISO14443: u32 = 177;
pub const WTAP_ENCAP_GFP_T: u32 = 178;
pub const WTAP_ENCAP_GFP_F: u32 = 179;
pub const WTAP_ENCAP_IP_OVER_IB_PCAP: u32 = 180;
pub const WTAP_ENCAP_JUNIPER_VN: u32 = 181;
pub const WTAP_ENCAP_USB_DARWIN: u32 = 182;
pub const WTAP_ENCAP_LORATAP: u32 = 183;
pub const WTAP_ENCAP_3MB_ETHERNET: u32 = 184;
pub const WTAP_ENCAP_VSOCK: u32 = 185;
pub const WTAP_ENCAP_NORDIC_BLE: u32 = 186;
pub const WTAP_ENCAP_NETMON_NET_NETEVENT: u32 = 187;
pub const WTAP_ENCAP_NETMON_HEADER: u32 = 188;
pub const WTAP_ENCAP_NETMON_NET_FILTER: u32 = 189;
pub const WTAP_ENCAP_NETMON_NETWORK_INFO_EX: u32 = 190;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_V4: u32 = 191;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_V6: u32 = 192;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_2V4: u32 = 193;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_2V6: u32 = 194;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_AUTH_V4: u32 = 195;
pub const WTAP_ENCAP_MA_WFP_CAPTURE_AUTH_V6: u32 = 196;
pub const WTAP_ENCAP_JUNIPER_ST: u32 = 197;
pub const WTAP_ENCAP_ETHERNET_MPACKET: u32 = 198;
pub const WTAP_ENCAP_DOCSIS31_XRA31: u32 = 199;
pub const WTAP_ENCAP_DPAUXMON: u32 = 200;
pub const WTAP_ENCAP_RUBY_MARSHAL: u32 = 201;
pub const WTAP_ENCAP_RFC7468: u32 = 202;
pub const WTAP_ENCAP_SYSTEMD_JOURNAL: u32 = 203;
pub const WTAP_ENCAP_EBHSCR: u32 = 204;
pub const WTAP_ENCAP_VPP: u32 = 205;
pub const WTAP_ENCAP_IEEE802_15_4_TAP: u32 = 206;
pub const WTAP_ENCAP_LOG_3GPP: u32 = 207;
pub const WTAP_ENCAP_USB_2_0: u32 = 208;
pub const WTAP_FILE_TYPE_SUBTYPE_UNKNOWN: u32 = 0;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP: u32 = 1;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAPNG: u32 = 2;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC: u32 = 3;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_AIX: u32 = 4;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_SS991029: u32 = 5;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_NOKIA: u32 = 6;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990417: u32 = 7;
pub const WTAP_FILE_TYPE_SUBTYPE_PCAP_SS990915: u32 = 8;
pub const WTAP_FILE_TYPE_SUBTYPE_5VIEWS: u32 = 9;
pub const WTAP_FILE_TYPE_SUBTYPE_IPTRACE_1_0: u32 = 10;
pub const WTAP_FILE_TYPE_SUBTYPE_IPTRACE_2_0: u32 = 11;
pub const WTAP_FILE_TYPE_SUBTYPE_BER: u32 = 12;
pub const WTAP_FILE_TYPE_SUBTYPE_HCIDUMP: u32 = 13;
pub const WTAP_FILE_TYPE_SUBTYPE_CATAPULT_DCT2000: u32 = 14;
pub const WTAP_FILE_TYPE_SUBTYPE_NETXRAY_OLD: u32 = 15;
pub const WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_0: u32 = 16;
pub const WTAP_FILE_TYPE_SUBTYPE_COSINE: u32 = 17;
pub const WTAP_FILE_TYPE_SUBTYPE_CSIDS: u32 = 18;
pub const WTAP_FILE_TYPE_SUBTYPE_DBS_ETHERWATCH: u32 = 19;
pub const WTAP_FILE_TYPE_SUBTYPE_ERF: u32 = 20;
pub const WTAP_FILE_TYPE_SUBTYPE_EYESDN: u32 = 21;
pub const WTAP_FILE_TYPE_SUBTYPE_NETTL: u32 = 22;
pub const WTAP_FILE_TYPE_SUBTYPE_ISERIES: u32 = 23;
pub const WTAP_FILE_TYPE_SUBTYPE_ISERIES_UNICODE: u32 = 24;
pub const WTAP_FILE_TYPE_SUBTYPE_I4BTRACE: u32 = 25;
pub const WTAP_FILE_TYPE_SUBTYPE_ASCEND: u32 = 26;
pub const WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x: u32 = 27;
pub const WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x: u32 = 28;
pub const WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_UNCOMPRESSED: u32 = 29;
pub const WTAP_FILE_TYPE_SUBTYPE_NGSNIFFER_COMPRESSED: u32 = 30;
pub const WTAP_FILE_TYPE_SUBTYPE_NETXRAY_1_1: u32 = 31;
pub const WTAP_FILE_TYPE_SUBTYPE_NETXRAY_2_00x: u32 = 32;
pub const WTAP_FILE_TYPE_SUBTYPE_NETWORK_INSTRUMENTS: u32 = 33;
pub const WTAP_FILE_TYPE_SUBTYPE_LANALYZER: u32 = 34;
pub const WTAP_FILE_TYPE_SUBTYPE_PPPDUMP: u32 = 35;
pub const WTAP_FILE_TYPE_SUBTYPE_RADCOM: u32 = 36;
pub const WTAP_FILE_TYPE_SUBTYPE_SNOOP: u32 = 37;
pub const WTAP_FILE_TYPE_SUBTYPE_SHOMITI: u32 = 38;
pub const WTAP_FILE_TYPE_SUBTYPE_VMS: u32 = 39;
pub const WTAP_FILE_TYPE_SUBTYPE_K12: u32 = 40;
pub const WTAP_FILE_TYPE_SUBTYPE_TOSHIBA: u32 = 41;
pub const WTAP_FILE_TYPE_SUBTYPE_VISUAL_NETWORKS: u32 = 42;
pub const WTAP_FILE_TYPE_SUBTYPE_PEEKCLASSIC_V56: u32 = 43;
pub const WTAP_FILE_TYPE_SUBTYPE_PEEKCLASSIC_V7: u32 = 44;
pub const WTAP_FILE_TYPE_SUBTYPE_PEEKTAGGED: u32 = 45;
pub const WTAP_FILE_TYPE_SUBTYPE_MPEG: u32 = 46;
pub const WTAP_FILE_TYPE_SUBTYPE_K12TEXT: u32 = 47;
pub const WTAP_FILE_TYPE_SUBTYPE_NETSCREEN: u32 = 48;
pub const WTAP_FILE_TYPE_SUBTYPE_COMMVIEW: u32 = 49;
pub const WTAP_FILE_TYPE_SUBTYPE_BTSNOOP: u32 = 50;
pub const WTAP_FILE_TYPE_SUBTYPE_TNEF: u32 = 51;
pub const WTAP_FILE_TYPE_SUBTYPE_DCT3TRACE: u32 = 52;
pub const WTAP_FILE_TYPE_SUBTYPE_PACKETLOGGER: u32 = 53;
pub const WTAP_FILE_TYPE_SUBTYPE_DAINTREE_SNA: u32 = 54;
pub const WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0: u32 = 55;
pub const WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0: u32 = 56;
pub const WTAP_FILE_TYPE_SUBTYPE_JPEG_JFIF: u32 = 57;
pub const WTAP_FILE_TYPE_SUBTYPE_IPFIX: u32 = 58;
pub const WTAP_FILE_TYPE_SUBTYPE_MIME: u32 = 59;
pub const WTAP_FILE_TYPE_SUBTYPE_AETHRA: u32 = 60;
pub const WTAP_FILE_TYPE_SUBTYPE_MPEG_2_TS: u32 = 61;
pub const WTAP_FILE_TYPE_SUBTYPE_VWR_80211: u32 = 62;
pub const WTAP_FILE_TYPE_SUBTYPE_VWR_ETH: u32 = 63;
pub const WTAP_FILE_TYPE_SUBTYPE_CAMINS: u32 = 64;
pub const WTAP_FILE_TYPE_SUBTYPE_STANAG_4607: u32 = 65;
pub const WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0: u32 = 66;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT: u32 = 67;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_BRIEF: u32 = 68;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_PROCESS: u32 = 69;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TAG: u32 = 70;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREAD: u32 = 71;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TIME: u32 = 72;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREADTIME: u32 = 73;
pub const WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG: u32 = 74;
pub const WTAP_FILE_TYPE_SUBTYPE_COLASOFT_CAPSA: u32 = 75;
pub const WTAP_FILE_TYPE_SUBTYPE_COLASOFT_PACKET_BUILDER: u32 = 76;
pub const WTAP_FILE_TYPE_SUBTYPE_JSON: u32 = 77;
pub const WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_5: u32 = 78;
pub const WTAP_FILE_TYPE_SUBTYPE_NETTRACE_3GPP_32_423: u32 = 79;
pub const WTAP_FILE_TYPE_SUBTYPE_MPLOG: u32 = 80;
pub const WTAP_FILE_TYPE_SUBTYPE_DPA400: u32 = 81;
pub const WTAP_FILE_TYPE_SUBTYPE_RFC7468: u32 = 82;
pub const WTAP_FILE_TYPE_SUBTYPE_RUBY_MARSHAL: u32 = 83;
pub const WTAP_FILE_TYPE_SUBTYPE_SYSTEMD_JOURNAL: u32 = 84;
pub const WTAP_FILE_TYPE_SUBTYPE_LOG_3GPP: u32 = 85;
pub const WTAP_TSPREC_UNKNOWN: i32 = -2;
pub const WTAP_TSPREC_PER_PACKET: i32 = -1;
pub const WTAP_TSPREC_SEC: u32 = 0;
pub const WTAP_TSPREC_DSEC: u32 = 1;
pub const WTAP_TSPREC_CSEC: u32 = 2;
pub const WTAP_TSPREC_MSEC: u32 = 3;
pub const WTAP_TSPREC_USEC: u32 = 6;
pub const WTAP_TSPREC_NSEC: u32 = 9;
pub const WTAP_MAX_PACKET_SIZE_STANDARD: u32 = 262144;
pub const WTAP_MAX_PACKET_SIZE_USBPCAP: u32 = 134217728;
pub const WTAP_MAX_PACKET_SIZE_EBHSCR: u32 = 8388608;
pub const WTAP_MAX_PACKET_SIZE_DBUS: u32 = 134217728;
pub const FROM_DCE: u32 = 128;
pub const ATM_RAW_CELL: u32 = 1;
pub const ATM_NO_HEC: u32 = 2;
pub const ATM_AAL2_NOPHDR: u32 = 4;
pub const ATM_REASSEMBLY_ERROR: u32 = 8;
pub const AAL_UNKNOWN: u32 = 0;
pub const AAL_1: u32 = 1;
pub const AAL_2: u32 = 2;
pub const AAL_3_4: u32 = 3;
pub const AAL_5: u32 = 4;
pub const AAL_USER: u32 = 5;
pub const AAL_SIGNALLING: u32 = 6;
pub const AAL_OAMCELL: u32 = 7;
pub const TRAF_UNKNOWN: u32 = 0;
pub const TRAF_LLCMX: u32 = 1;
pub const TRAF_VCMX: u32 = 2;
pub const TRAF_LANE: u32 = 3;
pub const TRAF_ILMI: u32 = 4;
pub const TRAF_FR: u32 = 5;
pub const TRAF_SPANS: u32 = 6;
pub const TRAF_IPSILON: u32 = 7;
pub const TRAF_UMTS_FP: u32 = 8;
pub const TRAF_GPRS_NS: u32 = 9;
pub const TRAF_SSCOP: u32 = 10;
pub const TRAF_ST_UNKNOWN: u32 = 0;
pub const TRAF_ST_VCMX_802_3_FCS: u32 = 1;
pub const TRAF_ST_VCMX_802_4_FCS: u32 = 2;
pub const TRAF_ST_VCMX_802_5_FCS: u32 = 3;
pub const TRAF_ST_VCMX_FDDI_FCS: u32 = 4;
pub const TRAF_ST_VCMX_802_6_FCS: u32 = 5;
pub const TRAF_ST_VCMX_802_3: u32 = 7;
pub const TRAF_ST_VCMX_802_4: u32 = 8;
pub const TRAF_ST_VCMX_802_5: u32 = 9;
pub const TRAF_ST_VCMX_FDDI: u32 = 10;
pub const TRAF_ST_VCMX_802_6: u32 = 11;
pub const TRAF_ST_VCMX_FRAGMENTS: u32 = 12;
pub const TRAF_ST_VCMX_BPDU: u32 = 13;
pub const TRAF_ST_LANE_LE_CTRL: u32 = 1;
pub const TRAF_ST_LANE_802_3: u32 = 2;
pub const TRAF_ST_LANE_802_5: u32 = 3;
pub const TRAF_ST_LANE_802_3_MC: u32 = 4;
pub const TRAF_ST_LANE_802_5_MC: u32 = 5;
pub const TRAF_ST_IPSILON_FT0: u32 = 1;
pub const TRAF_ST_IPSILON_FT1: u32 = 2;
pub const TRAF_ST_IPSILON_FT2: u32 = 3;
pub const ASCEND_MAX_STR_LEN: u32 = 64;
pub const ASCEND_PFX_WDS_X: u32 = 1;
pub const ASCEND_PFX_WDS_R: u32 = 2;
pub const ASCEND_PFX_WDD: u32 = 3;
pub const ASCEND_PFX_ISDN_X: u32 = 4;
pub const ASCEND_PFX_ISDN_R: u32 = 5;
pub const ASCEND_PFX_ETHER: u32 = 6;
pub const PHDR_802_11_PHY_UNKNOWN: u32 = 0;
pub const PHDR_802_11_PHY_11_FHSS: u32 = 1;
pub const PHDR_802_11_PHY_11_IR: u32 = 2;
pub const PHDR_802_11_PHY_11_DSSS: u32 = 3;
pub const PHDR_802_11_PHY_11B: u32 = 4;
pub const PHDR_802_11_PHY_11A: u32 = 5;
pub const PHDR_802_11_PHY_11G: u32 = 6;
pub const PHDR_802_11_PHY_11N: u32 = 7;
pub const PHDR_802_11_PHY_11AC: u32 = 8;
pub const PHDR_802_11_PHY_11AD: u32 = 9;
pub const PHDR_802_11_PHY_11AH: u32 = 10;
pub const PHDR_802_11_PHY_11AX: u32 = 11;
pub const PHDR_802_11A_CHANNEL_TYPE_NORMAL: u32 = 0;
pub const PHDR_802_11A_CHANNEL_TYPE_HALF_CLOCKED: u32 = 1;
pub const PHDR_802_11A_CHANNEL_TYPE_QUARTER_CLOCKED: u32 = 2;
pub const PHDR_802_11A_TURBO_TYPE_NORMAL: u32 = 0;
pub const PHDR_802_11A_TURBO_TYPE_TURBO: u32 = 1;
pub const PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO: u32 = 2;
pub const PHDR_802_11A_TURBO_TYPE_STATIC_TURBO: u32 = 3;
pub const PHDR_802_11G_MODE_NORMAL: u32 = 0;
pub const PHDR_802_11G_MODE_SUPER_G: u32 = 1;
pub const PHDR_802_11_BANDWIDTH_20_MHZ: u32 = 0;
pub const PHDR_802_11_BANDWIDTH_40_MHZ: u32 = 1;
pub const PHDR_802_11_BANDWIDTH_20_20L: u32 = 2;
pub const PHDR_802_11_BANDWIDTH_20_20U: u32 = 3;
pub const PHDR_802_11_BANDWIDTH_80_MHZ: u32 = 4;
pub const PHDR_802_11_BANDWIDTH_40_40L: u32 = 5;
pub const PHDR_802_11_BANDWIDTH_40_40U: u32 = 6;
pub const PHDR_802_11_BANDWIDTH_20LL: u32 = 7;
pub const PHDR_802_11_BANDWIDTH_20LU: u32 = 8;
pub const PHDR_802_11_BANDWIDTH_20UL: u32 = 9;
pub const PHDR_802_11_BANDWIDTH_20UU: u32 = 10;
pub const PHDR_802_11_BANDWIDTH_160_MHZ: u32 = 11;
pub const PHDR_802_11_BANDWIDTH_80_80L: u32 = 12;
pub const PHDR_802_11_BANDWIDTH_80_80U: u32 = 13;
pub const PHDR_802_11_BANDWIDTH_40LL: u32 = 14;
pub const PHDR_802_11_BANDWIDTH_40LU: u32 = 15;
pub const PHDR_802_11_BANDWIDTH_40UL: u32 = 16;
pub const PHDR_802_11_BANDWIDTH_40UU: u32 = 17;
pub const PHDR_802_11_BANDWIDTH_20LLL: u32 = 18;
pub const PHDR_802_11_BANDWIDTH_20LLU: u32 = 19;
pub const PHDR_802_11_BANDWIDTH_20LUL: u32 = 20;
pub const PHDR_802_11_BANDWIDTH_20LUU: u32 = 21;
pub const PHDR_802_11_BANDWIDTH_20ULL: u32 = 22;
pub const PHDR_802_11_BANDWIDTH_20ULU: u32 = 23;
pub const PHDR_802_11_BANDWIDTH_20UUL: u32 = 24;
pub const PHDR_802_11_BANDWIDTH_20UUU: u32 = 25;
pub const PHDR_802_11AD_MIN_FREQUENCY: u32 = 57000;
pub const PHDR_802_11AD_MAX_FREQUENCY: u32 = 71000;
pub const PHDR_802_11_LAST_PART_OF_A_MPDU: u32 = 1;
pub const PHDR_802_11_A_MPDU_DELIM_CRC_ERROR: u32 = 2;
pub const PHDR_802_11_SOUNDING_PSDU: u32 = 0;
pub const PHDR_802_11_DATA_NOT_CAPTURED: u32 = 1;
pub const PHDR_802_11_0_LENGTH_PSDU_VENDOR_SPECIFIC: u32 = 255;
pub const COSINE_MAX_IF_NAME_LEN: u32 = 128;
pub const COSINE_ENCAP_TEST: u32 = 1;
pub const COSINE_ENCAP_PPoATM: u32 = 2;
pub const COSINE_ENCAP_PPoFR: u32 = 3;
pub const COSINE_ENCAP_ATM: u32 = 4;
pub const COSINE_ENCAP_FR: u32 = 5;
pub const COSINE_ENCAP_HDLC: u32 = 6;
pub const COSINE_ENCAP_PPP: u32 = 7;
pub const COSINE_ENCAP_ETH: u32 = 8;
pub const COSINE_ENCAP_UNKNOWN: u32 = 99;
pub const COSINE_DIR_TX: u32 = 1;
pub const COSINE_DIR_RX: u32 = 2;
pub const IRDA_INCOMING: u32 = 0;
pub const IRDA_OUTGOING: u32 = 4;
pub const IRDA_LOG_MESSAGE: u32 = 256;
pub const IRDA_MISSED_MSG: u32 = 257;
pub const IRDA_CLASS_FRAME: u32 = 0;
pub const IRDA_CLASS_LOG: u32 = 256;
pub const IRDA_CLASS_MASK: u32 = 65280;
pub const MTP2_ANNEX_A_NOT_USED: u32 = 0;
pub const MTP2_ANNEX_A_USED: u32 = 1;
pub const MTP2_ANNEX_A_USED_UNKNOWN: u32 = 2;
pub const K12_PORT_DS0S: u32 = 65544;
pub const K12_PORT_DS1: u32 = 1048584;
pub const K12_PORT_ATMPVC: u32 = 16908288;
pub const MAX_ERF_EHDR: u32 = 16;
pub const SITA_FRAME_DIR_TXED: u32 = 0;
pub const SITA_FRAME_DIR_RXED: u32 = 1;
pub const SITA_FRAME_DIR: u32 = 1;
pub const SITA_ERROR_NO_BUFFER: u32 = 128;
pub const SITA_SIG_DSR: u32 = 1;
pub const SITA_SIG_DTR: u32 = 2;
pub const SITA_SIG_CTS: u32 = 4;
pub const SITA_SIG_RTS: u32 = 8;
pub const SITA_SIG_DCD: u32 = 16;
pub const SITA_SIG_UNDEF1: u32 = 32;
pub const SITA_SIG_UNDEF2: u32 = 64;
pub const SITA_SIG_UNDEF3: u32 = 128;
pub const SITA_ERROR_TX_UNDERRUN: u32 = 1;
pub const SITA_ERROR_TX_CTS_LOST: u32 = 2;
pub const SITA_ERROR_TX_UART_ERROR: u32 = 4;
pub const SITA_ERROR_TX_RETX_LIMIT: u32 = 8;
pub const SITA_ERROR_TX_UNDEF1: u32 = 16;
pub const SITA_ERROR_TX_UNDEF2: u32 = 32;
pub const SITA_ERROR_TX_UNDEF3: u32 = 64;
pub const SITA_ERROR_TX_UNDEF4: u32 = 128;
pub const SITA_ERROR_RX_FRAMING: u32 = 1;
pub const SITA_ERROR_RX_PARITY: u32 = 2;
pub const SITA_ERROR_RX_COLLISION: u32 = 4;
pub const SITA_ERROR_RX_FRAME_LONG: u32 = 8;
pub const SITA_ERROR_RX_FRAME_SHORT: u32 = 16;
pub const SITA_ERROR_RX_UNDEF1: u32 = 32;
pub const SITA_ERROR_RX_UNDEF2: u32 = 64;
pub const SITA_ERROR_RX_UNDEF3: u32 = 128;
pub const SITA_ERROR_RX_NONOCTET_ALIGNED: u32 = 1;
pub const SITA_ERROR_RX_ABORT: u32 = 2;
pub const SITA_ERROR_RX_CD_LOST: u32 = 4;
pub const SITA_ERROR_RX_DPLL: u32 = 8;
pub const SITA_ERROR_RX_OVERRUN: u32 = 16;
pub const SITA_ERROR_RX_FRAME_LEN_VIOL: u32 = 32;
pub const SITA_ERROR_RX_CRC: u32 = 64;
pub const SITA_ERROR_RX_BREAK: u32 = 128;
pub const SITA_PROTO_UNUSED: u32 = 0;
pub const SITA_PROTO_BOP_LAPB: u32 = 1;
pub const SITA_PROTO_ETHERNET: u32 = 2;
pub const SITA_PROTO_ASYNC_INTIO: u32 = 3;
pub const SITA_PROTO_ASYNC_BLKIO: u32 = 4;
pub const SITA_PROTO_ALC: u32 = 5;
pub const SITA_PROTO_UTS: u32 = 6;
pub const SITA_PROTO_PPP_HDLC: u32 = 7;
pub const SITA_PROTO_SDLC: u32 = 8;
pub const SITA_PROTO_TOKENRING: u32 = 9;
pub const SITA_PROTO_I2C: u32 = 16;
pub const SITA_PROTO_DPM_LINK: u32 = 17;
pub const SITA_PROTO_BOP_FRL: u32 = 18;
pub const BTHCI_CHANNEL_COMMAND: u32 = 1;
pub const BTHCI_CHANNEL_ACL: u32 = 2;
pub const BTHCI_CHANNEL_SCO: u32 = 3;
pub const BTHCI_CHANNEL_EVENT: u32 = 4;
pub const GSM_UM_CHANNEL_UNKNOWN: u32 = 0;
pub const GSM_UM_CHANNEL_BCCH: u32 = 1;
pub const GSM_UM_CHANNEL_SDCCH: u32 = 2;
pub const GSM_UM_CHANNEL_SACCH: u32 = 3;
pub const GSM_UM_CHANNEL_FACCH: u32 = 4;
pub const GSM_UM_CHANNEL_CCCH: u32 = 5;
pub const GSM_UM_CHANNEL_RACH: u32 = 6;
pub const GSM_UM_CHANNEL_AGCH: u32 = 7;
pub const GSM_UM_CHANNEL_PCH: u32 = 8;
pub const LLCP_PHDR_FLAG_SENT: u32 = 0;
pub const REC_TYPE_PACKET: u32 = 0;
pub const REC_TYPE_FT_SPECIFIC_EVENT: u32 = 1;
pub const REC_TYPE_FT_SPECIFIC_REPORT: u32 = 2;
pub const REC_TYPE_SYSCALL: u32 = 3;
pub const PACK_FLAGS_DIRECTION_MASK: u32 = 3;
pub const PACK_FLAGS_DIRECTION_SHIFT: u32 = 0;
pub const PACK_FLAGS_DIRECTION_UNKNOWN: u32 = 0;
pub const PACK_FLAGS_DIRECTION_INBOUND: u32 = 1;
pub const PACK_FLAGS_DIRECTION_OUTBOUND: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_MASK: u32 = 28;
pub const PACK_FLAGS_RECEPTION_TYPE_SHIFT: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_UNSPECIFIED: u32 = 0;
pub const PACK_FLAGS_RECEPTION_TYPE_UNICAST: u32 = 1;
pub const PACK_FLAGS_RECEPTION_TYPE_MULTICAST: u32 = 2;
pub const PACK_FLAGS_RECEPTION_TYPE_BROADCAST: u32 = 3;
pub const PACK_FLAGS_RECEPTION_TYPE_PROMISCUOUS: u32 = 4;
pub const PACK_FLAGS_FCS_LENGTH_MASK: u32 = 480;
pub const PACK_FLAGS_FCS_LENGTH_SHIFT: u32 = 5;
pub const PACK_FLAGS_RESERVED_MASK: u32 = 65024;
pub const PACK_FLAGS_CRC_ERROR: u32 = 16777216;
pub const PACK_FLAGS_PACKET_TOO_LONG: u32 = 33554432;
pub const PACK_FLAGS_PACKET_TOO_SHORT: u32 = 67108864;
pub const PACK_FLAGS_WRONG_INTER_FRAME_GAP: u32 = 134217728;
pub const PACK_FLAGS_UNALIGNED_FRAME: u32 = 268435456;
pub const PACK_FLAGS_START_FRAME_DELIMITER_ERROR: u32 = 536870912;
pub const PACK_FLAGS_PREAMBLE_ERROR: u32 = 1073741824;
pub const PACK_FLAGS_SYMBOL_ERROR: u32 = 2147483648;
pub const WTAP_HAS_TS: u32 = 1;
pub const WTAP_HAS_CAP_LEN: u32 = 2;
pub const WTAP_HAS_INTERFACE_ID: u32 = 4;
pub const WTAP_HAS_COMMENTS: u32 = 8;
pub const WTAP_HAS_DROP_COUNT: u32 = 16;
pub const WTAP_HAS_PACK_FLAGS: u32 = 32;
pub const MAXNAMELEN: u32 = 64;
pub const WTAP_COMMENT_PER_SECTION: u32 = 1;
pub const WTAP_COMMENT_PER_INTERFACE: u32 = 2;
pub const WTAP_COMMENT_PER_PACKET: u32 = 4;
pub const WTAP_TYPE_AUTO: u32 = 0;
pub const WTAP_ERR_NOT_REGULAR_FILE: i32 = -1;
pub const WTAP_ERR_RANDOM_OPEN_PIPE: i32 = -2;
pub const WTAP_ERR_FILE_UNKNOWN_FORMAT: i32 = -3;
pub const WTAP_ERR_UNSUPPORTED: i32 = -4;
pub const WTAP_ERR_CANT_WRITE_TO_PIPE: i32 = -5;
pub const WTAP_ERR_CANT_OPEN: i32 = -6;
pub const WTAP_ERR_UNWRITABLE_FILE_TYPE: i32 = -7;
pub const WTAP_ERR_UNWRITABLE_ENCAP: i32 = -8;
pub const WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED: i32 = -9;
pub const WTAP_ERR_CANT_WRITE: i32 = -10;
pub const WTAP_ERR_CANT_CLOSE: i32 = -11;
pub const WTAP_ERR_SHORT_READ: i32 = -12;
pub const WTAP_ERR_BAD_FILE: i32 = -13;
pub const WTAP_ERR_SHORT_WRITE: i32 = -14;
pub const WTAP_ERR_UNC_OVERFLOW: i32 = -15;
pub const WTAP_ERR_RANDOM_OPEN_STDIN: i32 = -16;
pub const WTAP_ERR_COMPRESSION_NOT_SUPPORTED: i32 = -17;
pub const WTAP_ERR_CANT_SEEK: i32 = -18;
pub const WTAP_ERR_CANT_SEEK_COMPRESSED: i32 = -19;
pub const WTAP_ERR_DECOMPRESS: i32 = -20;
pub const WTAP_ERR_INTERNAL: i32 = -21;
pub const WTAP_ERR_PACKET_TOO_LARGE: i32 = -22;
pub const WTAP_ERR_CHECK_WSLUA: i32 = -23;
pub const WTAP_ERR_UNWRITABLE_REC_TYPE: i32 = -24;
pub const WTAP_ERR_UNWRITABLE_REC_DATA: i32 = -25;
pub const WTAP_ERR_DECOMPRESSION_NOT_SUPPORTED: i32 = -26;
pub const P2P_DIR_UNKNOWN: i32 = -1;
pub const P2P_DIR_SENT: u32 = 0;
pub const P2P_DIR_RECV: u32 = 1;
pub const LINK_DIR_UNKNOWN: i32 = -1;
pub const P2P_DIR_UL: u32 = 0;
pub const P2P_DIR_DL: u32 = 1;
pub const PINFO_HAS_TS: u32 = 1;
pub const DESEGMENT_ONE_MORE_SEGMENT: u32 = 268435455;
pub const DESEGMENT_UNTIL_FIN: u32 = 268435454;
pub const FT_ETHER_LEN: u32 = 6;
pub const FT_GUID_LEN: u32 = 16;
pub const FT_IPv4_LEN: u32 = 4;
pub const FT_IPv6_LEN: u32 = 16;
pub const FT_IPXNET_LEN: u32 = 4;
pub const FT_EUI64_LEN: u32 = 8;
pub const FT_AX25_ADDR_LEN: u32 = 7;
pub const FT_VINES_ADDR_LEN: u32 = 6;
pub const FT_FCWWN_LEN: u32 = 8;
pub const FT_VARINT_MAX_LEN: u32 = 10;
pub const ITEM_LABEL_LENGTH: u32 = 240;
pub const ITEM_LABEL_UNKNOWN_STR: &'static [u8; 8usize] = b"Unknown\0";
pub const ENC_BIG_ENDIAN: u32 = 0;
pub const ENC_LITTLE_ENDIAN: u32 = 2147483648;
pub const ENC_HOST_ENDIAN: u32 = 2147483648;
pub const ENC_TIME_SECS_NSECS: u32 = 0;
pub const ENC_TIME_TIMESPEC: u32 = 0;
pub const ENC_TIME_NTP: u32 = 2;
pub const ENC_TIME_TOD: u32 = 4;
pub const ENC_TIME_RTPS: u32 = 8;
pub const ENC_TIME_NTP_BASE_ZERO: u32 = 8;
pub const ENC_TIME_SECS_USECS: u32 = 16;
pub const ENC_TIME_TIMEVAL: u32 = 16;
pub const ENC_TIME_SECS: u32 = 18;
pub const ENC_TIME_MSECS: u32 = 20;
pub const ENC_TIME_SECS_NTP: u32 = 24;
pub const ENC_TIME_RFC_3971: u32 = 32;
pub const ENC_TIME_MSEC_NTP: u32 = 34;
pub const ENC_TIME_MIP6: u32 = 36;
pub const ENC_ZIGBEE: u32 = 1073741824;
pub const ENC_CHARENCODING_MASK: u32 = 1073741822;
pub const ENC_ASCII: u32 = 0;
pub const ENC_ISO_646_IRV: u32 = 0;
pub const ENC_UTF_8: u32 = 2;
pub const ENC_UTF_16: u32 = 4;
pub const ENC_UCS_2: u32 = 6;
pub const ENC_UCS_4: u32 = 8;
pub const ENC_ISO_8859_1: u32 = 10;
pub const ENC_ISO_8859_2: u32 = 12;
pub const ENC_ISO_8859_3: u32 = 14;
pub const ENC_ISO_8859_4: u32 = 16;
pub const ENC_ISO_8859_5: u32 = 18;
pub const ENC_ISO_8859_6: u32 = 20;
pub const ENC_ISO_8859_7: u32 = 22;
pub const ENC_ISO_8859_8: u32 = 24;
pub const ENC_ISO_8859_9: u32 = 26;
pub const ENC_ISO_8859_10: u32 = 28;
pub const ENC_ISO_8859_11: u32 = 30;
pub const ENC_ISO_8859_13: u32 = 34;
pub const ENC_ISO_8859_14: u32 = 36;
pub const ENC_ISO_8859_15: u32 = 38;
pub const ENC_ISO_8859_16: u32 = 40;
pub const ENC_WINDOWS_1250: u32 = 42;
pub const ENC_3GPP_TS_23_038_7BITS: u32 = 44;
pub const ENC_EBCDIC: u32 = 46;
pub const ENC_MAC_ROMAN: u32 = 48;
pub const ENC_CP437: u32 = 50;
pub const ENC_ASCII_7BITS: u32 = 52;
pub const ENC_T61: u32 = 54;
pub const ENC_EBCDIC_CP037: u32 = 56;
pub const ENC_WINDOWS_1252: u32 = 58;
pub const ENC_WINDOWS_1251: u32 = 60;
pub const ENC_CP855: u32 = 62;
pub const ENC_CP866: u32 = 64;
pub const ENC_ISO_646_BASIC: u32 = 66;
pub const ENC_NA: u32 = 0;
pub const ENC_STR_NUM: u32 = 16777216;
pub const ENC_STR_HEX: u32 = 33554432;
pub const ENC_STRING: u32 = 50331648;
pub const ENC_STR_MASK: u32 = 65534;
pub const ENC_NUM_PREF: u32 = 2097152;
pub const ENC_VARINT_PROTOBUF: u32 = 2;
pub const ENC_VARINT_QUIC: u32 = 4;
pub const ENC_VARINT_ZIGZAG: u32 = 8;
pub const ENC_VARIANT_MASK: u32 = 14;
pub const ENC_SEP_NONE: u32 = 65536;
pub const ENC_SEP_COLON: u32 = 131072;
pub const ENC_SEP_DASH: u32 = 262144;
pub const ENC_SEP_DOT: u32 = 524288;
pub const ENC_SEP_SPACE: u32 = 1048576;
pub const ENC_SEP_MASK: u32 = 2031616;
pub const ENC_ISO_8601_DATE: u32 = 65536;
pub const ENC_ISO_8601_TIME: u32 = 131072;
pub const ENC_ISO_8601_DATE_TIME: u32 = 196608;
pub const ENC_RFC_822: u32 = 262144;
pub const ENC_RFC_1123: u32 = 524288;
pub const ENC_STR_TIME_MASK: u32 = 983040;
pub const FIELD_DISPLAY_E_MASK: u32 = 255;
pub const BASE_RANGE_STRING: u32 = 256;
pub const BASE_EXT_STRING: u32 = 512;
pub const BASE_VAL64_STRING: u32 = 1024;
pub const BASE_ALLOW_ZERO: u32 = 2048;
pub const BASE_UNIT_STRING: u32 = 4096;
pub const BASE_NO_DISPLAY_VALUE: u32 = 8192;
pub const BASE_PROTOCOL_INFO: u32 = 16384;
pub const BASE_SPECIAL_VALS: u32 = 32768;
pub const BASE_SHOW_ASCII_PRINTABLE: u32 = 65536;
pub const FI_HIDDEN: u32 = 1;
pub const FI_GENERATED: u32 = 2;
pub const FI_URL: u32 = 4;
pub const FI_LITTLE_ENDIAN: u32 = 8;
pub const FI_BIG_ENDIAN: u32 = 16;
pub const FI_VARINT: u32 = 16384;
pub const PI_SEVERITY_MASK: u32 = 15728640;
pub const PI_COMMENT: u32 = 1048576;
pub const PI_CHAT: u32 = 2097152;
pub const PI_NOTE: u32 = 4194304;
pub const PI_WARN: u32 = 6291456;
pub const PI_ERROR: u32 = 8388608;
pub const PI_GROUP_MASK: u32 = 4278190080;
pub const PI_CHECKSUM: u32 = 16777216;
pub const PI_SEQUENCE: u32 = 33554432;
pub const PI_RESPONSE_CODE: u32 = 50331648;
pub const PI_REQUEST_CODE: u32 = 67108864;
pub const PI_UNDECODED: u32 = 83886080;
pub const PI_REASSEMBLE: u32 = 100663296;
pub const PI_MALFORMED: u32 = 117440512;
pub const PI_DEBUG: u32 = 134217728;
pub const PI_PROTOCOL: u32 = 150994944;
pub const PI_SECURITY: u32 = 167772160;
pub const PI_COMMENTS_GROUP: u32 = 184549376;
pub const PI_DECRYPTION: u32 = 201326592;
pub const PI_ASSUMPTION: u32 = 218103808;
pub const PI_DEPRECATED: u32 = 234881024;
pub const BMT_NO_FLAGS: u32 = 0;
pub const BMT_NO_APPEND: u32 = 1;
pub const BMT_NO_INT: u32 = 2;
pub const BMT_NO_FALSE: u32 = 4;
pub const BMT_NO_TFS: u32 = 8;
pub const PROTO_CHECKSUM_NO_FLAGS: u32 = 0;
pub const PROTO_CHECKSUM_VERIFY: u32 = 1;
pub const PROTO_CHECKSUM_GENERATED: u32 = 2;
pub const PROTO_CHECKSUM_IN_CKSUM: u32 = 4;
pub const PROTO_CHECKSUM_ZERO: u32 = 8;
pub const PROTO_CHECKSUM_NOT_PRESENT: u32 = 16;
pub const MAX_SCTP_PORT: u32 = 65535;
pub const MAX_TCP_PORT: u32 = 65535;
pub const MAX_UDP_PORT: u32 = 65535;
pub const MAX_DCCP_PORT: u32 = 65535;
pub const DEF_WIDTH: u32 = 750;
pub const DEF_HEIGHT: u32 = 550;
pub const MAX_VAL_LEN: u32 = 1024;
pub const TAP_UPDATE_DEFAULT_INTERVAL: u32 = 3000;
pub const ST_DEF_BURSTRES: u32 = 5;
pub const ST_DEF_BURSTLEN: u32 = 100;
pub const ST_MAX_BURSTRES: u32 = 600000;
pub const ST_MAX_BURSTBUCKETS: u32 = 100;
pub const FO_STYLE_LAST_OPENED: u32 = 0;
pub const FO_STYLE_SPECIFIED: u32 = 1;
pub const TB_STYLE_ICONS: u32 = 0;
pub const TB_STYLE_TEXT: u32 = 1;
pub const TB_STYLE_BOTH: u32 = 2;
pub const COLOR_STYLE_DEFAULT: u32 = 0;
pub const COLOR_STYLE_FLAT: u32 = 1;
pub const COLOR_STYLE_GRADIENT: u32 = 2;
pub const COLOR_STYLE_ALPHA: f64 = 0.25;
pub type ssize_t = ::std::os::raw::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
extern "C" {
    pub fn _clearfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _controlfp(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _set_controlfp(_NewValue: ::std::os::raw::c_uint, _Mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _controlfp_s(
        _CurrentState: *mut ::std::os::raw::c_uint,
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> errno_t;
}
extern "C" {
    pub fn _statusfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _fpreset();
}
extern "C" {
    pub fn _control87(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __fpecode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpe_flt_rounds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn _scalb(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn _logb(_X: f64) -> f64;
}
extern "C" {
    pub fn _nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _finite(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnan(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclass(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scalbf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn fpreset();
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_longlong;
pub type guint64 = ::std::os::raw::c_ulonglong;
pub type gssize = ::std::os::raw::c_longlong;
pub type gsize = ::std::os::raw::c_ulonglong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_longlong;
pub type guintptr = ::std::os::raw::c_ulonglong;
pub type GPid = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: size_t, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut size_t,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: size_t) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: size_t) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GFreeFunc:"]
#[doc = " @data: a data pointer"]
#[doc = ""]
#[doc = " Declares a type of function which takes an arbitrary"]
#[doc = " data pointer argument and has no return value. It is"]
#[doc = " not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:"]
#[doc = " @str: the untranslated string"]
#[doc = " @data: user data specified when installing the function, e.g."]
#[doc = "  in g_option_group_set_translate_func()"]
#[doc = ""]
#[doc = " The type of functions which are used to translate user-visible"]
#[doc = " strings, for <option>--help</option> output."]
#[doc = ""]
#[doc = " Returns: a translation of the string for the current locale."]
#[doc = "  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
extern "C" {
    pub fn _calloc_base(_Count: size_t, _Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: size_t, _Alignment: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: size_t,
    pub _useflag: ::std::os::raw::c_int,
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
pub type __static_assert_t = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:"]
#[doc = " @domain: error domain, e.g. #G_FILE_ERROR"]
#[doc = " @code: error code, e.g. %G_FILE_ERROR_NOENT"]
#[doc = " @message: human-readable informative error message"]
#[doc = ""]
#[doc = " The `GError` structure contains information about"]
#[doc = " an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: va_list,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_win32_get_system_data_dirs_for_module(
        address_of_function: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:"]
#[doc = " @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory"]
#[doc = " @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory"]
#[doc = " @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory"]
#[doc = " @G_USER_DIRECTORY_MUSIC: the user's Music directory"]
#[doc = " @G_USER_DIRECTORY_PICTURES: the user's Pictures directory"]
#[doc = " @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory"]
#[doc = " @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory"]
#[doc = " @G_USER_DIRECTORY_VIDEOS: the user's Movies directory"]
#[doc = " @G_USER_N_DIRECTORIES: the number of enum values"]
#[doc = ""]
#[doc = " These are logical ids for special directories which are defined"]
#[doc = " depending on the platform used. You should use g_get_user_special_dir()"]
#[doc = " to retrieve the full path associated to the logical id."]
#[doc = ""]
#[doc = " The #GUserDirectory enumeration can be extended at later date. Not"]
#[doc = " every platform has a directory for every logical id in this"]
#[doc = " enumeration."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GUserDirectory = i32;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:"]
#[doc = " @key: the string"]
#[doc = " @value: the flag"]
#[doc = ""]
#[doc = " Associates a string with a bit flag."]
#[doc = " Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(string: *mut gchar, n: gulong, format: *const gchar, args: va_list) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub type GFormatSizeFlags = i32;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:"]
#[doc = ""]
#[doc = " Declares a type of function which takes no arguments"]
#[doc = " and has no return value. It is used to specify the type"]
#[doc = " function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
extern "C" {
    pub fn g_abort();
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = i32;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_mutex_locker_new() for details."]
#[doc = " Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type _crt_signal_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __pxcptinfoptrs() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn signal(_Signal: ::std::os::raw::c_int, _Function: _crt_signal_t) -> _crt_signal_t;
}
extern "C" {
    pub fn raise(_Signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did"]
#[doc = "     not register a bookmark"]
#[doc = " @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_READ: document was ill formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was"]
#[doc = "     in an unknown encoding"]
#[doc = " @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing"]
#[doc = " @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found"]
#[doc = ""]
#[doc = " Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = i32;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:"]
#[doc = ""]
#[doc = " The `GBookmarkFile` structure contains only"]
#[doc = " private data and should not be directly accessed."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:"]
#[doc = " @G_CHECKSUM_MD5: Use the MD5 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)"]
#[doc = " @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)"]
#[doc = ""]
#[doc = " The hashing algorithm to be used by #GChecksum when performing the"]
#[doc = " digest of some data."]
#[doc = ""]
#[doc = " Note that the #GChecksumType enumeration may be extended at a later"]
#[doc = " date to include new hashing algorithm types."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksumType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:"]
#[doc = ""]
#[doc = " An opaque structure representing a checksumming operation."]
#[doc = " To create a new GChecksum, use g_checksum_new(). To free"]
#[doc = " a GChecksum, use g_checksum_free()."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
#[doc = " GConvertError:"]
#[doc = " @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character"]
#[doc = "     sets is not supported."]
#[doc = " @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input."]
#[doc = " @G_CONVERT_ERROR_FAILED: Conversion failed for some reason."]
#[doc = " @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input."]
#[doc = " @G_CONVERT_ERROR_BAD_URI: URI is invalid."]
#[doc = " @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path."]
#[doc = " @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40"]
#[doc = ""]
#[doc = " Error codes returned by character set conversion routines."]
pub type GConvertError = i32;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv:"]
#[doc = ""]
#[doc = " The GIConv struct wraps an iconv() conversion descriptor. It contains"]
#[doc = " private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri_utf8(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri_utf8(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = i32;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = i32;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = i32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:"]
#[doc = " @G_TIME_TYPE_STANDARD: the time is in local standard time"]
#[doc = " @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time"]
#[doc = " @G_TIME_TYPE_UNIVERSAL: the time is in UTC"]
#[doc = ""]
#[doc = " Disambiguates a given time in two ways."]
#[doc = ""]
#[doc = " First, specifies if the given time is in universal or local time."]
#[doc = ""]
#[doc = " Second, if the time is in local time, specifies if it is local"]
#[doc = " standard time or local daylight time.  This is important for the case"]
#[doc = " where the same local time occurs twice (during daylight savings time"]
#[doc = " transitions, for example)."]
pub type GTimeType = i32;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
#[doc = " GTimeSpan:"]
#[doc = ""]
#[doc = " A value representing an interval of time, in microseconds."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:"]
#[doc = ""]
#[doc = " `GDateTime` is an opaque structure whose members"]
#[doc = " cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_open_utf8(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name_utf8(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_getenv_utf8(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv_utf8(
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv_utf8(variable: *const gchar);
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = i32;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = i32;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_file_test_utf8(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents_utf8(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mkstemp_utf8(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp_utf8(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_get_current_dir_utf8() -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:"]
#[doc = " @malloc: function to use for allocating memory."]
#[doc = " @realloc: function to use for reallocating memory."]
#[doc = " @free: function to use to free memory."]
#[doc = " @calloc: function to use for allocating zero-filled memory."]
#[doc = " @try_malloc: function to use for allocating memory without a default error handler."]
#[doc = " @try_realloc: function to use for reallocating memory without a default error handler."]
#[doc = ""]
#[doc = " A set of functions used to perform memory allocation. The same #GMemVTable must"]
#[doc = " be used for all allocations in the same program; a call to g_mem_set_vtable(),"]
#[doc = " if it exists, should be prior to any use of GLib."]
#[doc = ""]
#[doc = " This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = i32;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = i32;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[doc = " GCopyFunc:"]
#[doc = " @src: (not nullable): A pointer to the data which should be copied"]
#[doc = " @data: Additional data"]
#[doc = ""]
#[doc = " A function of this signature is used to copy the node data"]
#[doc = " when doing a deep-copy of a tree."]
#[doc = ""]
#[doc = " Returns: (not nullable): A pointer to the copy"]
#[doc = ""]
#[doc = " Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:"]
#[doc = ""]
#[doc = " An opaque structure representing a HMAC operation."]
#[doc = " To create a new GHmac, use g_hmac_new(). To free"]
#[doc = " a GHmac, use g_hmac_unref()."]
#[doc = ""]
#[doc = " Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:"]
#[doc = " @ufds: an array of #GPollFD elements"]
#[doc = " @nfsd: the number of elements in @ufds"]
#[doc = " @timeout_: the maximum time to wait for an event of the file descriptors."]
#[doc = "     A negative value indicates an infinite timeout."]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_main_context_set_poll_func()."]
#[doc = " The semantics of the function should match those of the poll() system call."]
#[doc = ""]
#[doc = " Returns: the number of #GPollFD elements which have events or errors"]
#[doc = "     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:"]
#[doc = " @fd: the file descriptor to poll (or a HANDLE on Win32)"]
#[doc = " @events: a bitwise combination from #GIOCondition, specifying which"]
#[doc = "     events should be polled for. Typically for reading from a file"]
#[doc = "     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and"]
#[doc = "     for writing you would use %G_IO_OUT | %G_IO_ERR."]
#[doc = " @revents: a bitwise combination of flags from #GIOCondition, returned"]
#[doc = "     from the poll() function to indicate which events occurred."]
#[doc = ""]
#[doc = " Represents a file descriptor, which events to poll for, and which events"]
#[doc = " occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint64,
    pub events: gushort,
    pub revents: gushort,
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:"]
    #[doc = ""]
    #[doc = " A format specifier that can be used in printf()-style format strings"]
    #[doc = " when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:"]
#[doc = ""]
#[doc = " The `GMainContext` struct is an opaque data"]
#[doc = " type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:"]
#[doc = ""]
#[doc = " The `GMainLoop` struct is an opaque data type"]
#[doc = " representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:"]
#[doc = ""]
#[doc = " The `GSource` struct is an opaque data type"]
#[doc = " representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:"]
#[doc = " @ref: Called when a reference is added to the callback object"]
#[doc = " @unref: Called when a reference to the callback object is dropped"]
#[doc = " @get: Called to extract the callback function and data from the"]
#[doc = "     callback object."]
#[doc = ""]
#[doc = " The `GSourceCallbackFuncs` struct contains"]
#[doc = " functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:"]
#[doc = " @prepare: Called before all the file descriptors are polled. If the"]
#[doc = "     source can determine that it is ready here (without waiting for the"]
#[doc = "     results of the poll() call) it should return %TRUE. It can also return"]
#[doc = "     a @timeout_ value which should be the maximum timeout (in milliseconds)"]
#[doc = "     which should be passed to the poll() call. The actual timeout used will"]
#[doc = "     be -1 if all sources returned -1, or it will be the minimum of all"]
#[doc = "     the @timeout_ values returned which were >= 0.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE with a timeout of -1.  If @prepare returns a"]
#[doc = "     timeout and the source also has a 'ready time' set then the"]
#[doc = "     nearer of the two will be used."]
#[doc = " @check: Called after all the file descriptors are polled. The source"]
#[doc = "     should return %TRUE if it is ready to be dispatched. Note that some"]
#[doc = "     time may have passed since the previous prepare function was called,"]
#[doc = "     so the source should be checked again here.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE."]
#[doc = " @dispatch: Called to dispatch the event source, after it has returned"]
#[doc = "     %TRUE in either its @prepare or its @check function. The @dispatch"]
#[doc = "     function is passed in a callback function and data. The callback"]
#[doc = "     function may be %NULL if the source was never connected to a callback"]
#[doc = "     using g_source_set_callback(). The @dispatch function should call the"]
#[doc = "     callback function with @user_data and whatever additional parameters"]
#[doc = "     are needed for this type of event source. The return value of the"]
#[doc = "     @dispatch function should be #G_SOURCE_REMOVE if the source should be"]
#[doc = "     removed or #G_SOURCE_CONTINUE to keep it."]
#[doc = " @finalize: Called when the source is finalized. At this point, the source"]
#[doc = "     will have been destroyed, had its callback cleared, and have been removed"]
#[doc = "     from its #GMainContext, but it will still have its final reference count;"]
#[doc = "     so methods can be called on it from within this function."]
#[doc = ""]
#[doc = " The `GSourceFuncs` struct contains a table of"]
#[doc = " functions used to handle event sources in a generic manner."]
#[doc = ""]
#[doc = " For idle sources, the prepare and check functions always return %TRUE"]
#[doc = " to indicate that the source is always ready to be processed. The prepare"]
#[doc = " function also returns a timeout value of 0 to ensure that the poll() call"]
#[doc = " doesn't block (since that would be time wasted which could have been spent"]
#[doc = " running the idle function)."]
#[doc = ""]
#[doc = " For timeout sources, the prepare and check functions both return %TRUE"]
#[doc = " if the timeout interval has expired. The prepare function also returns"]
#[doc = " a timeout value to ensure that the poll() call doesn't block too long"]
#[doc = " and miss the next timeout."]
#[doc = ""]
#[doc = " For file descriptor sources, the prepare function typically returns %FALSE,"]
#[doc = " since it must wait until poll() has been called before it knows whether"]
#[doc = " any events need to be processed. It sets the returned timeout to -1 to"]
#[doc = " indicate that it doesn't mind how long the poll() call blocks. In the"]
#[doc = " check function, it tests the results of the poll() call to see if the"]
#[doc = " required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:"]
#[doc = " @user_data: data passed to the function, set when the source was"]
#[doc = "     created with one of the above functions"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_timeout_add(),"]
#[doc = " g_timeout_add_full(), g_idle_add(), and g_idle_add_full()."]
#[doc = ""]
#[doc = " Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and"]
#[doc = " #G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GChildWatchFunc:"]
#[doc = " @pid: the process id of the child process"]
#[doc = " @status: Status information about the child process, encoded"]
#[doc = "     in a platform-specific manner"]
#[doc = " @user_data: user data passed to g_child_watch_add()"]
#[doc = ""]
#[doc = " Prototype of a #GChildWatchSource callback, called when a child"]
#[doc = " process has exited.  To interpret @status, see the documentation"]
#[doc = " for g_spawn_check_exit_status()."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[doc = " GSourceDummyMarshal:"]
#[doc = ""]
#[doc = " This is just a placeholder for #GClosureMarshal,"]
#[doc = " which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
#[doc = " gunichar:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-32 or UCS-4 character code,"]
#[doc = " also known as a Unicode code point."]
#[doc = ""]
#[doc = " If you want to produce the UTF-8 representation of a #gunichar,"]
#[doc = " use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse"]
#[doc = " process."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT."]
#[doc = ""]
#[doc = " The notation to express a Unicode code point in running text is"]
#[doc = " as a hexadecimal number with four to six digits and uppercase"]
#[doc = " letters, prefixed by the string \"U+\". Leading zeros are omitted,"]
#[doc = " unless the code point would have fewer than four hexadecimal digits."]
#[doc = " For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point"]
#[doc = " in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\"."]
#[doc = " To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\"."]
#[doc = ""]
#[doc = " |["]
#[doc = " gunichar c;"]
#[doc = " sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)"]
#[doc = " g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);"]
#[doc = " ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-16 code"]
#[doc = " point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called"]
#[doc = " <firstterm>surrogate pairs</firstterm> to encode characters beyond"]
#[doc = " the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored"]
#[doc = " in a single gunichar2 field, but all GLib functions accepting gunichar2"]
#[doc = " arrays will correctly interpret surrogate pairs.</footnote>."]
#[doc = ""]
#[doc = " To print/scan values of this type to/from text you need to convert"]
#[doc = " to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16()."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:"]
#[doc = " @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)"]
#[doc = " @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)"]
#[doc = " @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)"]
#[doc = " @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)"]
#[doc = " @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)"]
#[doc = " @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)"]
#[doc = " @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)"]
#[doc = " @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)"]
#[doc = " @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)"]
#[doc = " @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)"]
#[doc = " @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)"]
#[doc = " @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)"]
#[doc = " @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)"]
#[doc = " @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)"]
#[doc = " @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)"]
#[doc = " @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)"]
#[doc = " @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)"]
#[doc = " @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)"]
#[doc = " @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)"]
#[doc = " @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)"]
#[doc = " @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)"]
#[doc = " @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)"]
#[doc = " @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)"]
#[doc = " @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)"]
#[doc = " @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)"]
#[doc = " @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)"]
#[doc = " @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)"]
#[doc = " @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)"]
#[doc = " @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)"]
#[doc = " @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)"]
#[doc = ""]
#[doc = " These are the possible character classifications from the"]
#[doc = " Unicode specification."]
#[doc = " See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = i32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:"]
#[doc = " @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)"]
#[doc = " @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)"]
#[doc = " @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)"]
#[doc = " @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)"]
#[doc = " @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)"]
#[doc = " @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)"]
#[doc = " @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)"]
#[doc = " @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)"]
#[doc = " @G_UNICODE_BREAK_SPACE: Space (SP)"]
#[doc = " @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)"]
#[doc = " @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)"]
#[doc = " @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)"]
#[doc = " @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)"]
#[doc = " @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)"]
#[doc = " @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)"]
#[doc = " @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)"]
#[doc = " @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)"]
#[doc = " @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)"]
#[doc = " @G_UNICODE_BREAK_NUMERIC: Numeric (NU)"]
#[doc = " @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)"]
#[doc = " @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)"]
#[doc = " @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)"]
#[doc = " @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)"]
#[doc = " @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)"]
#[doc = " @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)"]
#[doc = " @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)"]
#[doc = " @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)"]
#[doc = " @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)"]
#[doc = " @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28"]
#[doc = " @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36"]
#[doc = " @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50"]
#[doc = ""]
#[doc = " These are the possible line break classifications."]
#[doc = ""]
#[doc = " Since new unicode versions may add new types here, applications should be ready"]
#[doc = " to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN."]
#[doc = ""]
#[doc = " See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/)."]
pub type GUnicodeBreakType = i32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
#[doc = " GUnicodeScript:"]
#[doc = " @G_UNICODE_SCRIPT_INVALID_CODE:"]
#[doc = "                               a value never returned from g_unichar_get_script()"]
#[doc = " @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts"]
#[doc = " @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the"]
#[doc = "                               base glyph to which it is attached"]
#[doc = " @G_UNICODE_SCRIPT_ARABIC:     Arabic"]
#[doc = " @G_UNICODE_SCRIPT_ARMENIAN:   Armenian"]
#[doc = " @G_UNICODE_SCRIPT_BENGALI:    Bengali"]
#[doc = " @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo"]
#[doc = " @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee"]
#[doc = " @G_UNICODE_SCRIPT_COPTIC:     Coptic"]
#[doc = " @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic"]
#[doc = " @G_UNICODE_SCRIPT_DESERET:    Deseret"]
#[doc = " @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari"]
#[doc = " @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic"]
#[doc = " @G_UNICODE_SCRIPT_GEORGIAN:   Georgian"]
#[doc = " @G_UNICODE_SCRIPT_GOTHIC:     Gothic"]
#[doc = " @G_UNICODE_SCRIPT_GREEK:      Greek"]
#[doc = " @G_UNICODE_SCRIPT_GUJARATI:   Gujarati"]
#[doc = " @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi"]
#[doc = " @G_UNICODE_SCRIPT_HAN:        Han"]
#[doc = " @G_UNICODE_SCRIPT_HANGUL:     Hangul"]
#[doc = " @G_UNICODE_SCRIPT_HEBREW:     Hebrew"]
#[doc = " @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana"]
#[doc = " @G_UNICODE_SCRIPT_KANNADA:    Kannada"]
#[doc = " @G_UNICODE_SCRIPT_KATAKANA:   Katakana"]
#[doc = " @G_UNICODE_SCRIPT_KHMER:      Khmer"]
#[doc = " @G_UNICODE_SCRIPT_LAO:        Lao"]
#[doc = " @G_UNICODE_SCRIPT_LATIN:      Latin"]
#[doc = " @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam"]
#[doc = " @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian"]
#[doc = " @G_UNICODE_SCRIPT_MYANMAR:    Myanmar"]
#[doc = " @G_UNICODE_SCRIPT_OGHAM:      Ogham"]
#[doc = " @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic"]
#[doc = " @G_UNICODE_SCRIPT_ORIYA:      Oriya"]
#[doc = " @G_UNICODE_SCRIPT_RUNIC:      Runic"]
#[doc = " @G_UNICODE_SCRIPT_SINHALA:    Sinhala"]
#[doc = " @G_UNICODE_SCRIPT_SYRIAC:     Syriac"]
#[doc = " @G_UNICODE_SCRIPT_TAMIL:      Tamil"]
#[doc = " @G_UNICODE_SCRIPT_TELUGU:     Telugu"]
#[doc = " @G_UNICODE_SCRIPT_THAANA:     Thaana"]
#[doc = " @G_UNICODE_SCRIPT_THAI:       Thai"]
#[doc = " @G_UNICODE_SCRIPT_TIBETAN:    Tibetan"]
#[doc = " @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:"]
#[doc = "                               Canadian Aboriginal"]
#[doc = " @G_UNICODE_SCRIPT_YI:         Yi"]
#[doc = " @G_UNICODE_SCRIPT_TAGALOG:    Tagalog"]
#[doc = " @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo"]
#[doc = " @G_UNICODE_SCRIPT_BUHID:      Buhid"]
#[doc = " @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa"]
#[doc = " @G_UNICODE_SCRIPT_BRAILLE:    Braille"]
#[doc = " @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot"]
#[doc = " @G_UNICODE_SCRIPT_LIMBU:      Limbu"]
#[doc = " @G_UNICODE_SCRIPT_OSMANYA:    Osmanya"]
#[doc = " @G_UNICODE_SCRIPT_SHAVIAN:    Shavian"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_B:   Linear B"]
#[doc = " @G_UNICODE_SCRIPT_TAI_LE:     Tai Le"]
#[doc = " @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic"]
#[doc = " @G_UNICODE_SCRIPT_NEW_TAI_LUE:"]
#[doc = "                               New Tai Lue"]
#[doc = " @G_UNICODE_SCRIPT_BUGINESE:   Buginese"]
#[doc = " @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic"]
#[doc = " @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh"]
#[doc = " @G_UNICODE_SCRIPT_SYLOTI_NAGRI:"]
#[doc = "                               Syloti Nagri"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERSIAN:"]
#[doc = "                               Old Persian"]
#[doc = " @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi"]
#[doc = " @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point"]
#[doc = " @G_UNICODE_SCRIPT_BALINESE:   Balinese"]
#[doc = " @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform"]
#[doc = " @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician"]
#[doc = " @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa"]
#[doc = " @G_UNICODE_SCRIPT_NKO:        N'Ko"]
#[doc = " @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:"]
#[doc = "                               Egyptian Hieroglpyhs. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:"]
#[doc = "                               Imperial Aramaic. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:"]
#[doc = "                               Inscriptional Pahlavi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:"]
#[doc = "                               Inscriptional Parthian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_MEETEI_MAYEK:"]
#[doc = "                               Meetei Mayek. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:"]
#[doc = "                               Old South Arabian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50"]
#[doc = ""]
#[doc = " The #GUnicodeScript enumeration identifies different writing"]
#[doc = " systems. The values correspond to the names as defined in the"]
#[doc = " Unicode standard. The enumeration has been added in GLib 2.14,"]
#[doc = " and is interchangeable with #PangoScript."]
#[doc = ""]
#[doc = " Note that new types may be added in the future. Applications"]
#[doc = " should be ready to handle unknown values."]
#[doc = " See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = i32;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize, end: *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:"]
#[doc = " @G_NORMALIZE_DEFAULT: standardize differences that do not affect the"]
#[doc = "     text content, such as the above-mentioned accent representation"]
#[doc = " @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT"]
#[doc = " @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with"]
#[doc = "     composed forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE"]
#[doc = " @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the"]
#[doc = "     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE"]
#[doc = "     to the standard forms (in this case DIGIT THREE). Formatting"]
#[doc = "     information may be lost but for most text operations such"]
#[doc = "     characters should be considered the same"]
#[doc = " @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL"]
#[doc = " @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed"]
#[doc = "     forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE"]
#[doc = ""]
#[doc = " Defines how a Unicode string is transformed in a canonical"]
#[doc = " form, standardizing such issues as whether a character with"]
#[doc = " an accent is represented as a base character and combining"]
#[doc = " accent or as a single precomposed character. Unicode strings"]
#[doc = " should generally be normalized before comparing them."]
pub type GNormalizeMode = i32;
extern "C" {
    pub fn g_utf8_normalize(str: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(string: *mut GString, format: *const gchar, args: va_list);
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = i32;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = i32;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = i32;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = i32;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u64,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub fn g_io_channel_win32_make_pollfd(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        fd: *mut GPollFD,
    );
}
extern "C" {
    pub fn g_io_channel_win32_poll(fds: *mut GPollFD, n_fds: gint, timeout_: gint) -> gint;
}
extern "C" {
    pub fn g_io_channel_win32_new_messages(hwnd: gsize) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_new_fd(fd: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub fn g_io_channel_win32_new_socket(socket: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_new_stream_socket(socket: gint) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_win32_set_debug(channel: *mut GIOChannel, flag: gboolean);
}
extern "C" {
    pub fn g_io_channel_new_file_utf8(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = i32;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = i32;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:"]
#[doc = " @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8"]
#[doc = " @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace"]
#[doc = " @G_MARKUP_ERROR_PARSE: document was ill-formed"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser"]
#[doc = "     functions; element wasn't known"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; attribute wasn't known"]
#[doc = " @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser"]
#[doc = "     functions; content was invalid"]
#[doc = " @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; a required attribute was missing"]
#[doc = ""]
#[doc = " Error codes returned by markup parsing."]
pub type GMarkupError = i32;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:"]
#[doc = " @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use"]
#[doc = " @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked"]
#[doc = "     sections are not passed literally to the @passthrough function of"]
#[doc = "     the parser. Instead, the content of the section (without the"]
#[doc = "     `<![CDATA[` and `]]>`) is"]
#[doc = "     passed to the @text function. This flag was added in GLib 2.12"]
#[doc = " @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup"]
#[doc = "     itself have line/column information prefixed to them to let the"]
#[doc = "     caller know the location of the error. When this flag is set the"]
#[doc = "     location information is also prefixed to errors generated by the"]
#[doc = "     #GMarkupParser implementation functions"]
#[doc = " @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified"]
#[doc = "     attributes and tags, along with their contents.  A qualified"]
#[doc = "     attribute or tag is one that contains ':' in its name (ie: is in"]
#[doc = "     another namespace).  Since: 2.40."]
#[doc = ""]
#[doc = " Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:"]
#[doc = ""]
#[doc = " A parse context is used to parse a stream of bytes that"]
#[doc = " you expect to contain marked-up text."]
#[doc = ""]
#[doc = " See g_markup_parse_context_new(), #GMarkupParser, and so"]
#[doc = " on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:"]
#[doc = " @start_element: Callback to invoke when the opening tag of an element"]
#[doc = "     is seen. The callback's @attribute_names and @attribute_values parameters"]
#[doc = "     are %NULL-terminated."]
#[doc = " @end_element: Callback to invoke when the closing tag of an element"]
#[doc = "     is seen. Note that this is also called for empty tags like"]
#[doc = "     `<empty/>`."]
#[doc = " @text: Callback to invoke when some text is seen (text is always"]
#[doc = "     inside an element). Note that the text of an element may be spread"]
#[doc = "     over multiple calls of this function. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also"]
#[doc = "     called for the content of CDATA marked sections."]
#[doc = " @passthrough: Callback to invoke for comments, processing instructions"]
#[doc = "     and doctype declarations; if you're re-writing the parsed document,"]
#[doc = "     write the passthrough text back out in the same position. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also"]
#[doc = "     called for CDATA marked sections."]
#[doc = " @error: Callback to invoke when an error occurs."]
#[doc = ""]
#[doc = " Any of the fields in #GMarkupParser can be %NULL, in which case they"]
#[doc = " will be ignored. Except for the @error function, any of these callbacks"]
#[doc = " can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,"]
#[doc = " %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT"]
#[doc = " errors are intended to be set from these callbacks. If you set an error"]
#[doc = " from a callback, g_markup_parse_context_parse() will report that error"]
#[doc = " back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = i32;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:"]
#[doc = ""]
#[doc = " A type in the GVariant type system."]
#[doc = ""]
#[doc = " Two types may not be compared by value; use g_variant_type_equal() or"]
#[doc = " g_variant_type_is_subtype_of().  May be copied using"]
#[doc = " g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = i32;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guchar;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub type GVariantParseError = i32;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: va_list) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = i32;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: va_list,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:"]
#[doc = " @G_LOG_WRITER_HANDLED: Log writer has handled the log entry."]
#[doc = " @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry."]
#[doc = ""]
#[doc = " Return values from #GLogWriterFuncs to indicate whether the given log entry"]
#[doc = " was successfully handled by the writer, or whether there was an error in"]
#[doc = " handling it (and hence a fallback writer should be used)."]
#[doc = ""]
#[doc = " If a #GLogWriterFunc ignores a log entry, it should return"]
#[doc = " %G_LOG_WRITER_HANDLED."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogWriterOutput = i32;
#[doc = " GLogField:"]
#[doc = " @key: field name (UTF-8 string)"]
#[doc = " @value: field value (arbitrary bytes)"]
#[doc = " @length: length of @value, in bytes, or -1 if it is nul-terminated"]
#[doc = ""]
#[doc = " Structure representing a single field in a structured log entry. See"]
#[doc = " g_log_structured() for details."]
#[doc = ""]
#[doc = " Log fields may contain arbitrary values, including binary with embedded nul"]
#[doc = " bytes. If the field contains a string, the string must be UTF-8 encoded and"]
#[doc = " have a trailing nul byte. Otherwise, @length must be set to a non-negative"]
#[doc = " value."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[doc = " GLogWriterFunc:"]
#[doc = " @log_level: log level of the message"]
#[doc = " @fields: (array length=n_fields): fields forming the message"]
#[doc = " @n_fields: number of @fields"]
#[doc = " @user_data: user data passed to g_log_set_writer_func()"]
#[doc = ""]
#[doc = " Writer function for log entries. A log entry is a collection of one or more"]
#[doc = " #GLogFields, using the standard [field names from journal"]
#[doc = " specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)."]
#[doc = " See g_log_structured() for more information."]
#[doc = ""]
#[doc = " Writer functions must ignore fields which they do not recognise, unless they"]
#[doc = " can write arbitrary binary output, as field values may be arbitrary binary."]
#[doc = ""]
#[doc = " @log_level is guaranteed to be included in @fields as the `PRIORITY` field,"]
#[doc = " but is provided separately for convenience of deciding whether or where to"]
#[doc = " output the log entry."]
#[doc = ""]
#[doc = " Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;"]
#[doc = "    %G_LOG_WRITER_UNHANDLED otherwise"]
#[doc = " Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
#[doc = " GPrintFunc:"]
#[doc = " @string: the message to output"]
#[doc = ""]
#[doc = " Specifies the type of the print handler functions."]
#[doc = " These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:"]
#[doc = ""]
#[doc = " A `GOptionContext` struct defines which options"]
#[doc = " are accepted by the commandline option parser. The struct has only private"]
#[doc = " fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:"]
#[doc = ""]
#[doc = " A `GOptionGroup` struct defines the options in a single"]
#[doc = " group. The struct has only private fields and should not be directly accessed."]
#[doc = ""]
#[doc = " All options in a group share the same translation function. Libraries which"]
#[doc = " need to parse commandline options are expected to provide a function for"]
#[doc = " getting a `GOptionGroup` holding their options, which"]
#[doc = " the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:"]
#[doc = " @G_OPTION_FLAG_NONE: No flags. Since: 2.42."]
#[doc = " @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output."]
#[doc = " @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the"]
#[doc = "     `--help` output, even if it is defined in a group."]
#[doc = " @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this"]
#[doc = "     flag indicates that the sense of the option is reversed."]
#[doc = " @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,"]
#[doc = "     this flag indicates that the callback does not take any argument"]
#[doc = "     (like a %G_OPTION_ARG_NONE option). Since 2.8"]
#[doc = " @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument should be passed to the"]
#[doc = "     callback in the GLib filename encoding rather than UTF-8. Since 2.8"]
#[doc = " @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument supply is optional."]
#[doc = "     If no argument is given then data of %GOptionParseFunc will be"]
#[doc = "     set to NULL. Since 2.8"]
#[doc = " @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict"]
#[doc = "     resolution which prefixes long option names with `groupname-` if"]
#[doc = "     there is a conflict. This option should only be used in situations"]
#[doc = "     where aliasing is necessary to model some legacy commandline interface."]
#[doc = "     It is not safe to use this option, unless all option groups are under"]
#[doc = "     your direct control. Since 2.8."]
#[doc = ""]
#[doc = " Flags which modify individual options."]
pub type GOptionFlags = i32;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:"]
#[doc = " @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags."]
#[doc = " @G_OPTION_ARG_STRING: The option takes a string argument."]
#[doc = " @G_OPTION_ARG_INT: The option takes an integer argument."]
#[doc = " @G_OPTION_ARG_CALLBACK: The option provides a callback (of type"]
#[doc = "     #GOptionArgFunc) to parse the extra argument."]
#[doc = " @G_OPTION_ARG_FILENAME: The option takes a filename as argument."]
#[doc = " @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple"]
#[doc = "     uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,"]
#[doc = "     multiple uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument"]
#[doc = "     can be formatted either for the user's locale or for the \"C\" locale."]
#[doc = "     Since 2.12"]
#[doc = " @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like"]
#[doc = "     %G_OPTION_ARG_INT but for larger numbers. The number can be in"]
#[doc = "     decimal base, or in hexadecimal (when prefixed with `0x`, for"]
#[doc = "     example, `0xffffffff`). Since 2.12"]
#[doc = ""]
#[doc = " The #GOptionArg enum values determine which type of extra argument the"]
#[doc = " options expect to find. If an option expects an extra argument, it can"]
#[doc = " be specified in several ways; with a short option: `-x arg`, with a long"]
#[doc = " option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = i32;
#[doc = " GOptionArgFunc:"]
#[doc = " @option_name: The name of the option being parsed. This will be either a"]
#[doc = "  single dash followed by a single letter (for a short name) or two dashes"]
#[doc = "  followed by a long option name."]
#[doc = " @value: The value to be parsed."]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED"]
#[doc = "  is intended to be used for errors in #GOptionArgFunc callbacks."]
#[doc = ""]
#[doc = " The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK"]
#[doc = " options."]
#[doc = ""]
#[doc = " Returns: %TRUE if the option was successfully parsed, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for error details"]
#[doc = ""]
#[doc = " The type of function that can be called before and after parsing."]
#[doc = ""]
#[doc = " Returns: %TRUE if the function completed successfully, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: The #GError containing details about the parse error"]
#[doc = ""]
#[doc = " The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:"]
#[doc = " @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser."]
#[doc = "  This error will only be reported, if the parser hasn't been instructed"]
#[doc = "  to ignore unknown options, see g_option_context_set_ignore_unknown_options()."]
#[doc = " @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed."]
#[doc = " @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed."]
#[doc = ""]
#[doc = " Error codes returned by option parsing."]
pub type GOptionError = i32;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:"]
#[doc = " @long_name: The long name of an option can be used to specify it"]
#[doc = "     in a commandline as `--long_name`. Every option must have a"]
#[doc = "     long name. To resolve conflicts if multiple option groups contain"]
#[doc = "     the same long name, it is also possible to specify the option as"]
#[doc = "     `--groupname-long_name`."]
#[doc = " @short_name: If an option has a short name, it can be specified"]
#[doc = "     `-short_name` in a commandline. @short_name must be  a printable"]
#[doc = "     ASCII character different from '-', or zero if the option has no"]
#[doc = "     short name."]
#[doc = " @flags: Flags from #GOptionFlags"]
#[doc = " @arg: The type of the option, as a #GOptionArg"]
#[doc = " @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data"]
#[doc = "     must point to a #GOptionArgFunc callback function, which will be"]
#[doc = "     called to handle the extra argument. Otherwise, @arg_data is a"]
#[doc = "     pointer to a location to store the value, the required type of"]
#[doc = "     the location depends on the @arg type:"]
#[doc = "     - %G_OPTION_ARG_NONE: %gboolean"]
#[doc = "     - %G_OPTION_ARG_STRING: %gchar*"]
#[doc = "     - %G_OPTION_ARG_INT: %gint"]
#[doc = "     - %G_OPTION_ARG_FILENAME: %gchar*"]
#[doc = "     - %G_OPTION_ARG_STRING_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_DOUBLE: %gdouble"]
#[doc = "     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,"]
#[doc = "     the location will contain a newly allocated string if the option"]
#[doc = "     was given. That string needs to be freed by the callee using g_free()."]
#[doc = "     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or"]
#[doc = "     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev()."]
#[doc = " @description: the description for the option in `--help`"]
#[doc = "     output. The @description is translated using the @translate_func"]
#[doc = "     of the group, see g_option_group_set_translation_domain()."]
#[doc = " @arg_description: The placeholder to use for the extra argument parsed"]
#[doc = "     by the option in `--help` output. The @arg_description is translated"]
#[doc = "     using the @translate_func of the group, see"]
#[doc = "     g_option_group_set_translation_domain()."]
#[doc = ""]
#[doc = " A GOptionEntry struct defines a single option. To have an effect, they"]
#[doc = " must be added to a #GOptionGroup with g_option_context_add_main_entries()"]
#[doc = " or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
pub type GQueue = _GQueue;
#[doc = " GQueue:"]
#[doc = " @head: a pointer to the first element of the queue"]
#[doc = " @tail: a pointer to the last element of the queue"]
#[doc = " @length: the number of elements in the queue"]
#[doc = ""]
#[doc = " Contains the public fields of a"]
#[doc = " [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:"]
#[doc = " @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement"]
#[doc = "     string."]
#[doc = " @G_REGEX_ERROR_MATCH: The match process failed."]
#[doc = " @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\""]
#[doc = "     quantifier. Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for"]
#[doc = "     character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence"]
#[doc = "     in character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\","]
#[doc = "     \"(?<\" or \"(?P\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are"]
#[doc = "     supported only within a class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\""]
#[doc = "     without opening \"(\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent"]
#[doc = "     subpattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16"]
#[doc = " @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not"]
#[doc = "     fixed length. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains"]
#[doc = "     more than two branches. Since 2.16"]
#[doc = " @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating"]
#[doc = "     elements are not supported. Since 2.16"]
#[doc = " @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence"]
#[doc = "     is too large. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in"]
#[doc = "     lookbehind assertion. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator"]
#[doc = "     in subpattern name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have"]
#[doc = "     the same name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or"]
#[doc = "     \"\\\\p\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long"]
#[doc = "     (maximum 32 characters). Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum"]
#[doc = "     10,000). Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more"]
#[doc = "     than one branch. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed."]
#[doc = "     This error is never raised. Since: 2.16 Deprecated: 2.34"]
#[doc = " @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,"]
#[doc = "      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing"]
#[doc = "     control verb used does not allow an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing"]
#[doc = "     control verb. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,"]
#[doc = "     \"[\" is an invalid data character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the"]
#[doc = "     same number are not allowed. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control"]
#[doc = "     verb requires an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII"]
#[doc = "     character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or"]
#[doc = "     quoted name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\","]
#[doc = "     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34"]
#[doc = " @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is"]
#[doc = "     too large. Since: 2.34"]
#[doc = ""]
#[doc = " Error codes returned by regular expressions functions."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexError = i32;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:"]
#[doc = " @G_REGEX_CASELESS: Letters in the pattern match both upper- and"]
#[doc = "     lowercase letters. This option can be changed within a pattern"]
#[doc = "     by a \"(?i)\" option setting."]
#[doc = " @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting"]
#[doc = "     of a single line of characters (even if it actually contains"]
#[doc = "     newlines). The \"start of line\" metacharacter (\"^\") matches only"]
#[doc = "     at the start of the string, while the \"end of line\" metacharacter"]
#[doc = "     (\"$\") matches only at the end of the string, or before a terminating"]
#[doc = "     newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When"]
#[doc = "     #G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\""]
#[doc = "     constructs match immediately following or immediately before any"]
#[doc = "     newline in the string, respectively, as well as at the very start"]
#[doc = "     and end. This can be changed within a pattern by a \"(?m)\" option"]
#[doc = "     setting."]
#[doc = " @G_REGEX_DOTALL: A dot metacharater (\".\") in the pattern matches all"]
#[doc = "     characters, including newlines. Without it, newlines are excluded."]
#[doc = "     This option can be changed within a pattern by a (\"?s\") option setting."]
#[doc = " @G_REGEX_EXTENDED: Whitespace data characters in the pattern are"]
#[doc = "     totally ignored except when escaped or inside a character class."]
#[doc = "     Whitespace does not include the VT character (code 11). In addition,"]
#[doc = "     characters between an unescaped \"#\" outside a character class and"]
#[doc = "     the next newline character, inclusive, are also ignored. This can"]
#[doc = "     be changed within a pattern by a \"(?x)\" option setting."]
#[doc = " @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharater."]
#[doc = " @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern"]
#[doc = "     matches only at the end of the string. Without this option, a"]
#[doc = "     dollar also matches immediately before the final character if"]
#[doc = "     it is a newline (but not before any other newlines). This option"]
#[doc = "     is ignored if #G_REGEX_MULTILINE is set."]
#[doc = " @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that"]
#[doc = "     they are not greedy by default, but become greedy if followed by \"?\"."]
#[doc = "     It can also be set by a \"(?U)\" option setting within the pattern."]
#[doc = " @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this"]
#[doc = "     flag they are considered as a raw sequence of bytes."]
#[doc = " @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing"]
#[doc = "     parentheses in the pattern. Any opening parenthesis that is not"]
#[doc = "     followed by \"?\" behaves as if it were followed by \"?:\" but named"]
#[doc = "     parentheses can still be used for capturing (and they acquire numbers"]
#[doc = "     in the usual way)."]
#[doc = " @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will"]
#[doc = "     be used many times, then it may be worth the effort to optimize it"]
#[doc = "     to improve the speed of matches."]
#[doc = " @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the"]
#[doc = "     first newline. Since: 2.34"]
#[doc = " @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not"]
#[doc = "     be unique. This can be helpful for certain types of pattern when it"]
#[doc = "     is known that only one instance of the named subpattern can ever be"]
#[doc = "     matched."]
#[doc = " @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\r'."]
#[doc = " @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\n'."]
#[doc = " @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequence is '\\r\\n'."]
#[doc = " @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognised. If this option is set, then \"\\R\" only recognizes the newline"]
#[doc = "    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with"]
#[doc = "     JavaScript rather than PCRE. Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying compile-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexCompileFlags = i32;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:"]
#[doc = " @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharater."]
#[doc = " @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is"]
#[doc = "     not the beginning of a line, so the circumflex metacharacter should"]
#[doc = "     not match before it. Setting this without #G_REGEX_MULTILINE (at"]
#[doc = "     compile time) causes circumflex never to match. This option affects"]
#[doc = "     only the behaviour of the circumflex metacharacter, it does not"]
#[doc = "     affect \"\\A\"."]
#[doc = " @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is"]
#[doc = "     not the end of a line, so the dollar metacharacter should not match"]
#[doc = "     it nor (except in multiline mode) a newline immediately before it."]
#[doc = "     Setting this without #G_REGEX_MULTILINE (at compile time) causes"]
#[doc = "     dollar never to match. This option affects only the behaviour of"]
#[doc = "     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\"."]
#[doc = " @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid"]
#[doc = "     match if this option is set. If there are alternatives in the pattern,"]
#[doc = "     they are tried. If all the alternatives match the empty string, the"]
#[doc = "     entire match fails. For example, if the pattern \"a?b?\" is applied to"]
#[doc = "     a string not beginning with \"a\" or \"b\", it matches the empty string"]
#[doc = "     at the start of the string. With this flag set, this match is not"]
#[doc = "     valid, so GRegex searches further into the string for occurrences"]
#[doc = "     of \"a\" or \"b\"."]
#[doc = " @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more"]
#[doc = "     documentation on partial matching see g_match_info_is_partial_match()."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\n' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, any Unicode newline sequence"]
#[doc = "     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence"]
#[doc = "     is recognized as a newline. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences"]
#[doc = "     are recognized as a newline by \"\\R\". Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; any Unicode newline character or character sequence"]
#[doc = "     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_SOFT: An alias for #G_REGEX_MATCH_PARTIAL. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to"]
#[doc = "     to #G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match"]
#[doc = "     is found, without continuing to search for a possible complete match. See"]
#[doc = "     g_match_info_is_partial_match() for more information. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like #G_REGEX_MATCH_NOTEMPTY, but only applied to"]
#[doc = "     the start of the matched string. For anchored"]
#[doc = "     patterns this can only happen for pattern containing \"\\K\". Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying match-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexMatchFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:"]
#[doc = ""]
#[doc = " A GRegex is the \"compiled\" form of a regular expression pattern."]
#[doc = " This structure is opaque and its fields cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:"]
#[doc = ""]
#[doc = " A GMatchInfo is an opaque struct used to return information about"]
#[doc = " matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:"]
#[doc = " @match_info: the #GMatchInfo generated by the match."]
#[doc = "     Use g_match_info_get_regex() and g_match_info_get_string() if you"]
#[doc = "     need the #GRegex or the matched string."]
#[doc = " @result: a #GString containing the new string"]
#[doc = " @user_data: user data passed to g_regex_replace_eval()"]
#[doc = ""]
#[doc = " Specifies the type of the function passed to g_regex_replace_eval()."]
#[doc = " It is called for each occurrence of the pattern in the string passed"]
#[doc = " to g_regex_replace_eval(), and it should append the replacement to"]
#[doc = " @result."]
#[doc = ""]
#[doc = " Returns: %FALSE to continue the replacement process, %TRUE to stop it"]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = i32;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub padding_dummy: guint,
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = i32;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = i32;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:"]
#[doc = " @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory."]
#[doc = " @G_SPAWN_ERROR_READ: Read or select on pipes failed."]
#[doc = " @G_SPAWN_ERROR_CHDIR: Changing to working directory failed."]
#[doc = " @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`"]
#[doc = " @G_SPAWN_ERROR_PERM: execv() returned `EPERM`"]
#[doc = " @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`"]
#[doc = " @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG"]
#[doc = " @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`"]
#[doc = " @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`"]
#[doc = " @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`"]
#[doc = " @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`"]
#[doc = " @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`"]
#[doc = " @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`"]
#[doc = " @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`"]
#[doc = " @G_SPAWN_ERROR_IO: execv() returned `EIO`"]
#[doc = " @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`"]
#[doc = " @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`"]
#[doc = " @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`"]
#[doc = " @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`"]
#[doc = " @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`"]
#[doc = " @G_SPAWN_ERROR_FAILED: Some other fatal failure,"]
#[doc = "   `error->message` should explain."]
#[doc = ""]
#[doc = " Error codes returned by spawning processes."]
pub type GSpawnError = i32;
#[doc = " GSpawnChildSetupFunc:"]
#[doc = " @user_data: user data to pass to the function."]
#[doc = ""]
#[doc = " Specifies the type of the setup function passed to g_spawn_async(),"]
#[doc = " g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very"]
#[doc = " limited ways, be used to affect the child's execution."]
#[doc = ""]
#[doc = " On POSIX platforms, the function is called in the child after GLib"]
#[doc = " has performed all the setup it plans to perform, but before calling"]
#[doc = " exec(). Actions taken in this function will only affect the child,"]
#[doc = " not the parent."]
#[doc = ""]
#[doc = " On Windows, the function is called in the parent. Its usefulness on"]
#[doc = " Windows is thus questionable. In many cases executing the child setup"]
#[doc = " function in the parent can have ill effects, and you should be very"]
#[doc = " careful when porting software to Windows that uses child setup"]
#[doc = " functions."]
#[doc = ""]
#[doc = " However, even on POSIX, you are extremely limited in what you can"]
#[doc = " safely do from a #GSpawnChildSetupFunc, because any mutexes that were"]
#[doc = " held by other threads in the parent process at the time of the fork()"]
#[doc = " will still be locked in the child process, and they will never be"]
#[doc = " unlocked (since the threads that held them don't exist in the child)."]
#[doc = " POSIX allows only async-signal-safe functions (see signal(7)) to be"]
#[doc = " called in the child between fork() and exec(), which drastically limits"]
#[doc = " the usefulness of child setup functions."]
#[doc = ""]
#[doc = " In particular, it is not safe to call any function which may"]
#[doc = " call malloc(), which includes POSIX functions such as setenv()."]
#[doc = " If you need to set up the child environment differently from"]
#[doc = " the parent, you should use g_get_environ(), g_environ_setenv(),"]
#[doc = " and g_environ_unsetenv(), and then pass the complete environment"]
#[doc = " list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " GSpawnFlags:"]
#[doc = " @G_SPAWN_DEFAULT: no flags, default behaviour"]
#[doc = " @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will"]
#[doc = "     be inherited by the child; otherwise all descriptors except stdin,"]
#[doc = "     stdout and stderr will be closed before calling exec() in the child."]
#[doc = " @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;"]
#[doc = "     you must use g_child_watch_add() yourself (or call waitpid() or handle"]
#[doc = "     `SIGCHLD` yourself), or the child will become a zombie."]
#[doc = " @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be"]
#[doc = "     looked for in the user's `PATH`."]
#[doc = " @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,"]
#[doc = "     instead of going to the same location as the parent's standard output."]
#[doc = " @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded."]
#[doc = " @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard"]
#[doc = "     input (by default, the child's standard input is attached to `/dev/null`)."]
#[doc = " @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to"]
#[doc = "     execute, while the remaining elements are the actual argument vector"]
#[doc = "     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`"]
#[doc = "     as the file to execute, and passes all of `argv` to the child."]
#[doc = " @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an abolute path,"]
#[doc = "     it will be looked for in the `PATH` from the passed child environment."]
#[doc = "     Since: 2.34"]
#[doc = " @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set."]
#[doc = "     Since: 2.40"]
#[doc = ""]
#[doc = " Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = i32;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
extern "C" {
    pub fn g_spawn_async_utf8(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes_utf8(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync_utf8(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync_utf8(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async_utf8(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = i32;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
pub type GTestTrapFlags = i32;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = i32;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: f64,
        cmp: *const ::std::os::raw::c_char,
        arg2: f64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:"]
#[doc = " @log_domain: the log domain of the message"]
#[doc = " @log_level: the log level of the message (including the fatal and recursion flags)"]
#[doc = " @message: the message to process"]
#[doc = " @user_data: user data, set in g_test_log_set_fatal_handler()"]
#[doc = ""]
#[doc = " Specifies the prototype of fatal log handler functions."]
#[doc = ""]
#[doc = " Returns: %TRUE if the program should abort, %FALSE otherwise"]
#[doc = ""]
#[doc = " Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = i32;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_win32_ftruncate(f: gint, size: guint) -> gint;
}
extern "C" {
    pub fn g_win32_getlocale() -> *mut gchar;
}
extern "C" {
    pub fn g_win32_error_message(error: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_directory_of_module(hmodule: gpointer) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_windows_version() -> guint;
}
extern "C" {
    pub fn g_win32_locale_filename_from_utf8(utf8filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_command_line() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_directory_utf8(
        package: *const gchar,
        dll_name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_win32_get_package_installation_subdirectory_utf8(
        package: *const gchar,
        dll_name: *const gchar,
        subdir: *const gchar,
    ) -> *mut gchar;
}
pub const GWin32OSType_G_WIN32_OS_ANY: GWin32OSType = 0;
pub const GWin32OSType_G_WIN32_OS_WORKSTATION: GWin32OSType = 1;
pub const GWin32OSType_G_WIN32_OS_SERVER: GWin32OSType = 2;
#[doc = " GWin32OSType:"]
#[doc = " @G_WIN32_OS_ANY: The running system can be a workstation or a server edition of"]
#[doc = "  Windows.  The type of the running system is therefore not checked."]
#[doc = " @G_WIN32_OS_WORKSTATION: The running system is a workstation edition of Windows,"]
#[doc = "  such as Windows 7 Professional."]
#[doc = " @G_WIN32_OS_SERVER: The running system is a server edition of Windows, such as"]
#[doc = "  Windows Server 2008 R2."]
#[doc = ""]
#[doc = " Type of Windows edition to check for at run-time."]
pub type GWin32OSType = i32;
extern "C" {
    pub fn g_win32_check_windows_version(
        major: gint,
        minor: gint,
        spver: gint,
        os_type: GWin32OSType,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: *mut ::std::os::raw::c_void,
    pub dummy: gdouble,
    _bindgen_union_align: u64,
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: size_t,
        _Value: wchar_t,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: size_t, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: size_t) -> size_t;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Value: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: size_t,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[doc = " @defgroup wmem Wireshark Memory Manager"]
#[doc = ""]
#[doc = " Wmem is a memory management framework for Wireshark that makes it simple to"]
#[doc = " write dissectors (and other 'user-space' code) that doesn't leak memory. The"]
#[doc = " core module provides basic functions like malloc, realloc and free, but"]
#[doc = " many other functions are available (see the \"Modules\" list at the top of"]
#[doc = " the generated doxygen HTML)."]
#[doc = ""]
#[doc = " Any wmem functions which allocate memory are guaranteed to either succeed or"]
#[doc = " abort the program. However, they *can* still legally return NULL when the"]
#[doc = " amount of requested memory is zero."]
#[doc = ""]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_allocator_t {
    _unused: [u8; 0],
}
#[doc = " A public opaque type representing one wmem allocation pool."]
pub type wmem_allocator_t = _wmem_allocator_t;
#[doc = "< A trivial allocator that mallocs requested"]
#[doc = "memory and tracks allocations via a hash table. As simple as"]
#[doc = "possible, intended more as a demo than for practical usage. Also"]
#[doc = "has the benefit of being friendly to tools like valgrind."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_SIMPLE: _wmem_allocator_type_t = 0;
#[doc = "< A block allocator that grabs large chunks of"]
#[doc = "memory at a time (8 MB currently) and serves allocations out of"]
#[doc = "those chunks. Designed for efficiency, especially in the"]
#[doc = "free_all operation."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_BLOCK: _wmem_allocator_type_t = 1;
#[doc = "< An allocator that does its best to find invalid"]
#[doc = "memory usage via things like canaries and scrubbing freed"]
#[doc = "memory. Valgrind is the better choice on platforms that support"]
#[doc = "it."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_STRICT: _wmem_allocator_type_t = 2;
#[doc = "< A block allocator like WMEM_ALLOCATOR_BLOCK"]
#[doc = "but even faster by tracking absolutely minimal metadata and"]
#[doc = "making 'free' a no-op. Useful only for very short-lived scopes"]
#[doc = "where there's no reason to free individual allocations because"]
#[doc = "the next free_all is always just around the corner."]
pub const _wmem_allocator_type_t_WMEM_ALLOCATOR_BLOCK_FAST: _wmem_allocator_type_t = 3;
#[doc = " An enumeration of the different types of available allocators."]
pub type _wmem_allocator_type_t = i32;
#[doc = " An enumeration of the different types of available allocators."]
pub use self::_wmem_allocator_type_t as wmem_allocator_type_t;
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object to use to allocate the memory."]
    #[doc = " @param size The amount of memory to allocate."]
    #[doc = " @return A void pointer to the newly allocated memory."]
    pub fn wmem_alloc(
        allocator: *mut wmem_allocator_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate the requested amount of memory in the given pool. Initializes the"]
    #[doc = " allocated memory with zeroes."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object to use to allocate the memory."]
    #[doc = " @param size The amount of memory to allocate."]
    #[doc = " @return A void pointer to the newly allocated and zeroed memory."]
    pub fn wmem_alloc0(
        allocator: *mut wmem_allocator_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Returns the allocated memory to the allocator. This function should only"]
    #[doc = " be called directly by allocators when the allocated block is sufficiently"]
    #[doc = " large that the reduced memory usage is worth the cost of the extra function"]
    #[doc = " call. It's usually easier to just let it get cleaned up when wmem_free_all()"]
    #[doc = " is called."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object used to originally allocate the memory."]
    #[doc = " @param ptr The pointer to the memory block to free. After this function"]
    #[doc = " returns it no longer points to valid memory."]
    pub fn wmem_free(allocator: *mut wmem_allocator_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Resizes a block of memory, potentially moving it if resizing it in place"]
    #[doc = " is not possible."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object used to originally allocate the memory."]
    #[doc = " @param ptr The pointer to the memory block to resize."]
    #[doc = " @param size The new size for the memory block."]
    #[doc = " @return The new location of the memory block. If this is different from ptr"]
    #[doc = " then ptr no longer points to valid memory."]
    pub fn wmem_realloc(
        allocator: *mut wmem_allocator_t,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Frees all the memory allocated in a pool. Depending on the allocator"]
    #[doc = " implementation used this can be significantly cheaper than calling"]
    #[doc = " wmem_free() on all the individual blocks. It also doesn't require you to have"]
    #[doc = " external pointers to those blocks."]
    #[doc = ""]
    #[doc = " @param allocator The allocator to free the memory from."]
    pub fn wmem_free_all(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Triggers a garbage-collection in the allocator. This does not free any"]
    #[doc = " memory, but it can return unused blocks to the operating system or perform"]
    #[doc = " other optimizations."]
    #[doc = ""]
    #[doc = " @param allocator The allocator in which to trigger the garbage collection."]
    pub fn wmem_gc(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Destroy the given allocator, freeing all memory allocated in it. Once this"]
    #[doc = " function has been called, no memory allocated with the allocator is valid."]
    #[doc = ""]
    #[doc = " @param allocator The allocator to destroy."]
    pub fn wmem_destroy_allocator(allocator: *mut wmem_allocator_t);
}
extern "C" {
    #[doc = " Create a new allocator of the given type. The type may be overridden by the"]
    #[doc = " WIRESHARK_DEBUG_WMEM_OVERRIDE environment variable."]
    #[doc = ""]
    #[doc = " @param type The type of allocator to create."]
    #[doc = " @return The new allocator."]
    pub fn wmem_allocator_new(type_: wmem_allocator_type_t) -> *mut wmem_allocator_t;
}
extern "C" {
    #[doc = " Initialize the wmem subsystem. This must be called before any other wmem"]
    #[doc = " function, usually at the very beginning of your program."]
    pub fn wmem_init();
}
extern "C" {
    #[doc = " Teardown the wmem subsystem. This must be called after all other wmem"]
    #[doc = " functions, usually at the very end of your program. This function will not"]
    #[doc = " destroy outstanding allocators, you must do that yourself."]
    pub fn wmem_cleanup();
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-array Array"]
#[doc = ""]
#[doc = "    A resizable array implementation on top of wmem."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_array_t {
    _unused: [u8; 0],
}
pub type wmem_array_t = _wmem_array_t;
extern "C" {
    pub fn wmem_array_sized_new(
        allocator: *mut wmem_allocator_t,
        elem_size: gsize,
        alloc_count: guint,
    ) -> *mut wmem_array_t;
}
extern "C" {
    pub fn wmem_array_new(allocator: *mut wmem_allocator_t, elem_size: gsize) -> *mut wmem_array_t;
}
extern "C" {
    pub fn wmem_array_set_null_terminator(array: *mut wmem_array_t);
}
extern "C" {
    pub fn wmem_array_bzero(array: *mut wmem_array_t);
}
extern "C" {
    pub fn wmem_array_append(
        array: *mut wmem_array_t,
        in_: *const ::std::os::raw::c_void,
        count: guint,
    );
}
extern "C" {
    pub fn wmem_array_index(
        array: *mut wmem_array_t,
        array_index: guint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_array_try_index(
        array: *mut wmem_array_t,
        array_index: guint,
        val: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmem_array_sort(
        array: *mut wmem_array_t,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn wmem_array_get_raw(array: *mut wmem_array_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_array_get_count(array: *mut wmem_array_t) -> guint;
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-list Doubly-Linked List"]
#[doc = ""]
#[doc = "    A doubly-linked list implementation on top of wmem."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_list_frame_t {
    _unused: [u8; 0],
}
pub type wmem_list_t = _wmem_list_t;
pub type wmem_list_frame_t = _wmem_list_frame_t;
extern "C" {
    pub fn wmem_list_count(list: *const wmem_list_t) -> guint;
}
extern "C" {
    pub fn wmem_list_head(list: *const wmem_list_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_tail(list: *const wmem_list_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_next(frame: *const wmem_list_frame_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_prev(frame: *const wmem_list_frame_t) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_frame_data(frame: *const wmem_list_frame_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_list_remove(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_remove_frame(list: *mut wmem_list_t, frame: *mut wmem_list_frame_t);
}
extern "C" {
    pub fn wmem_list_find(
        list: *mut wmem_list_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_find_custom(
        list: *mut wmem_list_t,
        data: *const ::std::os::raw::c_void,
        func: GCompareFunc,
    ) -> *mut wmem_list_frame_t;
}
extern "C" {
    pub fn wmem_list_prepend(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_append(list: *mut wmem_list_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wmem_list_insert_sorted(
        list: *mut wmem_list_t,
        data: *mut ::std::os::raw::c_void,
        func: GCompareFunc,
    );
}
extern "C" {
    pub fn wmem_list_new(allocator: *mut wmem_allocator_t) -> *mut wmem_list_t;
}
extern "C" {
    pub fn wmem_list_foreach(list: *mut wmem_list_t, foreach_func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn wmem_destroy_list(list: *mut wmem_list_t);
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-map Hash Map"]
#[doc = ""]
#[doc = "    A hash map implementation on top of wmem. Provides insertion, deletion and"]
#[doc = "    lookup in expected amortized constant time. Uses universal hashing to map"]
#[doc = "    keys into buckets, and provides a generic strong hash function that makes"]
#[doc = "    it secure against algorithmic complexity attacks, and suitable for use"]
#[doc = "    even with untrusted data."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_map_t {
    _unused: [u8; 0],
}
pub type wmem_map_t = _wmem_map_t;
extern "C" {
    #[doc = " Creates a map with the given allocator scope. When the scope is emptied,"]
    #[doc = " the map is fully destroyed. Items stored in it will not be freed unless they"]
    #[doc = " were allocated from the same scope. For details on the GHashFunc and"]
    #[doc = " GEqualFunc parameters, see the glib documentation at:"]
    #[doc = " https://developer.gnome.org/glib/unstable/glib-Hash-Tables.html"]
    #[doc = ""]
    #[doc = " If the keys are coming from untrusted data, do *not* use glib's default hash"]
    #[doc = " functions for strings, int64s or doubles. Wmem provides stronger equivalents"]
    #[doc = " below. Feel free to use the g_direct_hash, g_int_hash, and any of the"]
    #[doc = " g_*_equal functions though, as they should be safe."]
    #[doc = ""]
    #[doc = " @param allocator The allocator scope with which to create the map."]
    #[doc = " @param hash_func The hash function used to place inserted keys."]
    #[doc = " @param eql_func  The equality function used to compare inserted keys."]
    #[doc = " @return The newly-allocated map."]
    pub fn wmem_map_new(
        allocator: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_map_t;
}
extern "C" {
    #[doc = " Creates a map with two allocator scopes. The base structure lives in the"]
    #[doc = " master scope, however the data lives in the slave scope. Every time free_all"]
    #[doc = " occurs in the slave scope the map is transparently emptied without affecting"]
    #[doc = " the location of the master structure."]
    #[doc = ""]
    #[doc = " WARNING: None of the map (even the part in the master scope) can be used"]
    #[doc = " after the slave scope has been *destroyed*."]
    #[doc = ""]
    #[doc = " The primary use for this function is to create maps that reset for each new"]
    #[doc = " capture file that is loaded. This can be done by specifying wmem_epan_scope()"]
    #[doc = " as the master and wmem_file_scope() as the slave."]
    pub fn wmem_map_new_autoreset(
        master: *mut wmem_allocator_t,
        slave: *mut wmem_allocator_t,
        hash_func: GHashFunc,
        eql_func: GEqualFunc,
    ) -> *mut wmem_map_t;
}
extern "C" {
    #[doc = " Inserts a value into the map."]
    #[doc = ""]
    #[doc = " @param map The map to insert into."]
    #[doc = " @param key The key to insert by."]
    #[doc = " @param value The value to insert."]
    #[doc = " @return The previous value stored at this key if any, or NULL."]
    pub fn wmem_map_insert(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Check if a value is in the map."]
    #[doc = ""]
    #[doc = " @param map The map to search in."]
    #[doc = " @param key The key to lookup."]
    #[doc = " @return true if the key is in the map, otherwise false."]
    pub fn wmem_map_contains(map: *mut wmem_map_t, key: *const ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    #[doc = " Lookup a value in the map."]
    #[doc = ""]
    #[doc = " @param map The map to search in."]
    #[doc = " @param key The key to lookup."]
    #[doc = " @return The value stored at the key if any, or NULL."]
    pub fn wmem_map_lookup(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Lookup a value in the map, returning the key, value, and a boolean which"]
    #[doc = " is true if the key is found."]
    #[doc = ""]
    #[doc = " @param map The map to search in."]
    #[doc = " @param key The key to lookup."]
    #[doc = " @param orig_key (optional) The key that was determined to be a match, if any."]
    #[doc = " @param value (optional) The value stored at the key, if any."]
    #[doc = " @return true if the key is in the map, otherwise false."]
    pub fn wmem_map_lookup_extended(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
        orig_key: *mut *const ::std::os::raw::c_void,
        value: *mut *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Remove a value from the map. If no value is stored at that key, nothing"]
    #[doc = " happens."]
    #[doc = ""]
    #[doc = " @param map The map to remove from."]
    #[doc = " @param key The key of the value to remove."]
    #[doc = " @return The (removed) value stored at the key if any, or NULL."]
    pub fn wmem_map_remove(
        map: *mut wmem_map_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove a key and value from the map but does not destroy (free) them. If no"]
    #[doc = " value is stored at that key, nothing happens."]
    #[doc = ""]
    #[doc = " @param map The map to remove from."]
    #[doc = " @param key The key of the value to remove."]
    #[doc = " @return TRUE if key is found FALSE if not."]
    pub fn wmem_map_steal(map: *mut wmem_map_t, key: *const ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    #[doc = " Retrieves a list of keys inside the map"]
    #[doc = ""]
    #[doc = " @param list_allocator The allocator scope for the returned list."]
    #[doc = " @param map The map to extract keys from"]
    #[doc = " @return list of keys in the map"]
    pub fn wmem_map_get_keys(
        list_allocator: *mut wmem_allocator_t,
        map: *mut wmem_map_t,
    ) -> *mut wmem_list_t;
}
extern "C" {
    #[doc = " Run a function against all key/value pairs in the map. The order"]
    #[doc = " of the calls is unpredictable, since it is based on the internal"]
    #[doc = " storage of data."]
    #[doc = ""]
    #[doc = " @param map The map to use"]
    #[doc = " @param foreach_func the function to call for each key/value pair"]
    #[doc = " @param user_data user data to pass to the function"]
    pub fn wmem_map_foreach(map: *mut wmem_map_t, foreach_func: GHFunc, user_data: gpointer);
}
extern "C" {
    #[doc = " Return the number of elements of the map."]
    #[doc = ""]
    #[doc = " @param map The map to use"]
    #[doc = " @return the number of elements"]
    pub fn wmem_map_size(map: *mut wmem_map_t) -> guint;
}
extern "C" {
    #[doc = " Compute a strong hash value for an arbitrary sequence of bytes. Use of this"]
    #[doc = " hash value should be secure against algorithmic complexity attacks, even for"]
    #[doc = " short keys. The computation uses a random seed which is generated on wmem"]
    #[doc = " initialization, so the same key will hash to different values on different"]
    #[doc = " runs of the application."]
    #[doc = ""]
    #[doc = " @param buf The buffer of bytes (does not have to be aligned)."]
    #[doc = " @param len The length of buf to use for the hash computation."]
    #[doc = " @return The hash value."]
    pub fn wmem_strong_hash(buf: *const guint8, len: size_t) -> guint32;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over"]
    #[doc = " g_str_hash when the data comes from an untrusted source."]
    pub fn wmem_str_hash(key: gconstpointer) -> guint;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over"]
    #[doc = " g_int64_hash when the data comes from an untrusted source."]
    pub fn wmem_int64_hash(key: gconstpointer) -> guint;
}
extern "C" {
    #[doc = " An implementation of GHashFunc using wmem_strong_hash. Prefer this over"]
    #[doc = " g_double_hash when the data comes from an untrusted source."]
    pub fn wmem_double_hash(key: gconstpointer) -> guint;
}
extern "C" {
    #[doc = " Copies a block of memory."]
    #[doc = ""]
    #[doc = " @param allocator The allocator object to use to allocate memory to copy into."]
    #[doc = " @param source The pointer to the memory block to copy."]
    #[doc = " @param size The amount of memory to copy."]
    #[doc = " @return The location of the memory copy or NULL if size is 0."]
    pub fn wmem_memdup(
        allocator: *mut wmem_allocator_t,
        source: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-queue Queue"]
#[doc = ""]
#[doc = "    A queue implementation on top of wmem."]
#[doc = ""]
#[doc = "    @{"]
pub type wmem_queue_t = wmem_list_t;
extern "C" {
    pub fn wmem_epan_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    pub fn wmem_packet_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    pub fn wmem_enter_packet_scope();
}
extern "C" {
    pub fn wmem_leave_packet_scope();
}
extern "C" {
    pub fn wmem_file_scope() -> *mut wmem_allocator_t;
}
extern "C" {
    pub fn wmem_enter_file_scope();
}
extern "C" {
    pub fn wmem_leave_file_scope();
}
extern "C" {
    pub fn wmem_init_scopes();
}
extern "C" {
    pub fn wmem_cleanup_scopes();
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-stack Stack"]
#[doc = ""]
#[doc = "    A stack implementation on top of wmem."]
#[doc = ""]
#[doc = "    @{"]
pub type wmem_stack_t = wmem_list_t;
extern "C" {
    pub fn wmem_stack_peek(stack: *const wmem_stack_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmem_stack_pop(stack: *mut wmem_stack_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-strbuf String Buffer"]
#[doc = ""]
#[doc = "    A string object implementation on top of wmem."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_strbuf_t {
    _unused: [u8; 0],
}
pub type wmem_strbuf_t = _wmem_strbuf_t;
extern "C" {
    pub fn wmem_strbuf_sized_new(
        allocator: *mut wmem_allocator_t,
        alloc_len: gsize,
        max_len: gsize,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_new(
        allocator: *mut wmem_allocator_t,
        str: *const gchar,
    ) -> *mut wmem_strbuf_t;
}
extern "C" {
    pub fn wmem_strbuf_append(strbuf: *mut wmem_strbuf_t, str: *const gchar);
}
extern "C" {
    pub fn wmem_strbuf_append_printf(strbuf: *mut wmem_strbuf_t, format: *const gchar, ...);
}
extern "C" {
    pub fn wmem_strbuf_append_vprintf(strbuf: *mut wmem_strbuf_t, fmt: *const gchar, ap: va_list);
}
extern "C" {
    pub fn wmem_strbuf_append_c(strbuf: *mut wmem_strbuf_t, c: gchar);
}
extern "C" {
    pub fn wmem_strbuf_append_unichar(strbuf: *mut wmem_strbuf_t, c: gunichar);
}
extern "C" {
    pub fn wmem_strbuf_truncate(strbuf: *mut wmem_strbuf_t, len: gsize);
}
extern "C" {
    pub fn wmem_strbuf_get_str(strbuf: *mut wmem_strbuf_t) -> *const gchar;
}
extern "C" {
    pub fn wmem_strbuf_get_len(strbuf: *mut wmem_strbuf_t) -> gsize;
}
extern "C" {
    #[doc = " Truncates the allocated memory down to the minimal amount, frees the header"]
    #[doc = "  structure, and returns a non-const pointer to the raw string. The"]
    #[doc = "  wmem_strbuf_t structure cannot be used after this is called. Basically a"]
    #[doc = "  destructor for when you still need the underlying C-string."]
    pub fn wmem_strbuf_finalize(strbuf: *mut wmem_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @addtogroup wmem"]
    #[doc = "  @{"]
    #[doc = "    @defgroup wmem-strutl String Utilities"]
    #[doc = ""]
    #[doc = "    A collection of utility function for operating on C strings with wmem."]
    #[doc = ""]
    #[doc = "    @{"]
    pub fn wmem_strdup(allocator: *mut wmem_allocator_t, src: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn wmem_strndup(
        allocator: *mut wmem_allocator_t,
        src: *const gchar,
        len: size_t,
    ) -> *mut gchar;
}
extern "C" {
    pub fn wmem_strdup_printf(
        allocator: *mut wmem_allocator_t,
        fmt: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn wmem_strdup_vprintf(
        allocator: *mut wmem_allocator_t,
        fmt: *const gchar,
        ap: va_list,
    ) -> *mut gchar;
}
extern "C" {
    pub fn wmem_strconcat(allocator: *mut wmem_allocator_t, first: *const gchar, ...)
        -> *mut gchar;
}
extern "C" {
    pub fn wmem_strjoin(
        allocator: *mut wmem_allocator_t,
        separator: *const gchar,
        first: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn wmem_strjoinv(
        allocator: *mut wmem_allocator_t,
        separator: *const gchar,
        str_array: *mut *mut gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Splits a string into a maximum of max_tokens pieces, using the given"]
    #[doc = " delimiter. If max_tokens is reached, the remainder of string is appended"]
    #[doc = " to the last token. Successive tokens are not folded and will instead result"]
    #[doc = " in an empty string as element."]
    #[doc = ""]
    #[doc = " If src or delimiter are NULL, or if delimiter is empty, this will return"]
    #[doc = " NULL."]
    #[doc = ""]
    #[doc = " Do not use with a NULL allocator, use g_strsplit instead."]
    pub fn wmem_strsplit(
        allocator: *mut wmem_allocator_t,
        src: *const gchar,
        delimiter: *const gchar,
        max_tokens: ::std::os::raw::c_int,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[doc = " wmem_ascii_strdown:"]
    #[doc = " Based on g_ascii_strdown"]
    #[doc = " @param allocator  An enumeration of the different types of available allocators."]
    #[doc = " @param str a string."]
    #[doc = " @param len length of str in bytes, or -1 if str is nul-terminated."]
    #[doc = ""]
    #[doc = " Converts all upper case ASCII letters to lower case ASCII letters."]
    #[doc = ""]
    #[doc = " Return value: a newly-allocated string, with all the upper case"]
    #[doc = "               characters in str converted to lower case, with"]
    #[doc = "               semantics that exactly match g_ascii_tolower(). (Note"]
    #[doc = "               that this is unlike the old g_strdown(), which modified"]
    #[doc = "               the string in place.)"]
    pub fn wmem_ascii_strdown(
        allocator: *mut wmem_allocator_t,
        str: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
#[doc = " @addtogroup wmem"]
#[doc = "  @{"]
#[doc = "    @defgroup wmem-tree Red/Black Tree"]
#[doc = ""]
#[doc = "    Binary trees are a well-known and popular device in computer science to"]
#[doc = "    handle storage of objects based on a search key or identity. The"]
#[doc = "    particular binary tree style implemented here is the red/black tree, which"]
#[doc = "    has the nice property of being self-balancing. This guarantees O(log(n))"]
#[doc = "    time for lookups, compared to linked lists that are O(n). This means"]
#[doc = "    red/black trees scale very well when many objects are being stored."]
#[doc = ""]
#[doc = "    @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_t {
    _unused: [u8; 0],
}
pub type wmem_tree_t = _wmem_tree_t;
extern "C" {
    #[doc = " Creates a tree with the given allocator scope. When the scope is emptied,"]
    #[doc = " the tree is fully destroyed."]
    pub fn wmem_tree_new(allocator: *mut wmem_allocator_t) -> *mut wmem_tree_t;
}
extern "C" {
    #[doc = " Creates a tree with two allocator scopes. The base structure lives in the"]
    #[doc = " master scope, however the data lives in the slave scope. Every time free_all"]
    #[doc = " occurs in the slave scope the tree is transparently emptied without affecting"]
    #[doc = " the location of the master structure."]
    #[doc = ""]
    #[doc = " WARNING: None of the tree (even the part in the master scope) can be used"]
    #[doc = " after the slave scope has been *destroyed*."]
    #[doc = ""]
    #[doc = " The primary use for this function is to create trees that reset for each new"]
    #[doc = " capture file that is loaded. This can be done by specifying wmem_epan_scope()"]
    #[doc = " as the master and wmem_file_scope() as the slave."]
    pub fn wmem_tree_new_autoreset(
        master: *mut wmem_allocator_t,
        slave: *mut wmem_allocator_t,
    ) -> *mut wmem_tree_t;
}
extern "C" {
    #[doc = " Cleanup memory used by tree.  Intended for NULL scope allocated trees"]
    pub fn wmem_tree_destroy(tree: *mut wmem_tree_t, free_keys: gboolean, free_values: gboolean);
}
extern "C" {
    #[doc = " Returns true if the tree is empty (has no nodes)."]
    pub fn wmem_tree_is_empty(tree: *mut wmem_tree_t) -> gboolean;
}
extern "C" {
    #[doc = " Returns number of nodes in tree"]
    pub fn wmem_tree_count(tree: *mut wmem_tree_t) -> guint;
}
extern "C" {
    #[doc = " Insert a node indexed by a guint32 key value."]
    #[doc = ""]
    #[doc = " Data is a pointer to the structure you want to be able to retrieve by"]
    #[doc = " searching for the same key later."]
    #[doc = ""]
    #[doc = " NOTE: If you insert a node to a key that already exists in the tree this"]
    #[doc = " function will simply overwrite the old value. If the structures you are"]
    #[doc = " storing are allocated in a wmem pool this is not a problem as they will still"]
    #[doc = " be freed with the pool. If you are managing them manually however, you must"]
    #[doc = " either ensure the key is unique, or do a lookup before each insert."]
    pub fn wmem_tree_insert32(
        tree: *mut wmem_tree_t,
        key: guint32,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a guint32 integer value. If no node is"]
    #[doc = " found the function will return NULL."]
    pub fn wmem_tree_lookup32(tree: *mut wmem_tree_t, key: guint32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a guint32 integer value."]
    #[doc = " Returns the node that has the largest key that is less than or equal"]
    #[doc = " to the search key, or NULL if no such key exists."]
    pub fn wmem_tree_lookup32_le(
        tree: *mut wmem_tree_t,
        key: guint32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove a node in the tree indexed by a guint32 integer value. This is not"]
    #[doc = " really a remove, but the value is set to NULL so that wmem_tree_lookup32"]
    #[doc = " not will find it."]
    pub fn wmem_tree_remove32(tree: *mut wmem_tree_t, key: guint32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Insert a new value under a string key. Like wmem_tree_insert32 but where the"]
    #[doc = " key is a null-terminated string instead of a guint32. You may pass"]
    #[doc = " WMEM_TREE_STRING_NOCASE to the flags argument in order to make it store the"]
    #[doc = " key in a case-insensitive way.  (Note that \"case-insensitive\" refers"]
    #[doc = " only to the ASCII letters A-Z and a-z; it is locale-independent."]
    #[doc = " Do not expect it to honor the rules of your language; for example, \"I\""]
    #[doc = " will always be mapped to \"i\"."]
    pub fn wmem_tree_insert_string(
        tree: *mut wmem_tree_t,
        key: *const gchar,
        data: *mut ::std::os::raw::c_void,
        flags: guint32,
    );
}
extern "C" {
    #[doc = " Lookup the value under a string key, like wmem_tree_lookup32 but where the"]
    #[doc = " keye is a null-terminated string instead of a guint32. See"]
    #[doc = " wmem_tree_insert_string for an explanation of flags."]
    pub fn wmem_tree_lookup_string(
        tree: *mut wmem_tree_t,
        key: *const gchar,
        flags: guint32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove the value under a string key.  This is not really a remove, but the"]
    #[doc = " value is set to NULL so that wmem_tree_lookup_string not will find it."]
    #[doc = " See wmem_tree_insert_string for an explanation of flags."]
    pub fn wmem_tree_remove_string(
        tree: *mut wmem_tree_t,
        key: *const gchar,
        flags: guint32,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_tree_key_t {
    #[doc = "< length in guint32 words"]
    pub length: guint32,
    pub key: *mut guint32,
}
pub type wmem_tree_key_t = _wmem_tree_key_t;
extern "C" {
    #[doc = " Insert a node indexed by a sequence of guint32 key values."]
    #[doc = ""]
    #[doc = " Takes as key an array of guint32 vectors of type wmem_tree_key_t. It will"]
    #[doc = " iterate through each key to search further down the tree until it reaches an"]
    #[doc = " element where length==0, indicating the end of the array. You MUST terminate"]
    #[doc = " the key array by {0, NULL} or this will crash."]
    #[doc = ""]
    #[doc = " NOTE: length indicates the number of guint32 values in the vector, not the"]
    #[doc = " number of bytes."]
    #[doc = ""]
    #[doc = " NOTE: all the \"key\" members of the \"key\" argument MUST be aligned on"]
    #[doc = " 32-bit boundaries; otherwise, this code will crash on platforms such"]
    #[doc = " as SPARC that require aligned pointers."]
    #[doc = ""]
    #[doc = " If you use ...32_array() calls you MUST make sure that every single node"]
    #[doc = " you add to a specific tree always has a key of exactly the same number of"]
    #[doc = " keylen words or it will crash. Or at least that every single item that sits"]
    #[doc = " behind the same top level node always has exactly the same number of words."]
    #[doc = ""]
    #[doc = " One way to guarantee this is the way that NFS does this for the"]
    #[doc = " nfs_name_snoop_known tree which holds filehandles for both v2 and v3."]
    #[doc = " v2 filehandles are always 32 bytes (8 words) while v3 filehandles can have"]
    #[doc = " any length (though 32 bytes are most common)."]
    #[doc = " The NFS dissector handles this by providing a guint32 containing the length"]
    #[doc = " as the very first item in this vector :"]
    #[doc = ""]
    #[doc = "                      wmem_tree_key_t fhkey[3];"]
    #[doc = ""]
    #[doc = "                      fhlen=nns->fh_length;"]
    #[doc = "                      fhkey[0].length=1;"]
    #[doc = "                      fhkey[0].key=&fhlen;"]
    #[doc = "                      fhkey[1].length=fhlen/4;"]
    #[doc = "                      fhkey[1].key=nns->fh;"]
    #[doc = "                      fhkey[2].length=0;"]
    pub fn wmem_tree_insert32_array(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a sequence of guint32 integer values."]
    #[doc = " See wmem_tree_insert32_array for details on the key."]
    pub fn wmem_tree_lookup32_array(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Look up a node in the tree indexed by a multi-part tree value."]
    #[doc = " The function will return the node that has the largest key that is"]
    #[doc = " equal to or smaller than the search key, or NULL if no such key was"]
    #[doc = " found."]
    #[doc = ""]
    #[doc = " NOTE:  The key returned will be \"less\" in key order.  The usefulness"]
    #[doc = " of the returned node must be verified prior to use."]
    #[doc = ""]
    #[doc = " See wmem_tree_insert32_array for details on the key."]
    pub fn wmem_tree_lookup32_array_le(
        tree: *mut wmem_tree_t,
        key: *mut wmem_tree_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Function type for processing one node of a tree during a traversal. Value is"]
#[doc = " the value of the node, userdata is whatever was passed to the traversal"]
#[doc = " function. If the function returns TRUE the traversal will end prematurely."]
pub type wmem_foreach_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
#[doc = " Function type to print key/data of nodes in wmem_print_tree_verbose"]
pub type wmem_printer_func =
    ::std::option::Option<unsafe extern "C" fn(data: *const ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Inorder traversal (left/parent/right) of the tree and call"]
    #[doc = " callback(value, userdata) for each value found."]
    #[doc = ""]
    #[doc = " Returns TRUE if the traversal was ended prematurely by the callback."]
    pub fn wmem_tree_foreach(
        tree: *mut wmem_tree_t,
        callback: wmem_foreach_func,
        user_data: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    pub fn wmem_print_tree(
        tree: *mut wmem_tree_t,
        key_printer: wmem_printer_func,
        data_printer: wmem_printer_func,
    );
}
pub type wmem_itree_t = _wmem_tree_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wmem_range_t {
    pub low: guint64,
    pub high: guint64,
    pub max_edge: guint64,
}
extern "C" {
    pub fn wmem_itree_new(allocator: *mut wmem_allocator_t) -> *mut wmem_itree_t;
}
extern "C" {
    #[doc = " Returns true if the tree is empty (has no nodes)."]
    pub fn wmem_itree_is_empty(tree: *mut wmem_itree_t) -> gboolean;
}
extern "C" {
    #[doc = " Inserts a range low-high indexed by \"low\" in O(log(n))."]
    #[doc = " As in wmem_tree, if a key \"low\" already exists, it will be overwritten with the new data"]
    #[doc = ""]
    pub fn wmem_itree_insert(
        tree: *mut wmem_itree_t,
        low: guint64,
        high: guint64,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wmem_itree_find_intervals(
        tree: *mut wmem_itree_t,
        allocator: *mut wmem_allocator_t,
        low: guint64,
        high: guint64,
    ) -> *mut wmem_list_t;
}
extern "C" {
    #[doc = " Print ranges along the tree"]
    pub fn wmem_print_itree(tree: *mut wmem_itree_t);
}
#[doc = "< wmem_free_all()"]
pub const _wmem_cb_event_t_WMEM_CB_FREE_EVENT: _wmem_cb_event_t = 0;
#[doc = "< wmem_destroy_allocator()"]
pub const _wmem_cb_event_t_WMEM_CB_DESTROY_EVENT: _wmem_cb_event_t = 1;
#[doc = " The events that can trigger a callback."]
pub type _wmem_cb_event_t = i32;
#[doc = " The events that can trigger a callback."]
pub use self::_wmem_cb_event_t as wmem_cb_event_t;
#[doc = " Function signature for registered user callbacks."]
#[doc = ""]
#[doc = " allocator The allocator that triggered this callback."]
#[doc = " event     The event type that triggered this callback."]
#[doc = " user_data Whatever user_data was originally passed to the call to"]
#[doc = "                  wmem_register_callback()."]
#[doc = " @return          FALSE to unregister the callback, TRUE otherwise."]
pub type wmem_user_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wmem_allocator_t,
        arg2: wmem_cb_event_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
extern "C" {
    #[doc = " Register a callback function with the given allocator pool."]
    #[doc = ""]
    #[doc = " @param allocator The allocator with which to register the callback."]
    #[doc = " @param callback  The function to be called as the callback."]
    #[doc = " @param user_data An arbitrary data pointer that is passed to the callback as"]
    #[doc = "                  a way to specify extra parameters or store extra data. Note"]
    #[doc = "                  that this pointer is not freed when a callback is finished,"]
    #[doc = "                  you have to do that yourself in the callback, or just"]
    #[doc = "                  allocate it in the appropriate wmem pool."]
    #[doc = " @return          ID of this callback that can be passed back to"]
    #[doc = "                  wmem_unregister_callback()."]
    pub fn wmem_register_callback(
        allocator: *mut wmem_allocator_t,
        callback: wmem_user_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> guint;
}
extern "C" {
    #[doc = " Unregister the callback function with the given ID."]
    #[doc = ""]
    #[doc = " @param allocator The allocator from which to unregister the callback."]
    #[doc = " @param id        The callback id as returned from wmem_register_callback()."]
    pub fn wmem_unregister_callback(allocator: *mut wmem_allocator_t, id: guint);
}
pub type ws_in4_addr = guint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv4_addr_and_mask {
    pub addr: guint32,
    pub nmask: guint32,
}
#[doc = " data structure to hold time values with nanosecond resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
extern "C" {
    #[doc = " set the given nstime_t to zero"]
    pub fn nstime_set_zero(nstime: *mut nstime_t);
}
extern "C" {
    #[doc = " is the given nstime_t currently zero?"]
    pub fn nstime_is_zero(nstime: *mut nstime_t) -> gboolean;
}
extern "C" {
    #[doc = " set the given nstime_t to (0,maxint) to mark it as \"unset\""]
    #[doc = " That way we can find the first frame even when a timestamp"]
    #[doc = " is zero (fix for bug 1056)"]
    pub fn nstime_set_unset(nstime: *mut nstime_t);
}
extern "C" {
    pub fn nstime_is_unset(nstime: *const nstime_t) -> gboolean;
}
extern "C" {
    #[doc = " duplicate the current time"]
    #[doc = ""]
    #[doc = " a = b"]
    pub fn nstime_copy(a: *mut nstime_t, b: *const nstime_t);
}
extern "C" {
    #[doc = " calculate the delta between two times (can be negative!)"]
    #[doc = ""]
    #[doc = " delta = b-a"]
    #[doc = ""]
    #[doc = " Note that it is acceptable for two or more of the arguments to point at the"]
    #[doc = " same structure."]
    pub fn nstime_delta(delta: *mut nstime_t, b: *const nstime_t, a: *const nstime_t);
}
extern "C" {
    #[doc = " calculate the sum of two times"]
    #[doc = ""]
    #[doc = " sum = a+b"]
    #[doc = ""]
    #[doc = " Note that it is acceptable for two or more of the arguments to point at the"]
    #[doc = " same structure."]
    pub fn nstime_sum(sum: *mut nstime_t, b: *const nstime_t, a: *const nstime_t);
}
extern "C" {
    #[doc = " compare two times are return a value similar to memcmp() or strcmp()."]
    #[doc = ""]
    #[doc = " a > b : > 0"]
    #[doc = " a = b : 0"]
    #[doc = " a < b : < 0"]
    pub fn nstime_cmp(a: *const nstime_t, b: *const nstime_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts nstime to double, time base is milli seconds"]
    pub fn nstime_to_msec(nstime: *const nstime_t) -> f64;
}
extern "C" {
    #[doc = " converts nstime to double, time base is seconds"]
    pub fn nstime_to_sec(nstime: *const nstime_t) -> f64;
}
extern "C" {
    #[doc = " converts Windows FILETIME to nstime, returns TRUE on success,"]
    #[doc = "FALSE on failure"]
    pub fn filetime_to_nstime(nstime: *mut nstime_t, filetime: guint64) -> gboolean;
}
extern "C" {
    #[doc = " converts time like Windows FILETIME, but expressed in nanoseconds"]
    #[doc = "rather than tenths of microseconds, to nstime, returns TRUE on success,"]
    #[doc = "FALSE on failure"]
    pub fn nsfiletime_to_nstime(nstime: *mut nstime_t, nsfiletime: guint64) -> gboolean;
}
pub const to_str_time_res_t_TO_STR_TIME_RES_T_SECS: to_str_time_res_t = 0;
pub const to_str_time_res_t_TO_STR_TIME_RES_T_DSECS: to_str_time_res_t = 1;
pub const to_str_time_res_t_TO_STR_TIME_RES_T_CSECS: to_str_time_res_t = 2;
pub const to_str_time_res_t_TO_STR_TIME_RES_T_MSECS: to_str_time_res_t = 3;
pub const to_str_time_res_t_TO_STR_TIME_RES_T_USECS: to_str_time_res_t = 4;
pub const to_str_time_res_t_TO_STR_TIME_RES_T_NSECS: to_str_time_res_t = 5;
pub type to_str_time_res_t = i32;
pub const absolute_time_display_e_ABSOLUTE_TIME_LOCAL: absolute_time_display_e = 1000;
pub const absolute_time_display_e_ABSOLUTE_TIME_UTC: absolute_time_display_e = 1001;
pub const absolute_time_display_e_ABSOLUTE_TIME_DOY_UTC: absolute_time_display_e = 1002;
pub const absolute_time_display_e_ABSOLUTE_TIME_NTP_UTC: absolute_time_display_e = 1003;
pub type absolute_time_display_e = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_guid_t {
    pub data1: guint32,
    pub data2: guint16,
    pub data3: guint16,
    pub data4: [guint8; 8usize],
}
pub type e_guid_t = _e_guid_t;
extern "C" {
    pub fn guids_init();
}
extern "C" {
    pub fn guids_add_guid(guid: *const e_guid_t, name: *const gchar);
}
extern "C" {
    pub fn guids_get_guid_name(guid: *const e_guid_t) -> *const gchar;
}
extern "C" {
    pub fn guids_resolve_guid_to_str(guid: *const e_guid_t) -> *const gchar;
}
extern "C" {
    pub fn guid_cmp(g1: *const e_guid_t, g2: *const e_guid_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct e_in6_addr {
    pub bytes: [guint8; 16usize],
}
pub type ws_in6_addr = e_in6_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws_ip6_hdr {
    pub ip6h_vc_flow: guint32,
    pub ip6h_plen: guint16,
    pub ip6h_nxt: guint8,
    pub ip6h_hlim: guint8,
    pub ip6h_src: ws_in6_addr,
    pub ip6h_dst: ws_in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_ext {
    pub ip6e_nxt: guchar,
    pub ip6e_len: guchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr {
    pub ip6r_nxt: guint8,
    pub ip6r_len: guint8,
    pub ip6r_type: guint8,
    pub ip6r_segleft: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: guint8,
    pub ip6r0_len: guint8,
    pub ip6r0_type: guint8,
    pub ip6r0_segleft: guint8,
    pub ip6r0_reserved: guint8,
    pub ip6r0_slmap: [guint8; 3usize],
    pub ip6r0_addr: [ws_in6_addr; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_frag {
    pub ip6f_nxt: guint8,
    pub ip6f_reserved: guint8,
    pub ip6f_offlg: guint16,
    pub ip6f_ident: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_addr_and_prefix {
    pub addr: ws_in6_addr,
    pub prefix: guint32,
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: size_t,
        _Dir: *mut wchar_t,
        _DirCount: size_t,
        _Filename: *mut wchar_t,
        _FilenameCount: size_t,
        _Ext: *mut wchar_t,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: size_t,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: size_t,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: size_t,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut size_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
#[doc = " The pattern object used for ws_mempbrk_exec()."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct ws_mempbrk_pattern {
    pub patt: [gchar; 256usize],
    pub use_sse42: gboolean,
    pub __bindgen_padding_0: u64,
    pub mask: __m128i,
}
extern "C" {
    #[doc = " Compile the pattern for the needles to find using ws_mempbrk_exec()."]
    pub fn ws_mempbrk_compile(pattern: *mut ws_mempbrk_pattern, needles: *const gchar);
}
extern "C" {
    #[doc = " Scan for the needles specified by the compiled pattern."]
    pub fn ws_mempbrk_exec(
        haystack: *const guint8,
        haystacklen: size_t,
        pattern: *const ws_mempbrk_pattern,
        found_needle: *mut guchar,
    ) -> *const guint8;
}
#[doc = " \"testy, virtual(-izable) buffer\".  They are testy in that they get mad when"]
#[doc = " an attempt is made to access data beyond the bounds of their array. In that"]
#[doc = " case, they throw an exception."]
#[doc = ""]
#[doc = " They are virtualizable in that new tvbuff's can be made from other tvbuffs,"]
#[doc = " while only the original tvbuff may have data. That is, the new tvbuff has"]
#[doc = " virtual data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tvbuff {
    _unused: [u8; 0],
}
pub type tvbuff_t = tvbuff;
#[doc = " A \"real\" tvbuff contains a guint8* that points to real data."]
#[doc = " The data is allocated and contiguous."]
#[doc = ""]
#[doc = " A \"subset\" tvbuff has a backing tvbuff. It is a \"window\" through"]
#[doc = " which the program sees only a portion of the backing tvbuff."]
#[doc = ""]
#[doc = " A \"composite\" tvbuff combines multiple tvbuffs sequentially to"]
#[doc = " produce a larger byte array."]
#[doc = ""]
#[doc = " tvbuff's of any type can be used as the backing-tvbuff of a"]
#[doc = " \"subset\" tvbuff or as a member of a \"composite\" tvbuff."]
#[doc = " \"composite\" tvbuffs can have member-tvbuffs of different types."]
#[doc = ""]
#[doc = " Once a tvbuff is create/initialized/finalized, the tvbuff is read-only."]
#[doc = " That is, it cannot point to any other data. A new tvbuff must be created if"]
#[doc = " you want a tvbuff that points to other data."]
#[doc = ""]
#[doc = " tvbuff's are normally chained together to allow efficient de-allocation of"]
#[doc = " tvbuff's."]
pub type tvbuff_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Extracts 'number of bits' starting at 'bit offset'."]
    #[doc = " Returns a pointer to a newly initialized g_malloc'd REAL_DATA"]
    #[doc = " tvbuff with the bits octet aligned."]
    pub fn tvb_new_octet_aligned(
        tvb: *mut tvbuff_t,
        bit_offset: guint32,
        no_of_bits: gint32,
    ) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_new_chain(parent: *mut tvbuff_t, backing: *mut tvbuff_t) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_clone(tvb: *mut tvbuff_t) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_clone_offset_len(tvb: *mut tvbuff_t, offset: guint, len: guint) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Free a tvbuff_t and all tvbuffs chained from it"]
    #[doc = " The tvbuff must be 'the 'head' (initial) tvb of a chain or"]
    #[doc = " must not be in a chain."]
    #[doc = " If specified, a callback to free the tvbuff data will be invoked"]
    #[doc = " for each tvbuff free'd"]
    pub fn tvb_free(tvb: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Free the tvbuff_t and all tvbuffs chained from it."]
    #[doc = " The tvbuff must be 'the 'head' (initial) tvb of a chain or"]
    #[doc = " must not be in a chain."]
    #[doc = " If specified, a callback to free the tvbuff data will be invoked"]
    #[doc = " for each tvbuff free'd"]
    pub fn tvb_free_chain(tvb: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Set a callback function to call when a tvbuff is actually freed"]
    #[doc = " One argument is passed to that callback --- a void* that points"]
    #[doc = " to the real data. Obviously, this only applies to a"]
    #[doc = " \"real\" tvbuff."]
    pub fn tvb_set_free_cb(tvb: *mut tvbuff_t, func: tvbuff_free_cb_t);
}
extern "C" {
    #[doc = " Attach a \"real\" tvbuff to a parent tvbuff. This connection is used"]
    #[doc = " during a tvb_free_chain()... the \"child\" \"real\" tvbuff acts as if it"]
    #[doc = " is part of the chain-of-creation of the parent tvbuff, although it"]
    #[doc = " isn't. This is useful if you need to take the data from some tvbuff,"]
    #[doc = " run some operation on it, like decryption or decompression, and make"]
    #[doc = " a new tvbuff from it, yet want the new tvbuff to be part of the chain."]
    #[doc = " The reality is that the new tvbuff *is* part of the \"chain of creation\","]
    #[doc = " but in a way that these tvbuff routines are ignorant of. Use this"]
    #[doc = " function to make the tvbuff routines knowledgable of this fact."]
    pub fn tvb_set_child_real_data_tvbuff(parent: *mut tvbuff_t, child: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Create a tvbuff backed by existing data. Can throw ReportedBoundsError."]
    #[doc = " Normally, a callback to free the data should be registered using"]
    #[doc = " tvb_set_free_cb(); when this tvbuff is freed, then your callback will be"]
    #[doc = " called, and at that time you can free your original data."]
    pub fn tvb_new_real_data(
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Create a tvbuff that's a subset of another tvbuff."]
    #[doc = ""]
    #[doc = " 'backing_offset', if positive, is the offset from the beginning of"]
    #[doc = " the backing tvbuff at which the new tvbuff's data begins, and, if"]
    #[doc = " negative, is the offset from the end of the backing tvbuff at which"]
    #[doc = " the new tvbuff's data begins."]
    #[doc = ""]
    #[doc = " 'backing_length' is the length of the data to include in the new"]
    #[doc = " tvbuff, starting with the byte at 'backing_offset\"; if -1, it"]
    #[doc = " means \"to the end of the backing tvbuff\".  It can be 0, although"]
    #[doc = " the usefulness of the buffer would be rather limited."]
    #[doc = ""]
    #[doc = " Will throw BoundsError if 'backing_offset'/'length'"]
    #[doc = " is beyond the bounds of the backing tvbuff."]
    #[doc = " Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_length_caplen(
        backing: *mut tvbuff_t,
        backing_offset: gint,
        backing_length: gint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with captured length calculated"]
    #[doc = " to fit within the existing captured length and the specified"]
    #[doc = " reported length."]
    #[doc = " Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_length(
        backing: *mut tvbuff_t,
        backing_offset: gint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set"]
    #[doc = " to -1.  Can throw ReportedBoundsError."]
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Append to the list of tvbuffs that make up this composite tvbuff"]
    pub fn tvb_composite_append(tvb: *mut tvbuff_t, member: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Prepend to the list of tvbuffs that make up this composite tvbuff"]
    pub fn tvb_composite_prepend(tvb: *mut tvbuff_t, member: *mut tvbuff_t);
}
extern "C" {
    #[doc = " Create an empty composite tvbuff."]
    pub fn tvb_new_composite() -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Mark a composite tvbuff as initialized. No further appends or prepends"]
    #[doc = " occur, data access can finally happen after this finalization."]
    pub fn tvb_composite_finalize(tvb: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_captured_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Computes bytes to end of buffer, from offset (which can be negative,"]
    #[doc = " to indicate bytes from end of buffer). Function returns 0 if offset is"]
    #[doc = " either at the end of the buffer or out of bounds. No exception is thrown."]
    #[doc = " You probably want tvb_reported_length_remaining instead."]
    pub fn tvb_captured_length_remaining(tvb: *const tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    #[doc = " Same as above, but throws an exception if the offset is out of bounds."]
    pub fn tvb_ensure_captured_length_remaining(tvb: *const tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    pub fn tvb_bytes_exist(tvb: *const tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Checks that the bytes referred to by 'offset'/'length', where 'length'"]
    #[doc = " is a 64-bit unsigned integer, actually exist in the buffer, and throws"]
    #[doc = " an exception if they aren't."]
    pub fn tvb_ensure_bytes_exist64(tvb: *const tvbuff_t, offset: gint, length: guint64);
}
extern "C" {
    #[doc = " Checks that the bytes referred to by 'offset'/'length' actually exist"]
    #[doc = " in the buffer, and throws an exception if they aren't."]
    pub fn tvb_ensure_bytes_exist(tvb: *const tvbuff_t, offset: gint, length: gint);
}
extern "C" {
    pub fn tvb_offset_exists(tvb: *const tvbuff_t, offset: gint) -> gboolean;
}
extern "C" {
    pub fn tvb_reported_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    #[doc = " Computes bytes of reported packet data to end of buffer, from offset"]
    #[doc = " (which can be negative, to indicate bytes from end of buffer). Function"]
    #[doc = " returns 0 if offset is either at the end of the buffer or out of bounds."]
    #[doc = " No exception is thrown."]
    pub fn tvb_reported_length_remaining(tvb: *const tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    #[doc = " Set the reported length of a tvbuff to a given value; used for protocols"]
    #[doc = "whose headers contain an explicit length and where the calling"]
    #[doc = "dissector's payload may include padding as well as the packet for"]
    #[doc = "this protocol."]
    #[doc = ""]
    #[doc = "Also adjusts the data length."]
    pub fn tvb_set_reported_length(tvb: *mut tvbuff_t, arg1: guint);
}
extern "C" {
    pub fn tvb_offset_from_real_beginning(tvb: *const tvbuff_t) -> guint;
}
extern "C" {
    pub fn tvb_raw_offset(tvb: *mut tvbuff_t) -> gint;
}
extern "C" {
    #[doc = " Set the \"this is a fragment\" flag."]
    pub fn tvb_set_fragment(tvb: *mut tvbuff_t);
}
extern "C" {
    pub fn tvb_get_ds_tvb(tvb: *mut tvbuff_t) -> *mut tvbuff;
}
extern "C" {
    #[doc = " START OF ACCESSORS"]
    pub fn tvb_get_guint8(tvb: *mut tvbuff_t, offset: gint) -> guint8;
}
extern "C" {
    pub fn tvb_get_gint8(tvb: *mut tvbuff_t, offset: gint) -> gint8;
}
extern "C" {
    pub fn tvb_get_ntohs(tvb: *mut tvbuff_t, offset: gint) -> guint16;
}
extern "C" {
    pub fn tvb_get_ntohis(tvb: *mut tvbuff_t, offset: gint) -> gint16;
}
extern "C" {
    pub fn tvb_get_ntoh24(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ntohi24(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_ntohl(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ntohil(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_ntoh40(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi40(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh48(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi48(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh56(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi56(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntoh64(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_ntohi64(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ntohieee_float(tvb: *mut tvbuff_t, offset: gint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_ntohieee_double(tvb: *mut tvbuff_t, offset: gint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_letohs(tvb: *mut tvbuff_t, offset: gint) -> guint16;
}
extern "C" {
    pub fn tvb_get_letohis(tvb: *mut tvbuff_t, offset: gint) -> gint16;
}
extern "C" {
    pub fn tvb_get_letoh24(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_letohi24(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_letohl(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_letohil(tvb: *mut tvbuff_t, offset: gint) -> gint32;
}
extern "C" {
    pub fn tvb_get_letoh40(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi40(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh48(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi48(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh56(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi56(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letoh64(tvb: *mut tvbuff_t, offset: gint) -> guint64;
}
extern "C" {
    pub fn tvb_get_letohi64(tvb: *mut tvbuff_t, offset: gint) -> gint64;
}
extern "C" {
    pub fn tvb_get_letohieee_float(tvb: *mut tvbuff_t, offset: gint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_letohieee_double(tvb: *mut tvbuff_t, offset: gint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_guint16(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint16;
}
extern "C" {
    pub fn tvb_get_gint16(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint16;
}
extern "C" {
    pub fn tvb_get_guint24(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint32;
}
extern "C" {
    pub fn tvb_get_gint24(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint32;
}
extern "C" {
    pub fn tvb_get_guint32(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint32;
}
extern "C" {
    pub fn tvb_get_gint32(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint32;
}
extern "C" {
    pub fn tvb_get_guint40(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint40(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint48(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint48(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint56(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint56(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_guint64(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> guint64;
}
extern "C" {
    pub fn tvb_get_gint64(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gint64;
}
extern "C" {
    pub fn tvb_get_ieee_float(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gfloat;
}
extern "C" {
    pub fn tvb_get_ieee_double(tvb: *mut tvbuff_t, offset: gint, encoding: guint) -> gdouble;
}
extern "C" {
    pub fn tvb_get_string_time(
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
        ns: *mut nstime_t,
        endoff: *mut gint,
    ) -> *mut nstime_t;
}
extern "C" {
    pub fn tvb_get_string_bytes(
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
        bytes: *mut GByteArray,
        endoff: *mut gint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[doc = " Fetch an IPv4 address, in network byte order."]
    #[doc = " We do *not* convert it to host byte order; we leave it in"]
    #[doc = " network byte order, as that's what its callers expect."]
    pub fn tvb_get_ipv4(tvb: *mut tvbuff_t, offset: gint) -> guint32;
}
extern "C" {
    pub fn tvb_get_ipv6(tvb: *mut tvbuff_t, offset: gint, addr: *mut ws_in6_addr);
}
extern "C" {
    pub fn tvb_get_ntohguid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t);
}
extern "C" {
    pub fn tvb_get_letohguid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t);
}
extern "C" {
    pub fn tvb_get_guid(tvb: *mut tvbuff_t, offset: gint, guid: *mut e_guid_t, encoding: guint);
}
extern "C" {
    pub fn tvb_get_bits8(tvb: *mut tvbuff_t, bit_offset: guint, no_of_bits: gint) -> guint8;
}
extern "C" {
    pub fn tvb_get_bits16(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint16;
}
extern "C" {
    pub fn tvb_get_bits32(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint32;
}
extern "C" {
    pub fn tvb_get_bits64(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint64;
}
extern "C" {
    #[doc = "  This function has EXACTLY the same behavior as"]
    #[doc = "  tvb_get_bits32()"]
    pub fn tvb_get_bits(
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> guint32;
}
extern "C" {
    #[doc = " Returns target for convenience. Does not suffer from possible"]
    #[doc = " expense of tvb_get_ptr(), since this routine is smart enough"]
    #[doc = " to copy data in chunks if the request range actually exists in"]
    #[doc = " different \"real\" tvbuffs. This function assumes that the target"]
    #[doc = " memory is already allocated; it does not allocate or free the"]
    #[doc = " target memory."]
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length:"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    copy the data from the tvbuff specified by the offset and length"]
    #[doc = "    into that buffer, using tvb_memcpy();"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the data being copied does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_memdup(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " WARNING! This function is possibly expensive, temporarily allocating"]
    #[doc = " another copy of the packet data. Furthermore, it's dangerous because once"]
    #[doc = " this pointer is given to the user, there's no guarantee that the user will"]
    #[doc = " honor the 'length' and not overstep the boundaries of the buffer."]
    #[doc = ""]
    #[doc = " If you're thinking of using tvb_get_ptr, STOP WHAT YOU ARE DOING"]
    #[doc = " IMMEDIATELY. Go take a break. Consider that tvb_get_ptr hands you"]
    #[doc = " a raw, unprotected pointer that you can easily use to create a"]
    #[doc = " security vulnerability or otherwise crash Wireshark. Then consider"]
    #[doc = " that you can probably find a function elsewhere in this file that"]
    #[doc = " does exactly what you want in a much more safe and robust manner."]
    #[doc = ""]
    #[doc = " The returned pointer is data that is internal to the tvbuff, so do not"]
    #[doc = " attempt to free it. Don't modify the data, either, because another tvbuff"]
    #[doc = " that might be using this tvbuff may have already copied that portion of"]
    #[doc = " the data (sometimes tvbuff's need to make copies of data, but that's the"]
    #[doc = " internal implementation that you need not worry about). Assume that the"]
    #[doc = " guint8* points to read-only data that the tvbuff manages."]
    #[doc = ""]
    #[doc = " Return a pointer into our buffer if the data asked for via 'offset'/'length'"]
    #[doc = " is contiguous (which might not be the case for a \"composite\" tvbuff). If the"]
    #[doc = " data is not contiguous, a tvb_memdup() is called for the entire buffer"]
    #[doc = " and the pointer to the newly-contiguous data is returned. This dynamically-"]
    #[doc = " allocated memory will be freed when the tvbuff is freed, after the"]
    #[doc = " tvbuff_free_cb_t() is called, if any."]
    pub fn tvb_get_ptr(tvb: *mut tvbuff_t, offset: gint, length: gint) -> *const guint8;
}
extern "C" {
    #[doc = " Find first occurrence of needle in tvbuff, starting at offset. Searches"]
    #[doc = " at most maxlength number of bytes; if maxlength is -1, searches to"]
    #[doc = " end of tvbuff."]
    #[doc = " Returns the offset of the found needle, or -1 if not found."]
    #[doc = " Will not throw an exception, even if maxlength exceeds boundary of tvbuff;"]
    #[doc = " in that case, -1 will be returned if the boundary is reached before"]
    #[doc = " finding needle."]
    pub fn tvb_find_guint8(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        needle: guint8,
    ) -> gint;
}
extern "C" {
    #[doc = " Same as tvb_find_guint8() with 16bit needle."]
    pub fn tvb_find_guint16(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        needle: guint16,
    ) -> gint;
}
extern "C" {
    #[doc = " Find first occurrence of any of the needles of the pre-compiled pattern in"]
    #[doc = " tvbuff, starting at offset. The passed in pattern must have been \"compiled\""]
    #[doc = " before-hand, using ws_mempbrk_compile()."]
    #[doc = " Searches at most maxlength number of bytes. Returns the offset of the"]
    #[doc = " found needle, or -1 if not found and the found needle."]
    #[doc = " Will not throw an exception, even if"]
    #[doc = " maxlength exceeds boundary of tvbuff; in that case, -1 will be returned if"]
    #[doc = " the boundary is reached before finding needle."]
    pub fn tvb_ws_mempbrk_pattern_guint8(
        tvb: *mut tvbuff_t,
        offset: gint,
        maxlength: gint,
        pattern: *const ws_mempbrk_pattern,
        found_needle: *mut guchar,
    ) -> gint;
}
extern "C" {
    #[doc = " Find size of stringz (NUL-terminated string) by looking for terminating"]
    #[doc = " NUL.  The size of the string includes the terminating NUL."]
    #[doc = ""]
    #[doc = " If the NUL isn't found, it throws the appropriate exception."]
    pub fn tvb_strsize(tvb: *mut tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    #[doc = " Find size of UCS-2 or UTF-16 stringz (NUL-terminated string) by"]
    #[doc = " looking for terminating 16-bit NUL.  The size of the string includes"]
    #[doc = " the terminating NUL."]
    #[doc = ""]
    #[doc = " If the NUL isn't found, it throws the appropriate exception."]
    pub fn tvb_unicode_strsize(tvb: *mut tvbuff_t, offset: gint) -> guint;
}
extern "C" {
    #[doc = " Find length of string by looking for end of zero terminated string, up to"]
    #[doc = " 'maxlength' characters'; if 'maxlength' is -1, searches to end"]
    #[doc = " of tvbuff."]
    #[doc = " Returns -1 if 'maxlength' reached before finding EOS."]
    pub fn tvb_strnlen(tvb: *mut tvbuff_t, offset: gint, maxlength: guint) -> gint;
}
extern "C" {
    #[doc = " Format the data in the tvb from offset for size.  Returned string is"]
    #[doc = " wmem packet_scoped so call must be in that scope."]
    pub fn tvb_format_text(tvb: *mut tvbuff_t, offset: gint, size: gint) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text()\", but for 'wsp'; don't show"]
    #[doc = " the characters as C-style escapes."]
    pub fn tvb_format_text_wsp(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text()\", but for null-padded strings; don't show"]
    #[doc = " the null padding characters as \"\\000\".  Returned string is wmem packet_scoped"]
    #[doc = " so call must be in that scope."]
    pub fn tvb_format_stringzpad(tvb: *mut tvbuff_t, offset: gint, size: gint) -> *mut gchar;
}
extern "C" {
    #[doc = " Like \"tvb_format_text_wsp()\", but for null-padded strings; don't show"]
    #[doc = " the null padding characters as \"\\000\"."]
    pub fn tvb_format_stringzpad_wsp(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        size: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length, and"]
    #[doc = " a string encoding, with the specified offset and length referring to"]
    #[doc = " a string in the specified encoding:"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    convert the string from the specified encoding to UTF-8, possibly"]
    #[doc = "    mapping some characters or invalid octet sequences to the Unicode"]
    #[doc = "    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a"]
    #[doc = "    trailing '\\0', into that buffer;"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the string does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_get_string_enc(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a bit offset, and a length in"]
    #[doc = " 7-bit characters (not octets!), with the specified offset and"]
    #[doc = " length referring to a string in the 3GPP TS 23.038 7bits encoding:"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    convert the string from the specified encoding to UTF-8, possibly"]
    #[doc = "    mapping some characters or invalid octet sequences to the Unicode"]
    #[doc = "    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a"]
    #[doc = "    trailing '\\0', into that buffer;"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the string does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_get_ts_23_038_7bits_string(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        bit_offset: gint,
        no_of_chars: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a bit offset, and a length in"]
    #[doc = " 7-bit characters (not octets!), with the specified offset and"]
    #[doc = " length referring to a string in the ASCII 7bits encoding:"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    convert the string from the specified encoding to UTF-8, possibly"]
    #[doc = "    mapping some characters or invalid octet sequences to the Unicode"]
    #[doc = "    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a"]
    #[doc = "    trailing '\\0', into that buffer;"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the string does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_get_ascii_7bits_string(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        bit_offset: gint,
        no_of_chars: gint,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a byte length, and"]
    #[doc = " a string encoding, with the specified offset and length referring to"]
    #[doc = " a null-padded string in the specified encoding:"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    convert the string from the specified encoding to UTF-8, possibly"]
    #[doc = "    mapping some characters or invalid octet sequences to the Unicode"]
    #[doc = "    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a"]
    #[doc = "    trailing '\\0', into that buffer;"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the string does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_get_stringzpad(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        length: gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given an allocator scope, a tvbuff, a byte offset, a pointer to a"]
    #[doc = " gint, and a string encoding, with the specified offset referring to"]
    #[doc = " a null-terminated string in the specified encoding:"]
    #[doc = ""]
    #[doc = "    find the length of that string (and throw an exception if the tvbuff"]
    #[doc = "    ends before we find the null);"]
    #[doc = ""]
    #[doc = "    allocate a buffer using the specified scope;"]
    #[doc = ""]
    #[doc = "    convert the string from the specified encoding to UTF-8, possibly"]
    #[doc = "    mapping some characters or invalid octet sequences to the Unicode"]
    #[doc = "    REPLACEMENT CHARACTER, and put the resulting UTF-8 string, plus a"]
    #[doc = "    trailing '\\0', into that buffer;"]
    #[doc = ""]
    #[doc = "    if the pointer to the gint is non-null, set the gint to which it"]
    #[doc = "    points to the length of the string;"]
    #[doc = ""]
    #[doc = "    and return a pointer to the buffer."]
    #[doc = ""]
    #[doc = " Throws an exception if the tvbuff ends before the string does."]
    #[doc = ""]
    #[doc = " If scope is set to NULL it is the user's responsibility to wmem_free()"]
    #[doc = " the memory allocated. Otherwise memory is automatically freed when the"]
    #[doc = " scope lifetime is reached."]
    pub fn tvb_get_stringz_enc(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        lengthp: *mut gint,
        encoding: guint,
    ) -> *mut guint8;
}
extern "C" {
    #[doc = " Given a tvbuff and an offset, with the offset assumed to refer to"]
    #[doc = " a null-terminated string, find the length of that string (and throw"]
    #[doc = " an exception if the tvbuff ends before we find the null), allocate"]
    #[doc = " a buffer big enough to hold the string, copy the string into it,"]
    #[doc = " and return a pointer to the string.  Also return the length of the"]
    #[doc = " string (including the terminating null) through a pointer."]
    #[doc = ""]
    #[doc = " This returns a constant (unmodifiable) string that does not need"]
    #[doc = " to be freed; instead, it will automatically be freed once the next"]
    #[doc = " packet is dissected."]
    #[doc = ""]
    #[doc = " It is slightly more efficient than the other routines, but does *NOT*"]
    #[doc = " do any translation to UTF-8 - the string consists of the raw octets"]
    #[doc = " of the string, in whatever encoding they happen to be in, and, if"]
    #[doc = " the string is not valid in that encoding, with invalid octet sequences"]
    #[doc = " as they are in the packet."]
    pub fn tvb_get_const_stringz(
        tvb: *mut tvbuff_t,
        offset: gint,
        lengthp: *mut gint,
    ) -> *const guint8;
}
extern "C" {
    #[doc = " Looks for a stringz (NUL-terminated string) in tvbuff and copies"]
    #[doc = " no more than bufsize number of bytes, including terminating NUL, to buffer."]
    #[doc = " Returns length of string (not including terminating NUL), or -1 if the"]
    #[doc = " string was truncated in the buffer due to not having reached the terminating"]
    #[doc = " NUL.  In this way, it acts like g_snprintf()."]
    #[doc = ""]
    #[doc = " When processing a packet where the remaining number of bytes is less"]
    #[doc = " than bufsize, an exception is not thrown if the end of the packet"]
    #[doc = " is reached before the NUL is found. If no NUL is found before reaching"]
    #[doc = " the end of the short packet, -1 is still returned, and the string"]
    #[doc = " is truncated with a NUL, albeit not at buffer[bufsize - 1], but"]
    #[doc = " at the correct spot, terminating the string."]
    pub fn tvb_get_nstringz(
        tvb: *mut tvbuff_t,
        offset: gint,
        bufsize: guint,
        buffer: *mut guint8,
    ) -> gint;
}
extern "C" {
    #[doc = " Like tvb_get_nstringz(), but never returns -1. The string is guaranteed to"]
    #[doc = " have a terminating NUL. If the string was truncated when copied into buffer,"]
    #[doc = " a NUL is placed at the end of buffer to terminate it."]
    #[doc = ""]
    #[doc = " bufsize MUST be greater than 0."]
    pub fn tvb_get_nstringz0(
        tvb: *mut tvbuff_t,
        offset: gint,
        bufsize: guint,
        buffer: *mut guint8,
    ) -> gint;
}
extern "C" {
    pub fn tvb_get_raw_bytes_as_string(
        tvb: *mut tvbuff_t,
        offset: gint,
        buffer: *mut ::std::os::raw::c_char,
        bufsize: size_t,
    ) -> gint;
}
extern "C" {
    #[doc = " Iterates over the provided portion of the tvb checking that each byte"]
    #[doc = " is an ascii printable character."]
    #[doc = " Returns TRUE if all bytes are printable, FALSE otherwise"]
    pub fn tvb_ascii_isprint(tvb: *mut tvbuff_t, offset: gint, length: gint) -> gboolean;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts"]
    #[doc = " at that offset (which may be -1 for \"all the way to the end of the"]
    #[doc = " tvbuff\"), find the end of the (putative) line that starts at the"]
    #[doc = " specified offset in the tvbuff, going no further than the specified"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " Return the length of the line (not counting the line terminator at"]
    #[doc = " the end), or, if we don't find a line terminator:"]
    #[doc = ""]
    #[doc = "  if \"deseg\" is true, return -1;"]
    #[doc = ""]
    #[doc = "  if \"deseg\" is false, return the amount of data remaining in"]
    #[doc = "  the buffer."]
    #[doc = ""]
    #[doc = " Set \"*next_offset\" to the offset of the character past the line"]
    #[doc = " terminator, or past the end of the buffer if we don't find a line"]
    #[doc = " terminator.  (It's not set if we return -1.)"]
    pub fn tvb_find_line_end(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
        desegment: gboolean,
    ) -> gint;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts"]
    #[doc = " at that offset (which may be -1 for \"all the way to the end of the"]
    #[doc = " tvbuff\"), find the end of the (putative) line that starts at the"]
    #[doc = " specified offset in the tvbuff, going no further than the specified"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " However, treat quoted strings inside the buffer specially - don't"]
    #[doc = " treat newlines in quoted strings as line terminators."]
    #[doc = ""]
    #[doc = " Return the length of the line (not counting the line terminator at"]
    #[doc = " the end), or the amount of data remaining in the buffer if we don't"]
    #[doc = " find a line terminator."]
    #[doc = ""]
    #[doc = " Set \"*next_offset\" to the offset of the character past the line"]
    #[doc = " terminator, or past the end of the buffer if we don't find a line"]
    #[doc = " terminator."]
    pub fn tvb_find_line_end_unquoted(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
    ) -> gint;
}
extern "C" {
    #[doc = " Copied from the mgcp dissector. (This function should be moved to /epan )"]
    #[doc = " tvb_skip_wsp - Returns the position in tvb of the first non-whitespace"]
    #[doc = "                character following offset or offset + maxlength -1 whichever"]
    #[doc = "                is smaller."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = " tvb - The tvbuff in which we are skipping whitespace."]
    #[doc = " offset - The offset in tvb from which we begin trying to skip whitespace."]
    #[doc = " maxlength - The maximum distance from offset that we may try to skip"]
    #[doc = " whitespace."]
    #[doc = ""]
    #[doc = " Returns: The position in tvb of the first non-whitespace"]
    #[doc = "          character following offset or offset + maxlength -1 whichever"]
    #[doc = "          is smaller."]
    pub fn tvb_skip_wsp(tvb: *mut tvbuff_t, offset: gint, maxlength: gint) -> gint;
}
extern "C" {
    pub fn tvb_skip_wsp_return(tvb: *mut tvbuff_t, offset: gint) -> gint;
}
extern "C" {
    pub fn tvb_skip_guint8(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        maxlength: ::std::os::raw::c_int,
        ch: guint8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts"]
    #[doc = " at that offset (which may be -1 for \"all the way to the end of the"]
    #[doc = " tvbuff\"), find the end of the token that starts at the"]
    #[doc = " specified offset in the tvbuff, going no further than the specified"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " Return the length of the token, or, if we don't find a terminator:"]
    #[doc = ""]
    #[doc = "  if \"deseg\" is true, return -1;"]
    #[doc = ""]
    #[doc = "  if \"deseg\" is false, return the amount of data remaining in"]
    #[doc = "  the buffer."]
    #[doc = ""]
    #[doc = " Set \"*next_offset\" to the offset of the character past the"]
    #[doc = " terminator, or past the end of the buffer if we don't find a line"]
    #[doc = " terminator.  (It's not set if we return -1.)"]
    pub fn tvb_get_token_len(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: ::std::os::raw::c_int,
        next_offset: *mut gint,
        desegment: gboolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call strncmp after checking if enough chars left, returning 0 if"]
    #[doc = " it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_strneql(tvb: *mut tvbuff_t, offset: gint, str: *const gchar, size: size_t) -> gint;
}
extern "C" {
    #[doc = " Call g_ascii_strncasecmp after checking if enough chars left, returning"]
    #[doc = " 0 if it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_strncaseeql(
        tvb: *mut tvbuff_t,
        offset: gint,
        str: *const gchar,
        size: size_t,
    ) -> gint;
}
extern "C" {
    #[doc = " Call memcmp after checking if enough chars left, returning 0 if"]
    #[doc = " it returns 0 (meaning \"equal\") and -1 otherwise, otherwise return -1."]
    pub fn tvb_memeql(tvb: *mut tvbuff_t, offset: gint, str: *const guint8, size: size_t) -> gint;
}
extern "C" {
    #[doc = " Format a bunch of data from a tvbuff as bytes, returning a pointer"]
    #[doc = " to the string with the formatted data, with \"punct\" as a byte"]
    #[doc = " separator."]
    pub fn tvb_bytes_to_str_punct(
        scope: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        punct: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " Format a bunch of data from a tvbuff as bytes, returning a pointer"]
    #[doc = " to the string with the formatted data."]
    pub fn tvb_bytes_to_str(
        allocator: *mut wmem_allocator_t,
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
    ) -> *mut gchar;
}
#[doc = " Given a tvbuff, an offset into the tvbuff, and a length that starts"]
#[doc = " at that offset (which may be -1 for \"all the way to the end of the"]
#[doc = " tvbuff\"), fetch BCD encoded digits from a tvbuff starting from either"]
#[doc = " the low or high half byte, formatting the digits according to an input digit"]
#[doc = " set, if NUL a default digit set of 0-9 returning \"?\" for overdecadic digits"]
#[doc = " will be used.  A pointer to the packet-scope (WMEM-allocated) string will"]
#[doc = " be returned. Note a tvbuff content of 0xf is considered a 'filler' and will"]
#[doc = " end the conversion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dgt_set_t {
    pub out: [::std::os::raw::c_uchar; 16usize],
}
extern "C" {
    pub fn tvb_bcd_dig_to_wmem_packet_str(
        tvb: *mut tvbuff_t,
        offset: gint,
        len: gint,
        dgt: *const dgt_set_t,
        skip_first: gboolean,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Locate a sub-tvbuff within another tvbuff, starting at position"]
    #[doc = " 'haystack_offset'. Returns the index of the beginning of 'needle' within"]
    #[doc = " 'haystack', or -1 if 'needle' is not found. The index is relative"]
    #[doc = " to the start of 'haystack', not 'haystack_offset'."]
    pub fn tvb_find_tvb(
        haystack_tvb: *mut tvbuff_t,
        needle_tvb: *mut tvbuff_t,
        haystack_offset: gint,
    ) -> gint;
}
extern "C" {
    #[doc = " Uncompresses a zlib compressed packet inside a tvbuff at offset with"]
    #[doc = " length comprlen.  Returns an uncompressed tvbuffer if uncompression"]
    #[doc = " succeeded or NULL if uncompression failed."]
    pub fn tvb_uncompress(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a zlib compressed packet inside a tvbuff at offset with"]
    #[doc = " length comprlen.  Returns an uncompressed tvbuffer attached to tvb if"]
    #[doc = " uncompression succeeded or NULL if uncompression failed."]
    pub fn tvb_child_uncompress(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a brotli compressed packet inside a tvbuff at offset with"]
    #[doc = " length comprlen.  Returns an uncompressed tvbuffer if uncompression"]
    #[doc = " succeeded or NULL if uncompression failed."]
    pub fn tvb_uncompress_brotli(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a brotli compressed packet inside a tvbuff at offset with"]
    #[doc = " length comprlen.  Returns an uncompressed tvbuffer attached to tvb if"]
    #[doc = " uncompression succeeded or NULL if uncompression failed."]
    pub fn tvb_child_uncompress_brotli(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft Plain LZ77 compressed payload inside a"]
    #[doc = " tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer if uncompression succeeded or NULL if uncompression"]
    #[doc = " failed."]
    pub fn tvb_uncompress_lz77(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft Plain LZ77 compressed payload inside a"]
    #[doc = " tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer attached to tvb if uncompression succeeded or NULL if"]
    #[doc = " uncompression failed."]
    pub fn tvb_child_uncompress_lz77(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZ77+Huffman compressed payload inside a"]
    #[doc = " tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer if uncompression succeeded or NULL if uncompression"]
    #[doc = " failed."]
    pub fn tvb_uncompress_lz77huff(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZ77+Huffman compressed payload inside a"]
    #[doc = " tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer attached to tvb if uncompression succeeded or NULL if"]
    #[doc = " uncompression failed."]
    pub fn tvb_child_uncompress_lz77huff(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZNT1 compressed payload inside"]
    #[doc = " a tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer if uncompression succeeded or NULL if uncompression"]
    #[doc = " failed."]
    pub fn tvb_uncompress_lznt1(
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Uncompresses a Microsoft LZNT1 compressed payload inside"]
    #[doc = " a tvbuff at offset with length comprlen.  Returns an uncompressed"]
    #[doc = " tvbuffer if uncompression succeeded or NULL if uncompression"]
    #[doc = " failed."]
    pub fn tvb_child_uncompress_lznt1(
        parent: *mut tvbuff_t,
        tvb: *mut tvbuff_t,
        offset: ::std::os::raw::c_int,
        comprlen: ::std::os::raw::c_int,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Return a tvb that contains the binary representation of a base64"]
    #[doc = "  string as a child of the indicated tvb."]
    #[doc = ""]
    #[doc = " @param parent The parent tvbuff."]
    #[doc = " @param base64 The base64 encoded string which binary representation will be"]
    #[doc = "               returned in the child tvb."]
    #[doc = ""]
    #[doc = " @return   A tvb with the binary representation of the base64 decoded string."]
    pub fn base64_to_tvb(
        parent: *mut tvbuff_t,
        base64: *const ::std::os::raw::c_char,
    ) -> *mut tvbuff_t;
}
extern "C" {
    #[doc = " Extract a variable length integer from a tvbuff."]
    #[doc = " Each byte in a varint, except the last byte, has the most significant bit (msb)"]
    #[doc = " set -- this indicates that there are further bytes to come. For example,"]
    #[doc = "   1010 1100 0000 0010 is 300"]
    #[doc = ""]
    #[doc = " @param tvb The tvbuff in which we are extracting integer."]
    #[doc = " @param offset The offset in tvb from which we begin trying to extract integer."]
    #[doc = " @param maxlen The maximum distance from offset that we may try to extract integer"]
    #[doc = " @param value  if parsing succeeds, parsed varint will store here."]
    #[doc = " @param encoding The ENC_* that defines the format (e.g., ENC_VARINT_PROTOBUF, ENC_VARINT_QUIC, ENC_VARINT_ZIGZAG)"]
    #[doc = " @return   the length of this varint in tvb. 0 means parsing failed."]
    pub fn tvb_get_varint(
        tvb: *mut tvbuff_t,
        offset: guint,
        maxlen: guint,
        value: *mut guint64,
        encoding: guint,
    ) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _value_string {
    pub value: guint32,
    pub strptr: *const gchar,
}
pub type value_string = _value_string;
extern "C" {
    pub fn val_to_str(
        val: guint32,
        vs: *const value_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val_to_str_wmem(
        scope: *mut wmem_allocator_t,
        val: guint32,
        vs: *const value_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val_to_str_const(
        val: guint32,
        vs: *const value_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str(val: guint32, vs: *const value_string) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_idx(
        val: guint32,
        vs: *const value_string,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _val64_string {
    pub value: guint64,
    pub strptr: *const gchar,
}
pub type val64_string = _val64_string;
extern "C" {
    pub fn val64_to_str(
        val: guint64,
        vs: *const val64_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val64_to_str_const(
        val: guint64,
        vs: *const val64_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str(val: guint64, vs: *const val64_string) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_idx(
        val: guint64,
        vs: *const val64_string,
        idx: *mut gint,
    ) -> *const gchar;
}
extern "C" {
    pub fn str_to_val(val: *const gchar, vs: *const value_string, err_val: guint32) -> guint32;
}
extern "C" {
    pub fn str_to_val_idx(val: *const gchar, vs: *const value_string) -> gint;
}
pub type value_string_ext = _value_string_ext;
pub type _value_string_match2_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: guint32, arg2: *mut value_string_ext) -> *const value_string,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _value_string_ext {
    pub _vs_match2: _value_string_match2_t,
    pub _vs_first_value: guint32,
    pub _vs_num_entries: guint,
    pub _vs_p: *const value_string,
    pub _vs_name: *const gchar,
}
extern "C" {
    pub fn _try_val_to_str_ext_init(
        val: guint32,
        vse: *mut value_string_ext,
    ) -> *const value_string;
}
extern "C" {
    pub fn value_string_ext_new(
        vs: *const value_string,
        vs_tot_num_entries: guint,
        vs_name: *const gchar,
    ) -> *mut value_string_ext;
}
extern "C" {
    pub fn value_string_ext_free(vse: *mut value_string_ext);
}
extern "C" {
    pub fn val_to_str_ext(
        val: guint32,
        vse: *mut value_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val_to_str_ext_wmem(
        scope: *mut wmem_allocator_t,
        val: guint32,
        vse: *mut value_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val_to_str_ext_const(
        val: guint32,
        vs: *mut value_string_ext,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_ext(val: guint32, vse: *mut value_string_ext) -> *const gchar;
}
extern "C" {
    pub fn try_val_to_str_idx_ext(
        val: guint32,
        vse: *mut value_string_ext,
        idx: *mut gint,
    ) -> *const gchar;
}
pub type val64_string_ext = _val64_string_ext;
pub type _val64_string_match2_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: guint64, arg2: *mut val64_string_ext) -> *const val64_string,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _val64_string_ext {
    pub _vs_match2: _val64_string_match2_t,
    pub _vs_first_value: guint64,
    pub _vs_num_entries: guint,
    pub _vs_p: *const val64_string,
    pub _vs_name: *const gchar,
}
extern "C" {
    pub fn _try_val64_to_str_ext_init(
        val: guint64,
        vse: *mut val64_string_ext,
    ) -> *const val64_string;
}
extern "C" {
    pub fn val64_string_ext_new(
        vs: *const val64_string,
        vs_tot_num_entries: guint,
        vs_name: *const gchar,
    ) -> *mut val64_string_ext;
}
extern "C" {
    pub fn val64_string_ext_free(vse: *mut val64_string_ext);
}
extern "C" {
    pub fn val64_to_str_ext(
        val: guint64,
        vse: *mut val64_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn val64_to_str_ext_wmem(
        scope: *mut wmem_allocator_t,
        val: guint64,
        vse: *mut val64_string_ext,
        fmt: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    pub fn val64_to_str_ext_const(
        val: guint64,
        vs: *mut val64_string_ext,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_ext(val: guint64, vse: *mut val64_string_ext) -> *const gchar;
}
extern "C" {
    pub fn try_val64_to_str_idx_ext(
        val: guint64,
        vse: *mut val64_string_ext,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _string_string {
    pub value: *const gchar,
    pub strptr: *const gchar,
}
pub type string_string = _string_string;
extern "C" {
    pub fn str_to_str(
        val: *const gchar,
        vs: *const string_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_str_to_str(val: *const gchar, vs: *const string_string) -> *const gchar;
}
extern "C" {
    pub fn try_str_to_str_idx(
        val: *const gchar,
        vs: *const string_string,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _range_string {
    pub value_min: guint32,
    pub value_max: guint32,
    pub strptr: *const gchar,
}
pub type range_string = _range_string;
extern "C" {
    pub fn rval_to_str(
        val: guint32,
        rs: *const range_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn rval_to_str_const(
        val: guint32,
        rs: *const range_string,
        unknown_str: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_rval_to_str(val: guint32, rs: *const range_string) -> *const gchar;
}
extern "C" {
    pub fn try_rval_to_str_idx(
        val: guint32,
        rs: *const range_string,
        idx: *mut gint,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_rval64_to_str(val: guint64, rs: *const range_string) -> *const gchar;
}
extern "C" {
    pub fn try_rval64_to_str_idx(
        val: guint64,
        rs: *const range_string,
        idx: *mut gint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bytes_string {
    pub value: *const guint8,
    pub value_length: size_t,
    pub strptr: *const gchar,
}
pub type bytes_string = _bytes_string;
extern "C" {
    pub fn bytesval_to_str(
        val: *const guint8,
        val_len: size_t,
        bs: *const bytes_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_bytesval_to_str(
        val: *const guint8,
        val_len: size_t,
        bs: *const bytes_string,
    ) -> *const gchar;
}
extern "C" {
    pub fn bytesprefix_to_str(
        haystack: *const guint8,
        haystack_len: size_t,
        bs: *const bytes_string,
        fmt: *const ::std::os::raw::c_char,
    ) -> *const gchar;
}
extern "C" {
    pub fn try_bytesprefix_to_str(
        haystack: *const guint8,
        haystack_len: size_t,
        bs: *const bytes_string,
    ) -> *const gchar;
}
extern "C" {
    pub fn value_string_ext_validate(vse: *const value_string_ext) -> gboolean;
}
extern "C" {
    pub fn value_string_ext_match_type_str(vse: *const value_string_ext) -> *const gchar;
}
extern "C" {
    pub fn val64_string_ext_validate(vse: *const val64_string_ext) -> gboolean;
}
extern "C" {
    pub fn val64_string_ext_match_type_str(vse: *const val64_string_ext) -> *const gchar;
}
#[doc = " Struct for boolean enumerations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct true_false_string {
    #[doc = "< The string presented when true"]
    pub true_string: *const ::std::os::raw::c_char,
    #[doc = "< The string presented when false"]
    pub false_string: *const ::std::os::raw::c_char,
}
extern "C" {
    pub static tfs_true_false: true_false_string;
}
extern "C" {
    pub static tfs_yes_no: true_false_string;
}
extern "C" {
    pub static tfs_no_yes: true_false_string;
}
extern "C" {
    pub static tfs_set_notset: true_false_string;
}
extern "C" {
    pub static tfs_enabled_disabled: true_false_string;
}
extern "C" {
    pub static tfs_disabled_enabled: true_false_string;
}
extern "C" {
    pub static tfs_ok_error: true_false_string;
}
extern "C" {
    pub static tfs_error_ok: true_false_string;
}
extern "C" {
    pub static tfs_success_fail: true_false_string;
}
extern "C" {
    pub static tfs_fail_success: true_false_string;
}
extern "C" {
    pub static tfs_on_off: true_false_string;
}
extern "C" {
    pub static tfs_ack_nack: true_false_string;
}
extern "C" {
    pub static tfs_odd_even: true_false_string;
}
extern "C" {
    pub static tfs_allow_block: true_false_string;
}
extern "C" {
    pub static tfs_restricted_allowed: true_false_string;
}
extern "C" {
    pub static tfs_restricted_not_restricted: true_false_string;
}
extern "C" {
    pub static tfs_accept_reject: true_false_string;
}
extern "C" {
    pub static tfs_more_nomore: true_false_string;
}
extern "C" {
    pub static tfs_present_absent: true_false_string;
}
extern "C" {
    pub static tfs_present_not_present: true_false_string;
}
extern "C" {
    pub static tfs_active_inactive: true_false_string;
}
extern "C" {
    pub static tfs_activated_deactivated: true_false_string;
}
extern "C" {
    pub static tfs_found_not_found: true_false_string;
}
extern "C" {
    pub static tfs_command_response: true_false_string;
}
extern "C" {
    pub static tfs_response_command: true_false_string;
}
extern "C" {
    pub static tfs_capable_not_capable: true_false_string;
}
extern "C" {
    pub static tfs_supported_not_supported: true_false_string;
}
extern "C" {
    pub static tfs_not_supported_supported: true_false_string;
}
extern "C" {
    pub static tfs_used_notused: true_false_string;
}
extern "C" {
    pub static tfs_high_low: true_false_string;
}
extern "C" {
    pub static tfs_high_normal: true_false_string;
}
extern "C" {
    pub static tfs_low_normal: true_false_string;
}
extern "C" {
    pub static tfs_pressed_not_pressed: true_false_string;
}
extern "C" {
    pub static tfs_implemented_not_implemented: true_false_string;
}
extern "C" {
    pub static tfs_requested_not_requested: true_false_string;
}
extern "C" {
    pub static tfs_reliable_not_reliable: true_false_string;
}
extern "C" {
    pub static tfs_allowed_not_allowed: true_false_string;
}
extern "C" {
    pub static tfs_not_allowed_allowed: true_false_string;
}
extern "C" {
    pub static tfs_accepted_not_accepted: true_false_string;
}
extern "C" {
    pub static tfs_detected_not_detected: true_false_string;
}
extern "C" {
    pub static tfs_available_not_available: true_false_string;
}
extern "C" {
    pub static tfs_shared_independent: true_false_string;
}
extern "C" {
    pub static tfs_valid_invalid: true_false_string;
}
extern "C" {
    pub static tfs_invalid_valid: true_false_string;
}
extern "C" {
    pub static tfs_group_unique_name: true_false_string;
}
extern "C" {
    pub static tfs_inuse_not_inuse: true_false_string;
}
extern "C" {
    pub static tfs_critical_not_critical: true_false_string;
}
extern "C" {
    pub static tfs_complete_incomplete: true_false_string;
}
extern "C" {
    pub static tfs_valid_not_valid: true_false_string;
}
extern "C" {
    pub static tfs_do_not_clear_clear: true_false_string;
}
extern "C" {
    pub static tfs_confirmed_unconfirmed: true_false_string;
}
extern "C" {
    pub static tfs_enforced_not_enforced: true_false_string;
}
extern "C" {
    pub static tfs_possible_not_possible: true_false_string;
}
extern "C" {
    pub static tfs_required_not_required: true_false_string;
}
extern "C" {
    pub static tfs_registered_not_registered: true_false_string;
}
extern "C" {
    pub static tfs_provisioned_not_provisioned: true_false_string;
}
extern "C" {
    pub static tfs_included_not_included: true_false_string;
}
extern "C" {
    pub static tfs_allocated_by_receiver_sender: true_false_string;
}
extern "C" {
    pub static tfs_asynchronous_synchronous: true_false_string;
}
extern "C" {
    pub static tfs_protocol_sensative_bit_transparent: true_false_string;
}
extern "C" {
    pub static tfs_full_half: true_false_string;
}
extern "C" {
    pub static tfs_acknowledged_not_acknowledged: true_false_string;
}
extern "C" {
    pub static tfs_segmentation_no_segmentation: true_false_string;
}
extern "C" {
    pub static tfs_response_request: true_false_string;
}
extern "C" {
    pub static tfs_defined_not_defined: true_false_string;
}
extern "C" {
    pub static tfs_constructed_primitive: true_false_string;
}
extern "C" {
    pub static tfs_client_server: true_false_string;
}
extern "C" {
    pub static tfs_server_client: true_false_string;
}
extern "C" {
    pub static tfs_preferred_no_preference: true_false_string;
}
extern "C" {
    pub static tfs_encrypt_do_not_encrypt: true_false_string;
}
extern "C" {
    pub static tfs_down_up: true_false_string;
}
extern "C" {
    pub static tfs_up_down: true_false_string;
}
extern "C" {
    pub static tfs_downlink_uplink: true_false_string;
}
extern "C" {
    pub static tfs_uplink_downlink: true_false_string;
}
extern "C" {
    pub static tfs_s2c_c2s: true_false_string;
}
extern "C" {
    pub static tfs_c2s_s2c: true_false_string;
}
extern "C" {
    pub static tfs_open_closed: true_false_string;
}
extern "C" {
    pub static tfs_external_internal: true_false_string;
}
extern "C" {
    pub static tfs_changed_not_changed: true_false_string;
}
extern "C" {
    pub static tfs_needed_not_needed: true_false_string;
}
extern "C" {
    pub static tfs_selected_not_selected: true_false_string;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    pub data: *mut guint8,
    pub allocated: gsize,
    pub start: gsize,
    pub first_free: gsize,
}
extern "C" {
    pub fn ws_buffer_init(buffer: *mut Buffer, space: gsize);
}
extern "C" {
    pub fn ws_buffer_free(buffer: *mut Buffer);
}
extern "C" {
    pub fn ws_buffer_assure_space(buffer: *mut Buffer, space: gsize);
}
extern "C" {
    pub fn ws_buffer_append(buffer: *mut Buffer, from: *mut guint8, bytes: gsize);
}
extern "C" {
    pub fn ws_buffer_remove_start(buffer: *mut Buffer, bytes: gsize);
}
extern "C" {
    pub fn ws_buffer_cleanup();
}
extern "C" {
    pub fn ws_inet_ntop4(src: gconstpointer, dst: *mut gchar, dst_size: guint) -> *const gchar;
}
extern "C" {
    pub fn ws_inet_ntop6(src: gconstpointer, dst: *mut gchar, dst_size: guint) -> *const gchar;
}
extern "C" {
    pub fn ws_inet_pton4(src: *const gchar, dst: *mut ws_in4_addr) -> gboolean;
}
extern "C" {
    pub fn ws_inet_pton6(src: *const gchar, dst: *mut ws_in6_addr) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_block {
    _unused: [u8; 0],
}
pub type wtap_block_t = *mut wtap_block;
pub const wtap_block_type_t_WTAP_BLOCK_NG_SECTION: wtap_block_type_t = 0;
pub const wtap_block_type_t_WTAP_BLOCK_IF_DESCR: wtap_block_type_t = 1;
pub const wtap_block_type_t_WTAP_BLOCK_NG_NRB: wtap_block_type_t = 2;
pub const wtap_block_type_t_WTAP_BLOCK_IF_STATS: wtap_block_type_t = 3;
pub const wtap_block_type_t_WTAP_BLOCK_DSB: wtap_block_type_t = 4;
pub const wtap_block_type_t_WTAP_BLOCK_END_OF_LIST: wtap_block_type_t = 5;
pub type wtap_block_type_t = i32;
pub const wtap_opttype_e_WTAP_OPTTYPE_UINT8: wtap_opttype_e = 0;
pub const wtap_opttype_e_WTAP_OPTTYPE_UINT64: wtap_opttype_e = 1;
pub const wtap_opttype_e_WTAP_OPTTYPE_STRING: wtap_opttype_e = 2;
pub const wtap_opttype_e_WTAP_OPTTYPE_IPv4: wtap_opttype_e = 3;
pub const wtap_opttype_e_WTAP_OPTTYPE_IPv6: wtap_opttype_e = 4;
pub const wtap_opttype_e_WTAP_OPTTYPE_CUSTOM: wtap_opttype_e = 5;
pub type wtap_opttype_e = i32;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_SUCCESS: wtap_opttype_return_val = 0;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NO_SUCH_OPTION: wtap_opttype_return_val = -1;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NOT_FOUND: wtap_opttype_return_val = -2;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_TYPE_MISMATCH: wtap_opttype_return_val = -3;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_NUMBER_MISMATCH: wtap_opttype_return_val = -4;
pub const wtap_opttype_return_val_WTAP_OPTTYPE_ALREADY_EXISTS: wtap_opttype_return_val = -5;
pub type wtap_opttype_return_val = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_opttype_custom {
    pub data: *mut ::std::os::raw::c_void,
    pub size: guint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_optval_t {
    pub uint8val: guint8,
    pub uint64val: guint64,
    pub ipv4val: guint32,
    pub ipv6val: ws_in6_addr,
    pub stringval: *mut ::std::os::raw::c_char,
    pub customval: wtap_opttype_custom,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_option_t {
    #[doc = "< option code for the option"]
    pub option_id: guint,
    #[doc = "< value"]
    pub value: wtap_optval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_dumper {
    _unused: [u8; 0],
}
pub type wtap_block_create_func = ::std::option::Option<unsafe extern "C" fn(block: wtap_block_t)>;
pub type wtap_mand_free_func = ::std::option::Option<unsafe extern "C" fn(block: wtap_block_t)>;
pub type wtap_mand_copy_func =
    ::std::option::Option<unsafe extern "C" fn(dest_block: wtap_block_t, src_block: wtap_block_t)>;
extern "C" {
    #[doc = " Initialize block types."]
    #[doc = ""]
    #[doc = " This is currently just a placeholder as nothing needs to be"]
    #[doc = " initialized yet.  Should handle \"registration\" when code is"]
    #[doc = " refactored to do so."]
    pub fn wtap_opttypes_initialize();
}
extern "C" {
    #[doc = " Create a block by type"]
    #[doc = ""]
    #[doc = " Return a newly allocated block with default options provided"]
    #[doc = ""]
    #[doc = " @param[in] block_type Block type to be created"]
    #[doc = " @return Newly allocated block"]
    pub fn wtap_block_create(block_type: wtap_block_type_t) -> wtap_block_t;
}
extern "C" {
    #[doc = " Free a block"]
    #[doc = ""]
    #[doc = " Needs to be called to clean up any allocated block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to be freed"]
    pub fn wtap_block_free(block: wtap_block_t);
}
extern "C" {
    #[doc = " Free an array of blocks"]
    #[doc = ""]
    #[doc = " Needs to be called to clean up blocks allocated"]
    #[doc = " through GArray (for multiple blocks of same type)"]
    #[doc = " Includes freeing the GArray"]
    #[doc = ""]
    #[doc = " @param[in] block_array Array of blocks to be freed"]
    pub fn wtap_block_array_free(block_array: *mut GArray);
}
extern "C" {
    #[doc = " Provide mandatory data of a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to retrieve mandatory data"]
    #[doc = " @return Block mandatory data.  Structure varies based on block type"]
    pub fn wtap_block_get_mandatory_data(block: wtap_block_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Add UINT8 option value to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_uint8_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set UINT8 option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_uint8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get UINT8 option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_uint8_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint8,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add UINT64 option value to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_uint64_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set UINT64 option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_uint64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get UINT64 option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_uint64_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint64,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add IPv4 address option value to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_ipv4_option(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set IPv4 option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_ipv4_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get IPv4 option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_ipv4_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut guint32,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add IPv6 address option value to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_ipv6_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set IPv6 option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_ipv6_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get IPv6 option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_ipv6_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ws_in6_addr,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a string option to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @param[in] value_length Maximum length of string to copy."]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_string_option(
        block: wtap_block_t,
        option_id: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a string option to a block witha printf-formatted string as its value"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] format printf-like format string"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_string_option_format(
        block: wtap_block_t,
        option_id: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @param[in] value_length Maximum length of string to copy."]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value for nth instance of a particular option in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] idx Instance number of option with that ID"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @param[in] value_length Maximum length of string to copy."]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_nth_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *const ::std::os::raw::c_char,
        value_length: gsize,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set string option value in a block to a printf-formatted string"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] format printf-like format string"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_string_option_value_format(
        block: wtap_block_t,
        option_id: guint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get string option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get string option value for nth instance of a particular option in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] idx Instance number of option with that ID"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_nth_string_option_value(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Add a \"custom\" option value to a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block to which to add the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value Value of option"]
    #[doc = " @param[in] value_size Size of value"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_add_custom_option(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ::std::os::raw::c_void,
        value_size: size_t,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Set a \"custom\" option value in a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block in which to set the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] value New value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_set_custom_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut ::std::os::raw::c_void,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Get a \"custom\" option value from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to get the option value"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[out] value Returned value of option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_get_custom_option_value(
        block: wtap_block_t,
        option_id: guint,
        value: *mut *mut ::std::os::raw::c_void,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Remove an option from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to remove the option"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_remove_option(
        block: wtap_block_t,
        option_id: guint,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Remove the nth instance of an option from a block"]
    #[doc = ""]
    #[doc = " @param[in] block Block from which to remove the option instance"]
    #[doc = " @param[in] option_id Identifier value for option"]
    #[doc = " @param[in] idx Instance number of option with that ID"]
    #[doc = " @return wtap_opttype_return_val - WTAP_OPTTYPE_SUCCESS if successful,"]
    #[doc = " error code otherwise"]
    pub fn wtap_block_remove_nth_option_instance(
        block: wtap_block_t,
        option_id: guint,
        idx: guint,
    ) -> wtap_opttype_return_val;
}
extern "C" {
    #[doc = " Copy a block to another."]
    #[doc = ""]
    #[doc = " Any options that are in the destination but not the source are not removed."]
    #[doc = " Options that are just in source will be added to destination"]
    #[doc = ""]
    #[doc = " @param[in] dest_block Block to be copied to"]
    #[doc = " @param[in] src_block Block to be copied from"]
    pub fn wtap_block_copy(dest_block: wtap_block_t, src_block: wtap_block_t);
}
pub type wtap_block_foreach_func = ::std::option::Option<
    unsafe extern "C" fn(
        block: wtap_block_t,
        option_id: guint,
        option_type: wtap_opttype_e,
        option: *mut wtap_optval_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn wtap_block_foreach_option(
        block: wtap_block_t,
        func: wtap_block_foreach_func,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wtap_opttype_register_custom_block_type(
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        create: wtap_block_create_func,
        free_mand: wtap_mand_free_func,
        copy_mand: wtap_mand_copy_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup the internal structures"]
    pub fn wtap_opttypes_cleanup();
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
pub type GModuleFlags = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_module_open_utf8(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    pub fn g_module_name_utf8(module: *mut GModule) -> *const gchar;
}
pub type plugin_register_func = ::std::option::Option<unsafe extern "C" fn()>;
pub type plugins_t = ::std::os::raw::c_void;
pub const plugin_type_e_WS_PLUGIN_EPAN: plugin_type_e = 0;
pub const plugin_type_e_WS_PLUGIN_WIRETAP: plugin_type_e = 1;
pub const plugin_type_e_WS_PLUGIN_CODEC: plugin_type_e = 2;
pub type plugin_type_e = i32;
extern "C" {
    pub fn plugins_init(type_: plugin_type_e) -> *mut plugins_t;
}
pub type plugin_description_callback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        version: *const ::std::os::raw::c_char,
        types: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn plugins_get_descriptions(
        callback: plugin_description_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn plugins_dump_all();
}
extern "C" {
    pub fn plugins_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plugins_cleanup(plugins: *mut plugins_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_phdr {
    pub fcs_len: gint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dte_dce_phdr {
    pub flags: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isdn_phdr {
    pub uton: gboolean,
    pub channel: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atm_phdr {
    pub flags: guint32,
    pub aal: guint8,
    pub type_: guint8,
    pub subtype: guint8,
    pub vpi: guint16,
    pub vci: guint16,
    pub aal2_cid: guint8,
    pub channel: guint16,
    pub cells: guint16,
    pub aal5t_u2u: guint16,
    pub aal5t_len: guint16,
    pub aal5t_chksum: guint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ascend_phdr {
    pub type_: guint16,
    pub user: [::std::os::raw::c_char; 64usize],
    pub sess: guint32,
    pub call_num: [::std::os::raw::c_char; 64usize],
    pub chunk: guint32,
    pub task: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p2p_phdr {
    pub sent: gboolean,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11_fhss {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub hop_set: guint8,
    pub hop_pattern: guint8,
    pub hop_index: guint8,
}
impl ieee_802_11_fhss {
    #[inline]
    pub fn has_hop_set(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_set(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hop_pattern(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_pattern(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_hop_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_hop_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_hop_set: guint,
        has_hop_pattern: guint,
        has_hop_index: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_hop_set: u32 = unsafe { ::std::mem::transmute(has_hop_set) };
            has_hop_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_hop_pattern: u32 = unsafe { ::std::mem::transmute(has_hop_pattern) };
            has_hop_pattern as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_hop_index: u32 = unsafe { ::std::mem::transmute(has_hop_index) };
            has_hop_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11b {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub short_preamble: gboolean,
}
impl ieee_802_11b {
    #[inline]
    pub fn has_short_preamble(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_preamble(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_short_preamble: guint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_short_preamble: u32 = unsafe { ::std::mem::transmute(has_short_preamble) };
            has_short_preamble as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11a {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ieee_802_11a {
    #[inline]
    pub fn has_channel_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_channel_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_turbo_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_turbo_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_channel_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn turbo_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_turbo_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_channel_type: guint,
        has_turbo_type: guint,
        channel_type: guint,
        turbo_type: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_channel_type: u32 = unsafe { ::std::mem::transmute(has_channel_type) };
            has_channel_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_turbo_type: u32 = unsafe { ::std::mem::transmute(has_turbo_type) };
            has_turbo_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let channel_type: u32 = unsafe { ::std::mem::transmute(channel_type) };
            channel_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let turbo_type: u32 = unsafe { ::std::mem::transmute(turbo_type) };
            turbo_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11g {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub short_preamble: gboolean,
    pub mode: guint32,
}
impl ieee_802_11g {
    #[inline]
    pub fn has_short_preamble(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_preamble(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_mode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_short_preamble: guint,
        has_mode: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_short_preamble: u32 = unsafe { ::std::mem::transmute(has_short_preamble) };
            has_short_preamble as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_mode: u32 = unsafe { ::std::mem::transmute(has_mode) };
            has_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11n {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
    pub mcs_index: guint16,
    pub bandwidth: guint,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ness: guint,
}
impl ieee_802_11n {
    #[inline]
    pub fn has_mcs_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mcs_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_bandwidth(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_bandwidth(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_greenfield(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_greenfield(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_stbc_streams(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_stbc_streams(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ness(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ness(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_mcs_index: guint,
        has_bandwidth: guint,
        has_short_gi: guint,
        has_greenfield: guint,
        has_fec: guint,
        has_stbc_streams: guint,
        has_ness: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mcs_index: u32 = unsafe { ::std::mem::transmute(has_mcs_index) };
            has_mcs_index as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_bandwidth: u32 = unsafe { ::std::mem::transmute(has_bandwidth) };
            has_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_short_gi: u32 = unsafe { ::std::mem::transmute(has_short_gi) };
            has_short_gi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_greenfield: u32 = unsafe { ::std::mem::transmute(has_greenfield) };
            has_greenfield as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fec: u32 = unsafe { ::std::mem::transmute(has_fec) };
            has_fec as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_stbc_streams: u32 = unsafe { ::std::mem::transmute(has_stbc_streams) };
            has_stbc_streams as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_ness: u32 = unsafe { ::std::mem::transmute(has_ness) };
            has_ness as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn greenfield(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_greenfield(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc_streams(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stbc_streams(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        short_gi: guint,
        greenfield: guint,
        fec: guint,
        stbc_streams: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let short_gi: u32 = unsafe { ::std::mem::transmute(short_gi) };
            short_gi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let greenfield: u32 = unsafe { ::std::mem::transmute(greenfield) };
            greenfield as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fec: u32 = unsafe { ::std::mem::transmute(fec) };
            fec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let stbc_streams: u32 = unsafe { ::std::mem::transmute(stbc_streams) };
            stbc_streams as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11ac {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u8; 2usize],
    pub bandwidth: guint8,
    pub mcs: [guint8; 4usize],
    pub nss: [guint8; 4usize],
    pub fec: guint8,
    pub group_id: guint8,
    pub partial_aid: guint16,
}
impl ieee_802_11ac {
    #[inline]
    pub fn has_stbc(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_stbc(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_txop_ps_not_allowed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_txop_ps_not_allowed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_short_gi_nsym_disambig(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_short_gi_nsym_disambig(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ldpc_extra_ofdm_symbol(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ldpc_extra_ofdm_symbol(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_beamformed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_beamformed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_bandwidth(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_bandwidth(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fec(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fec(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_group_id(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_group_id(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_partial_aid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_partial_aid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stbc(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stbc(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txop_ps_not_allowed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txop_ps_not_allowed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn short_gi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn short_gi_nsym_disambig(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_short_gi_nsym_disambig(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ldpc_extra_ofdm_symbol(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ldpc_extra_ofdm_symbol(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn beamformed(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_beamformed(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_stbc: guint,
        has_txop_ps_not_allowed: guint,
        has_short_gi: guint,
        has_short_gi_nsym_disambig: guint,
        has_ldpc_extra_ofdm_symbol: guint,
        has_beamformed: guint,
        has_bandwidth: guint,
        has_fec: guint,
        has_group_id: guint,
        has_partial_aid: guint,
        stbc: guint,
        txop_ps_not_allowed: guint,
        short_gi: guint,
        short_gi_nsym_disambig: guint,
        ldpc_extra_ofdm_symbol: guint,
        beamformed: guint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_stbc: u32 = unsafe { ::std::mem::transmute(has_stbc) };
            has_stbc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_txop_ps_not_allowed: u32 =
                unsafe { ::std::mem::transmute(has_txop_ps_not_allowed) };
            has_txop_ps_not_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_short_gi: u32 = unsafe { ::std::mem::transmute(has_short_gi) };
            has_short_gi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_short_gi_nsym_disambig: u32 =
                unsafe { ::std::mem::transmute(has_short_gi_nsym_disambig) };
            has_short_gi_nsym_disambig as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_ldpc_extra_ofdm_symbol: u32 =
                unsafe { ::std::mem::transmute(has_ldpc_extra_ofdm_symbol) };
            has_ldpc_extra_ofdm_symbol as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_beamformed: u32 = unsafe { ::std::mem::transmute(has_beamformed) };
            has_beamformed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_bandwidth: u32 = unsafe { ::std::mem::transmute(has_bandwidth) };
            has_bandwidth as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_fec: u32 = unsafe { ::std::mem::transmute(has_fec) };
            has_fec as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_group_id: u32 = unsafe { ::std::mem::transmute(has_group_id) };
            has_group_id as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_partial_aid: u32 = unsafe { ::std::mem::transmute(has_partial_aid) };
            has_partial_aid as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stbc: u32 = unsafe { ::std::mem::transmute(stbc) };
            stbc as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let txop_ps_not_allowed: u32 = unsafe { ::std::mem::transmute(txop_ps_not_allowed) };
            txop_ps_not_allowed as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let short_gi: u32 = unsafe { ::std::mem::transmute(short_gi) };
            short_gi as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let short_gi_nsym_disambig: u32 =
                unsafe { ::std::mem::transmute(short_gi_nsym_disambig) };
            short_gi_nsym_disambig as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ldpc_extra_ofdm_symbol: u32 =
                unsafe { ::std::mem::transmute(ldpc_extra_ofdm_symbol) };
            ldpc_extra_ofdm_symbol as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let beamformed: u32 = unsafe { ::std::mem::transmute(beamformed) };
            beamformed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ieee_802_11ad {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub mcs: guint8,
}
impl ieee_802_11ad {
    #[inline]
    pub fn has_mcs_index(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_mcs_index(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(has_mcs_index: guint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_mcs_index: u32 = unsafe { ::std::mem::transmute(has_mcs_index) };
            has_mcs_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ieee_802_11_phy_info {
    pub info_11_fhss: ieee_802_11_fhss,
    pub info_11b: ieee_802_11b,
    pub info_11a: ieee_802_11a,
    pub info_11g: ieee_802_11g,
    pub info_11n: ieee_802_11n,
    pub info_11ac: ieee_802_11ac,
    pub info_11ad: ieee_802_11ad,
    _bindgen_union_align: [u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee_802_11_phdr {
    pub fcs_len: gint,
    pub decrypted: gboolean,
    pub datapad: gboolean,
    pub phy: guint,
    pub phy_info: ieee_802_11_phy_info,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: u16,
    pub channel: guint16,
    pub frequency: guint32,
    pub data_rate: guint16,
    pub signal_percent: guint8,
    pub noise_percent: guint8,
    pub signal_dbm: gint8,
    pub noise_dbm: gint8,
    pub signal_db: guint8,
    pub noise_db: guint8,
    pub tsf_timestamp: guint64,
    pub aggregate_flags: guint32,
    pub aggregate_id: guint32,
    pub zero_length_psdu_type: guint8,
}
impl ieee_802_11_phdr {
    #[inline]
    pub fn has_channel(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_channel(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_frequency(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_frequency(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_data_rate(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_data_rate(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_percent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_percent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_percent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_percent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_dbm(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_dbm(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_dbm(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_dbm(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_signal_db(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_signal_db(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_noise_db(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_noise_db(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_tsf_timestamp(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_tsf_timestamp(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_aggregate_info(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_aggregate_info(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_zero_length_psdu_type(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_zero_length_psdu_type(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_channel: guint,
        has_frequency: guint,
        has_data_rate: guint,
        has_signal_percent: guint,
        has_noise_percent: guint,
        has_signal_dbm: guint,
        has_noise_dbm: guint,
        has_signal_db: guint,
        has_noise_db: guint,
        has_tsf_timestamp: guint,
        has_aggregate_info: guint,
        has_zero_length_psdu_type: guint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_channel: u32 = unsafe { ::std::mem::transmute(has_channel) };
            has_channel as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_frequency: u32 = unsafe { ::std::mem::transmute(has_frequency) };
            has_frequency as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_data_rate: u32 = unsafe { ::std::mem::transmute(has_data_rate) };
            has_data_rate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_signal_percent: u32 = unsafe { ::std::mem::transmute(has_signal_percent) };
            has_signal_percent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_noise_percent: u32 = unsafe { ::std::mem::transmute(has_noise_percent) };
            has_noise_percent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_signal_dbm: u32 = unsafe { ::std::mem::transmute(has_signal_dbm) };
            has_signal_dbm as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_noise_dbm: u32 = unsafe { ::std::mem::transmute(has_noise_dbm) };
            has_noise_dbm as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_signal_db: u32 = unsafe { ::std::mem::transmute(has_signal_db) };
            has_signal_db as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_noise_db: u32 = unsafe { ::std::mem::transmute(has_noise_db) };
            has_noise_db as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_tsf_timestamp: u32 = unsafe { ::std::mem::transmute(has_tsf_timestamp) };
            has_tsf_timestamp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let has_aggregate_info: u32 = unsafe { ::std::mem::transmute(has_aggregate_info) };
            has_aggregate_info as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let has_zero_length_psdu_type: u32 =
                unsafe { ::std::mem::transmute(has_zero_length_psdu_type) };
            has_zero_length_psdu_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cosine_phdr {
    pub encap: guint8,
    pub direction: guint8,
    pub if_name: [::std::os::raw::c_char; 128usize],
    pub pro: guint16,
    pub off: guint16,
    pub pri: guint16,
    pub rm: guint16,
    pub err: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irda_phdr {
    pub pkttype: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nettl_phdr {
    pub subsys: guint16,
    pub devid: guint32,
    pub kind: guint32,
    pub pid: gint32,
    pub uid: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtp2_phdr {
    pub sent: guint8,
    pub annex_a_used: guint8,
    pub link_number: guint16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k12_input_info_t {
    pub atm: k12_input_info_t__bindgen_ty_1,
    pub ds0mask: guint32,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k12_input_info_t__bindgen_ty_1 {
    pub vp: guint16,
    pub vc: guint16,
    pub cid: guint16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k12_phdr {
    pub input: guint32,
    pub input_name: *const gchar,
    pub stack_file: *const gchar,
    pub input_type: guint32,
    pub input_info: k12_input_info_t,
    pub extra_info: *mut guint8,
    pub extra_length: guint32,
    pub stuff: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lapd_phdr {
    pub pkttype: guint16,
    pub we_network: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct catapult_dct2000_phdr {
    pub inner_pseudo_header: catapult_dct2000_phdr__bindgen_ty_1,
    pub seek_off: gint64,
    pub wth: *mut wtap,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union catapult_dct2000_phdr__bindgen_ty_1 {
    pub isdn: isdn_phdr,
    pub atm: atm_phdr,
    pub p2p: p2p_phdr,
    _bindgen_union_align: [u32; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct erf_phdr {
    pub ts: guint64,
    pub type_: guint8,
    pub flags: guint8,
    pub rlen: guint16,
    pub lctr: guint16,
    pub wlen: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct erf_ehdr {
    pub ehdr: guint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_erf_eth_hdr {
    pub offset: guint8,
    pub pad: guint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct erf_mc_phdr {
    pub phdr: erf_phdr,
    pub ehdr_list: [erf_ehdr; 16usize],
    pub subhdr: erf_mc_phdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union erf_mc_phdr__bindgen_ty_1 {
    pub eth_hdr: wtap_erf_eth_hdr,
    pub mc_hdr: guint32,
    pub aal2_hdr: guint32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sita_phdr {
    pub sita_flags: guint8,
    pub sita_signals: guint8,
    pub sita_errors1: guint8,
    pub sita_errors2: guint8,
    pub sita_proto: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bthci_phdr {
    pub sent: gboolean,
    pub channel: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btmon_phdr {
    pub adapter_id: guint16,
    pub opcode: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l1event_phdr {
    pub uton: gboolean,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_phdr {
    pub is_event: guint8,
    pub bus: guint8,
    pub flags: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsm_um_phdr {
    pub uplink: gboolean,
    pub channel: guint8,
    pub bsic: guint8,
    pub arfcn: guint16,
    pub tdma_frame: guint32,
    pub error: guint8,
    pub timeshift: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstr_phdr {
    pub rec_offset: gint64,
    pub rec_len: gint32,
    pub nicno_offset: guint8,
    pub nicno_len: guint8,
    pub dir_offset: guint8,
    pub dir_len: guint8,
    pub eth_offset: guint16,
    pub pcb_offset: guint8,
    pub l_pcb_offset: guint8,
    pub rec_type: guint8,
    pub vlantag_offset: guint8,
    pub coreid_offset: guint8,
    pub srcnodeid_offset: guint8,
    pub destnodeid_offset: guint8,
    pub clflags_offset: guint8,
    pub src_vmname_len_offset: guint8,
    pub dst_vmname_len_offset: guint8,
    pub ns_activity_offset: guint8,
    pub data_offset: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nokia_phdr {
    pub eth: eth_phdr,
    pub stuff: [guint8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llcp_phdr {
    pub adapter: guint8,
    pub flags: guint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logcat_phdr {
    pub version: gint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netmon_phdr {
    pub title: *mut guint8,
    pub descLength: guint32,
    pub description: *mut guint8,
    pub sub_encap: guint,
    pub subheader: netmon_phdr_sub_wtap_pseudo_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netmon_phdr_sub_wtap_pseudo_header {
    pub eth: eth_phdr,
    pub atm: atm_phdr,
    pub ieee_802_11: ieee_802_11_phdr,
    _bindgen_union_align: [u64; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_pseudo_header {
    pub eth: eth_phdr,
    pub dte_dce: dte_dce_phdr,
    pub isdn: isdn_phdr,
    pub atm: atm_phdr,
    pub ascend: ascend_phdr,
    pub p2p: p2p_phdr,
    pub ieee_802_11: ieee_802_11_phdr,
    pub cosine: cosine_phdr,
    pub irda: irda_phdr,
    pub nettl: nettl_phdr,
    pub mtp2: mtp2_phdr,
    pub k12: k12_phdr,
    pub lapd: lapd_phdr,
    pub dct2000: catapult_dct2000_phdr,
    pub erf: erf_mc_phdr,
    pub sita: sita_phdr,
    pub bthci: bthci_phdr,
    pub btmon: btmon_phdr,
    pub l1event: l1event_phdr,
    pub i2c: i2c_phdr,
    pub gsm_um: gsm_um_phdr,
    pub nstr: nstr_phdr,
    pub nokia: nokia_phdr,
    pub llcp: llcp_phdr,
    pub logcat: logcat_phdr,
    pub netmon: netmon_phdr,
    _bindgen_union_align: [u64; 19usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_packet_header {
    pub caplen: guint32,
    pub len: guint32,
    pub pkt_encap: ::std::os::raw::c_int,
    pub interface_id: guint32,
    pub drop_count: guint64,
    pub pack_flags: guint32,
    pub pseudo_header: wtap_pseudo_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_ft_specific_header {
    pub record_type: guint,
    pub record_len: guint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_syscall_header {
    pub record_type: guint,
    pub byte_order: ::std::os::raw::c_int,
    pub timestamp: guint64,
    pub thread_id: guint64,
    pub event_len: guint32,
    pub event_filelen: guint32,
    pub event_type: guint16,
    pub cpu_id: guint16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wtap_rec {
    pub rec_type: guint,
    pub presence_flags: guint32,
    pub ts: nstime_t,
    pub tsprec: ::std::os::raw::c_int,
    pub rec_header: wtap_rec__bindgen_ty_1,
    pub opt_comment: *mut gchar,
    pub has_comment_changed: gboolean,
    pub options_buf: Buffer,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wtap_rec__bindgen_ty_1 {
    pub packet_header: wtap_packet_header,
    pub ft_specific_header: wtap_ft_specific_header,
    pub syscall_header: wtap_syscall_header,
    _bindgen_union_align: [u64; 23usize],
}
#[doc = " Holds the required data from pcapng:s Section Header block(SHB)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_section_mandatory_s {
    #[doc = "< 64-bit value specifying the length in bytes of the"]
    #[doc = "     following section."]
    #[doc = "     Section Length equal -1 (0xFFFFFFFFFFFFFFFF) means"]
    #[doc = "     that the size of the section is not specified"]
    #[doc = "   Note: if writing to a new file, this length will"]
    #[doc = "     be invalid if anything changes, such as the other"]
    #[doc = "     members of this struct, or the packets written."]
    pub section_length: guint64,
}
#[doc = " Holds the required data from pcapng:s Section Header block(SHB)."]
pub type wtapng_mandatory_section_t = wtapng_section_mandatory_s;
#[doc = " struct holding the information to build IDB:s"]
#[doc = "  the interface_data array holds an array of wtap_block_t"]
#[doc = "  represending IDB of one per interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_iface_descriptions_s {
    pub interface_data: *mut GArray,
}
#[doc = " struct holding the information to build IDB:s"]
#[doc = "  the interface_data array holds an array of wtap_block_t"]
#[doc = "  represending IDB of one per interface."]
pub type wtapng_iface_descriptions_t = wtapng_iface_descriptions_s;
#[doc = " Interface description data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_if_descr_mandatory_s {
    #[doc = "< link_type translated to wtap_encap"]
    pub wtap_encap: ::std::os::raw::c_int,
    pub time_units_per_second: guint64,
    #[doc = "< WTAP_TSPREC_ value for this interface"]
    pub tsprecision: ::std::os::raw::c_int,
    pub snap_len: guint32,
    pub num_stat_entries: guint8,
    #[doc = "< An array holding the interface statistics from"]
    #[doc = "     pcapng ISB:s or equivalent(?)"]
    pub interface_statistics: *mut GArray,
}
#[doc = " Interface description data"]
pub type wtapng_if_descr_mandatory_t = wtapng_if_descr_mandatory_s;
#[doc = " Decryption Secrets Block data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_dsb_mandatory_s {
    pub secrets_type: guint32,
    #[doc = " Type of secrets stored in data (see secrets-types.h)"]
    pub secrets_len: guint32,
    #[doc = " Length of the secrets data in bytes"]
    pub secrets_data: *mut guint8,
}
#[doc = " Decryption Secrets Block data."]
pub type wtapng_dsb_mandatory_t = wtapng_dsb_mandatory_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_if_descr_filter_s {
    #[doc = "< NULL if not available"]
    #[doc = "  libpcap string."]
    pub if_filter_str: *mut gchar,
    pub bpf_filter_len: guint16,
    #[doc = " variant II BPF filter len 0 if not used"]
    pub if_filter_bpf_bytes: *mut guint8,
}
pub type wtapng_if_descr_filter_t = wtapng_if_descr_filter_s;
#[doc = " Holds the required data for pcapng Interface Statistics Block (ISB)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtapng_if_stats_mandatory_s {
    pub interface_id: guint32,
    pub ts_high: guint32,
    pub ts_low: guint32,
}
#[doc = " Holds the required data for pcapng Interface Statistics Block (ISB)."]
pub type wtapng_if_stats_mandatory_t = wtapng_if_stats_mandatory_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hashipv4 {
    pub addr: guint,
    pub flags: guint8,
    pub ip: [gchar; 16usize],
    pub name: [gchar; 64usize],
}
pub type hashipv4_t = hashipv4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hashipv6 {
    pub addr: [guint8; 16usize],
    pub flags: guint8,
    pub ip6: [gchar; 46usize],
    pub name: [gchar; 64usize],
}
pub type hashipv6_t = hashipv6;
#[doc = " A struct with lists of resolved addresses."]
#[doc = "  Used when writing name resoultion blocks (NRB)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo_lists {
    #[doc = "< A list of resolved hashipv4_t"]
    pub ipv4_addr_list: *mut GList,
    #[doc = "< A list of resolved hashipv6_t"]
    pub ipv6_addr_list: *mut GList,
}
#[doc = " A struct with lists of resolved addresses."]
#[doc = "  Used when writing name resoultion blocks (NRB)"]
pub type addrinfo_lists_t = addrinfo_lists;
#[doc = " Parameters for various wtap_dump_* functions, specifying per-file"]
#[doc = " information. The structure itself is no longer used after returning"]
#[doc = " from wtap_dump_*, but its pointer fields must remain valid until"]
#[doc = " wtap_dump_close is called."]
#[doc = ""]
#[doc = " @note The shb_hdr, idb_inf, and nrb_hdr arguments will be used until"]
#[doc = "     wtap_dump_close() is called, but will not be free'd by the dumper. If"]
#[doc = "     you created them, you must free them yourself after wtap_dump_close()."]
#[doc = "     dsbs_initial will be freed by wtap_dump_close(),"]
#[doc = "     dsbs_growing typically refers to another wth->dsbs."]
#[doc = ""]
#[doc = " @see wtap_dump_params_init, wtap_dump_params_cleanup."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_dump_params {
    #[doc = "< Per-file packet encapsulation, or WTAP_ENCAP_PER_PACKET"]
    pub encap: ::std::os::raw::c_int,
    #[doc = "< Per-file snapshot length (what if it's per-interface?)"]
    pub snaplen: ::std::os::raw::c_int,
    #[doc = "< The section header block(s) information, or NULL."]
    pub shb_hdrs: *mut GArray,
    #[doc = "< The interface description information, or NULL."]
    pub idb_inf: *mut wtapng_iface_descriptions_t,
    #[doc = "< The name resolution blocks(s) comment/custom_opts information, or NULL."]
    pub nrb_hdrs: *mut GArray,
    #[doc = "< The initial Decryption Secrets Block(s) to be written, or NULL."]
    pub dsbs_initial: *mut GArray,
    #[doc = "< DSBs that will be written while writing packets, or NULL."]
    #[doc = "This array may grow since the dumper was opened and will subsequently"]
    #[doc = "be written before newer packets are written in wtap_dump."]
    pub dsbs_growing: *const GArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_reader {
    _unused: [u8; 0],
}
pub type FILE_T = *mut wtap_reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_wslua_file_info {
    pub wslua_can_write_encap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub wslua_data: *mut ::std::os::raw::c_void,
}
pub type wtap_wslua_file_info_t = wtap_wslua_file_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_extension_info {
    pub name: *const ::std::os::raw::c_char,
    pub is_capture_file: gboolean,
    pub extensions: *const ::std::os::raw::c_char,
}
pub const wtap_open_return_val_WTAP_OPEN_NOT_MINE: wtap_open_return_val = 0;
pub const wtap_open_return_val_WTAP_OPEN_MINE: wtap_open_return_val = 1;
pub const wtap_open_return_val_WTAP_OPEN_ERROR: wtap_open_return_val = -1;
pub type wtap_open_return_val = i32;
pub type wtap_open_routine_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wtap,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> wtap_open_return_val,
>;
pub const wtap_open_type_OPEN_INFO_MAGIC: wtap_open_type = 0;
pub const wtap_open_type_OPEN_INFO_HEURISTIC: wtap_open_type = 1;
pub type wtap_open_type = i32;
extern "C" {
    pub fn init_open_routines();
}
extern "C" {
    pub fn cleanup_open_routines();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open_info {
    pub name: *const ::std::os::raw::c_char,
    pub type_: wtap_open_type,
    pub open_routine: wtap_open_routine_t,
    pub extensions: *const ::std::os::raw::c_char,
    pub extensions_set: *mut *mut gchar,
    pub wslua_data: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub static mut open_routines: *mut open_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_type_subtype_info {
    pub name: *const ::std::os::raw::c_char,
    pub short_name: *const ::std::os::raw::c_char,
    pub default_file_extension: *const ::std::os::raw::c_char,
    pub additional_file_extensions: *const ::std::os::raw::c_char,
    pub writing_must_seek: gboolean,
    pub has_name_resolution: gboolean,
    pub supported_comment_types: guint32,
    pub can_write_encap: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub dump_open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wtap_dumper,
            arg2: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub wslua_info: *mut wtap_wslua_file_info_t,
}
extern "C" {
    #[doc = " @brief Initialize the Wiretap library."]
    #[doc = ""]
    #[doc = " @param load_wiretap_plugins Load Wiretap plugins when initializing library."]
    pub fn wtap_init(load_wiretap_plugins: gboolean);
}
extern "C" {
    #[doc = " On failure, \"wtap_open_offline()\" returns NULL, and puts into the"]
    #[doc = " \"int\" pointed to by its second argument:"]
    #[doc = ""]
    #[doc = " @param filename Name of the file to open"]
    #[doc = " @param type WTAP_TYPE_AUTO for automatic recognize file format or explicit choose format type"]
    #[doc = " @param err a positive \"errno\" value if the capture file can't be opened;"]
    #[doc = " a negative number, indicating the type of error, on other failures."]
    #[doc = " @param err_info for some errors, a string giving more details of"]
    #[doc = " the error"]
    #[doc = " @param do_random TRUE if random access to the file will be done,"]
    #[doc = " FALSE if not"]
    pub fn wtap_open_offline(
        filename: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_uint,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
        do_random: gboolean,
    ) -> *mut wtap;
}
extern "C" {
    #[doc = " If we were compiled with zlib and we're at EOF, unset EOF so that"]
    #[doc = " wtap_read/gzread has a chance to succeed. This is necessary if"]
    #[doc = " we're tailing a file."]
    pub fn wtap_cleareof(wth: *mut wtap);
}
#[doc = " Set callback functions to add new hostnames. Currently pcapng-only."]
#[doc = " MUST match add_ipv4_name and add_ipv6_name in addr_resolv.c."]
pub type wtap_new_ipv4_callback_t =
    ::std::option::Option<unsafe extern "C" fn(addr: guint, name: *const gchar)>;
extern "C" {
    pub fn wtap_set_cb_new_ipv4(wth: *mut wtap, add_new_ipv4: wtap_new_ipv4_callback_t);
}
pub type wtap_new_ipv6_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addrp: *const ::std::os::raw::c_void, name: *const gchar),
>;
extern "C" {
    pub fn wtap_set_cb_new_ipv6(wth: *mut wtap, add_new_ipv6: wtap_new_ipv6_callback_t);
}
#[doc = " Set callback function to receive new decryption secrets for a particular"]
#[doc = " secrets type (as defined in secrets-types.h). Currently pcapng-only."]
pub type wtap_new_secrets_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        secrets_type: guint32,
        secrets: *const ::std::os::raw::c_void,
        size: guint,
    ),
>;
extern "C" {
    pub fn wtap_set_cb_new_secrets(wth: *mut wtap, add_new_secrets: wtap_new_secrets_callback_t);
}
extern "C" {
    #[doc = " Read the next record in the file, filling in *phdr and *buf."]
    #[doc = ""]
    #[doc = " @wth a wtap * returned by a call that opened a file for reading."]
    #[doc = " @rec a pointer to a wtap_rec, filled in with information about the"]
    #[doc = " record."]
    #[doc = " @buf a pointer to a Buffer, filled in with data from the record."]
    #[doc = " @param err a positive \"errno\" value, or a negative number indicating"]
    #[doc = " the type of error, if the read failed."]
    #[doc = " @param err_info for some errors, a string giving more details of"]
    #[doc = " the error"]
    #[doc = " @param offset a pointer to a gint64, set to the offset in the file"]
    #[doc = " that should be used on calls to wtap_seek_read() to reread that record,"]
    #[doc = " if the read succeeded."]
    #[doc = " @return TRUE on success, FALSE on failure."]
    pub fn wtap_read(
        wth: *mut wtap,
        rec: *mut wtap_rec,
        buf: *mut Buffer,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
        offset: *mut gint64,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Read the record at a specified offset in a capture file, filling in"]
    #[doc = " *phdr and *buf."]
    #[doc = ""]
    #[doc = " @wth a wtap * returned by a call that opened a file for random-access"]
    #[doc = " reading."]
    #[doc = " @seek_off a gint64 giving an offset value returned by a previous"]
    #[doc = " wtap_read() call."]
    #[doc = " @phdr a pointer to a struct wtap_pkthdr, filled in with information"]
    #[doc = " about the record."]
    #[doc = " @buf a pointer to a Buffer, filled in with data from the record."]
    #[doc = " @param err a positive \"errno\" value, or a negative number indicating"]
    #[doc = " the type of error, if the read failed."]
    #[doc = " @param err_info for some errors, a string giving more details of"]
    #[doc = " the error"]
    #[doc = " @return TRUE on success, FALSE on failure."]
    pub fn wtap_seek_read(
        wth: *mut wtap,
        seek_off: gint64,
        rec: *mut wtap_rec,
        buf: *mut Buffer,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " initialize a wtap_rec structure"]
    pub fn wtap_rec_init(rec: *mut wtap_rec);
}
extern "C" {
    #[doc = " clean up a wtap_rec structure, freeing what wtap_rec_init() allocated"]
    pub fn wtap_rec_cleanup(rec: *mut wtap_rec);
}
pub const wtap_compression_type_WTAP_UNCOMPRESSED: wtap_compression_type = 0;
pub const wtap_compression_type_WTAP_GZIP_COMPRESSED: wtap_compression_type = 1;
pub type wtap_compression_type = i32;
extern "C" {
    pub fn wtap_get_compression_type(wth: *mut wtap) -> wtap_compression_type;
}
extern "C" {
    pub fn wtap_compression_type_description(
        compression_type: wtap_compression_type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_compression_type_extension(
        compression_type: wtap_compression_type,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_all_compression_type_extensions_list() -> *mut GSList;
}
extern "C" {
    #[doc = " Return an approximation of the amount of data we've read sequentially"]
    #[doc = " from the file so far."]
    pub fn wtap_read_so_far(wth: *mut wtap) -> gint64;
}
extern "C" {
    pub fn wtap_file_size(wth: *mut wtap, err: *mut ::std::os::raw::c_int) -> gint64;
}
extern "C" {
    pub fn wtap_snapshot_length(wth: *mut wtap) -> guint;
}
extern "C" {
    pub fn wtap_file_type_subtype(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_file_encap(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_file_tsprec(wth: *mut wtap) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Gets existing section header block, not for new file."]
    #[doc = " @details Returns the pointer to the existing SHB, without creating a"]
    #[doc = "          new one. This should only be used for accessing info, not"]
    #[doc = "          for creating a new file based on existing SHB info. Use"]
    #[doc = "          wtap_file_get_shb_for_new_file() for that."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @return The existing section header, which must NOT be g_free'd."]
    #[doc = ""]
    #[doc = " XXX - need to be updated to handle multiple SHBs."]
    pub fn wtap_file_get_shb(wth: *mut wtap) -> wtap_block_t;
}
extern "C" {
    #[doc = " @brief Gets new section header block for new file, based on existing info."]
    #[doc = " @details Creates a new wtap_block_t section header block and only"]
    #[doc = "          copies appropriate members of the SHB for a new file. In"]
    #[doc = "          particular, the comment string is copied, and any custom options"]
    #[doc = "          which should be copied are copied. The os, hardware, and"]
    #[doc = "          application strings are *not* copied."]
    #[doc = ""]
    #[doc = " @note Use wtap_free_shb() to free the returned section header."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @return The new section header, which must be wtap_free_shb'd."]
    pub fn wtap_file_get_shb_for_new_file(wth: *mut wtap) -> *mut GArray;
}
extern "C" {
    #[doc = " @brief Sets or replaces the section header comment."]
    #[doc = " @details The passed-in comment string is set to be the comment"]
    #[doc = "          for the section header block. The passed-in string's"]
    #[doc = "          ownership will be owned by the block, so it should be"]
    #[doc = "          duplicated before passing into this function."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @param comment The comment string."]
    pub fn wtap_write_shb_comment(wth: *mut wtap, comment: *mut gchar);
}
extern "C" {
    #[doc = " @brief Gets existing interface descriptions."]
    #[doc = " @details Returns a new struct containing a pointer to the existing"]
    #[doc = "          description, without creating new descriptions internally."]
    #[doc = " @note The returned pointer must be g_free'd, but its internal"]
    #[doc = "       interface_data must not."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @return A new struct of the existing section descriptions, which must be g_free'd."]
    pub fn wtap_file_get_idb_info(wth: *mut wtap) -> *mut wtapng_iface_descriptions_t;
}
extern "C" {
    #[doc = " @brief Free's a interface description block and all of its members."]
    #[doc = ""]
    #[doc = " @details This free's all of the interface descriptions inside the passed-in"]
    #[doc = "     struct, including their members (e.g., comments); and then free's the"]
    #[doc = "     passed-in struct as well."]
    #[doc = ""]
    #[doc = " @warning Do not use this for the struct returned by"]
    #[doc = "     wtap_file_get_idb_info(), as that one did not create the internal"]
    #[doc = "     interface descriptions; for that case you can simply g_free() the new"]
    #[doc = "     struct."]
    pub fn wtap_free_idb_info(idb_info: *mut wtapng_iface_descriptions_t);
}
extern "C" {
    #[doc = " @brief Gets a debug string of an interface description."]
    #[doc = " @details Returns a newly allocated string of debug information about"]
    #[doc = "          the given interface descrption, useful for debugging."]
    #[doc = " @note The returned pointer must be g_free'd."]
    #[doc = ""]
    #[doc = " @param if_descr The interface description."]
    #[doc = " @param indent Number of spaces to indent each line by."]
    #[doc = " @param line_end A string to append to each line (e.g., \"\\n\" or \", \")."]
    #[doc = " @return A newly allocated gcahr array string, which must be g_free'd."]
    pub fn wtap_get_debug_if_descr(
        if_descr: wtap_block_t,
        indent: ::std::os::raw::c_int,
        line_end: *const ::std::os::raw::c_char,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " @brief Gets existing name resolution block, not for new file."]
    #[doc = " @details Returns the pointer to the existing NRB, without creating a"]
    #[doc = "          new one. This should only be used for accessing info, not"]
    #[doc = "          for creating a new file based on existing NRB info. Use"]
    #[doc = "          wtap_file_get_nrb_for_new_file() for that."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @return The existing section header, which must NOT be g_free'd."]
    #[doc = ""]
    #[doc = " XXX - need to be updated to handle multiple NRBs."]
    pub fn wtap_file_get_nrb(wth: *mut wtap) -> wtap_block_t;
}
extern "C" {
    #[doc = " @brief Gets new name resolution info for new file, based on existing info."]
    #[doc = " @details Creates a new wtap_block_t of name resolution info and only"]
    #[doc = "          copies appropriate members for a new file."]
    #[doc = ""]
    #[doc = " @note Use wtap_free_nrb() to free the returned pointer."]
    #[doc = ""]
    #[doc = " @param wth The wiretap session."]
    #[doc = " @return The new name resolution info, which must be freed."]
    pub fn wtap_file_get_nrb_for_new_file(wth: *mut wtap) -> *mut GArray;
}
extern "C" {
    #[doc = " close the file descriptors for the current file"]
    pub fn wtap_fdclose(wth: *mut wtap);
}
extern "C" {
    #[doc = " reopen the random file descriptor for the current file"]
    pub fn wtap_fdreopen(
        wth: *mut wtap,
        filename: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Close only the sequential side, freeing up memory it uses."]
    pub fn wtap_sequential_close(wth: *mut wtap);
}
extern "C" {
    #[doc = " Closes any open file handles and frees the memory associated with wth."]
    pub fn wtap_close(wth: *mut wtap);
}
extern "C" {
    #[doc = " dump packets into a capture file"]
    pub fn wtap_dump_can_open(filetype: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Given a GArray of WTAP_ENCAP_ types, return the per-file encapsulation"]
    #[doc = " type that would be needed to write out a file with those types."]
    pub fn wtap_dump_file_encap_type(file_encaps: *const GArray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return TRUE if we can write this capture file format out in"]
    #[doc = " compressed form, FALSE if not."]
    pub fn wtap_dump_can_compress(filetype: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Return TRUE if this capture file format supports storing name"]
    #[doc = " resolution information in it, FALSE if not."]
    pub fn wtap_dump_has_name_resolution(filetype: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Return TRUE if this capture file format supports all the comment"]
    #[doc = " types specified, FALSE if not."]
    pub fn wtap_dump_supports_comment_types(
        filetype: ::std::os::raw::c_int,
        comment_types: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Initialize the per-file information based on an existing file. Its"]
    #[doc = " contents must be freed according to the requirements of wtap_dump_params."]
    #[doc = " If wth does not remain valid for the duration of the session, dsbs_growing"]
    #[doc = " MUST be cleared after this function."]
    #[doc = ""]
    #[doc = " @param params The parameters for wtap_dump_* to initialize."]
    #[doc = " @param wth The wiretap session."]
    pub fn wtap_dump_params_init(params: *mut wtap_dump_params, wth: *mut wtap);
}
extern "C" {
    #[doc = " Remove any decryption secret information from the per-file information;"]
    #[doc = " used if we're stripping decryption secrets as we write the file."]
    #[doc = ""]
    #[doc = " @param params The parameters for wtap_dump_* from which to remove the"]
    #[doc = " decryption secrets.."]
    pub fn wtap_dump_params_discard_decryption_secrets(params: *mut wtap_dump_params);
}
extern "C" {
    #[doc = " Free memory associated with the wtap_dump_params when it is no longer in"]
    #[doc = " use by wtap_dumper."]
    #[doc = ""]
    #[doc = " @param params The parameters as initialized by wtap_dump_params_init."]
    pub fn wtap_dump_params_cleanup(params: *mut wtap_dump_params);
}
extern "C" {
    #[doc = " @brief Opens a new capture file for writing."]
    #[doc = ""]
    #[doc = " @param filename The new file's name."]
    #[doc = " @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type."]
    #[doc = " @param compression_type Type of compression to use when writing, if any"]
    #[doc = " @param params The per-file information for this file."]
    #[doc = " @param[out] err Will be set to an error code on failure."]
    #[doc = " @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open(
        filename: *const ::std::os::raw::c_char,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for a temporary file."]
    #[doc = ""]
    #[doc = " @param filenamep Points to a pointer that's set to point to the"]
    #[doc = "        pathname of the temporary file; it's allocated with g_malloc()"]
    #[doc = " @param pfx A string to be used as the prefix for the temporary file name"]
    #[doc = " @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type."]
    #[doc = " @param compression_type Type of compression to use when writing, if any"]
    #[doc = " @param params The per-file information for this file."]
    #[doc = " @param[out] err Will be set to an error code on failure."]
    #[doc = " @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open_tempfile(
        filenamep: *mut *mut ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for an existing file descriptor."]
    #[doc = ""]
    #[doc = " @param fd The file descriptor for which the dumper should be created."]
    #[doc = " @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type."]
    #[doc = " @param compression_type Type of compression to use when writing, if any"]
    #[doc = " @param params The per-file information for this file."]
    #[doc = " @param[out] err Will be set to an error code on failure."]
    #[doc = " @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_fdopen(
        fd: ::std::os::raw::c_int,
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut wtap_dumper;
}
extern "C" {
    #[doc = " @brief Creates a dumper for the standard output."]
    #[doc = ""]
    #[doc = " @param file_type_subtype The WTAP_FILE_TYPE_SUBTYPE_XXX file type."]
    #[doc = " @param compression_type Type of compression to use when writing, if any"]
    #[doc = " @param params The per-file information for this file."]
    #[doc = " @param[out] err Will be set to an error code on failure."]
    #[doc = " @return The newly created dumper object, or NULL on failure."]
    pub fn wtap_dump_open_stdout(
        file_type_subtype: ::std::os::raw::c_int,
        compression_type: wtap_compression_type,
        params: *const wtap_dump_params,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut wtap_dumper;
}
extern "C" {
    pub fn wtap_dump(
        arg1: *mut wtap_dumper,
        arg2: *const wtap_rec,
        arg3: *const guint8,
        err: *mut ::std::os::raw::c_int,
        err_info: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_flush(arg1: *mut wtap_dumper);
}
extern "C" {
    pub fn wtap_get_bytes_dumped(arg1: *mut wtap_dumper) -> gint64;
}
extern "C" {
    pub fn wtap_set_bytes_dumped(wdh: *mut wtap_dumper, bytes_dumped: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wtap_addrinfo_list_empty(addrinfo_lists: *mut addrinfo_lists_t) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_set_addrinfo_list(
        wdh: *mut wtap_dumper,
        addrinfo_lists: *mut addrinfo_lists_t,
    ) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_get_needs_reload(wdh: *mut wtap_dumper) -> gboolean;
}
extern "C" {
    pub fn wtap_dump_discard_decryption_secrets(wdh: *mut wtap_dumper);
}
extern "C" {
    #[doc = " Closes open file handles and frees memory associated with wdh. Note that"]
    #[doc = " shb_hdr, idb_inf and nrb_hdr are not freed by this routine."]
    pub fn wtap_dump_close(wdh: *mut wtap_dumper, err: *mut ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Return TRUE if we can write a file out with the given GArray of file"]
    #[doc = " encapsulations and the given bitmask of comment types."]
    pub fn wtap_dump_can_write(
        file_encaps: *const GArray,
        required_comment_types: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Get a GArray of WTAP_FILE_TYPE_SUBTYPE_ values for file types/subtypes"]
    #[doc = " that can be used to save a file of a given type with a given GArray of"]
    #[doc = " WTAP_ENCAP_ types and the given bitmask of comment types."]
    pub fn wtap_get_savable_file_types_subtypes(
        file_type: ::std::os::raw::c_int,
        file_encaps: *const GArray,
        required_comment_types: guint32,
    ) -> *mut GArray;
}
extern "C" {
    #[doc = " various string converter functions"]
    pub fn wtap_file_type_subtype_string(
        file_type_subtype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_file_type_subtype_short_string(
        file_type_subtype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_short_string_to_file_type_subtype(
        short_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " various file extension functions"]
    pub fn wtap_get_all_capture_file_extensions_list() -> *mut GSList;
}
extern "C" {
    pub fn wtap_default_file_extension(
        filetype: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_file_extensions_list(
        filetype: ::std::os::raw::c_int,
        include_compressed: gboolean,
    ) -> *mut GSList;
}
extern "C" {
    pub fn wtap_get_all_file_extensions_list() -> *mut GSList;
}
extern "C" {
    pub fn wtap_free_extensions_list(extensions: *mut GSList);
}
extern "C" {
    pub fn wtap_encap_name(encap: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_encap_description(encap: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_name_to_encap(short_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_tsprec_string(tsprec: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get available number of file types and encapsulations"]
    pub fn wtap_get_num_file_type_extensions() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_get_num_encap_types() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_get_num_file_types_subtypes() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get information for file type extension"]
    pub fn wtap_get_file_extension_type_name(
        extension_type: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wtap_get_file_extension_type_extensions(extension_type: guint) -> *mut GSList;
}
extern "C" {
    #[doc = " dynamically register new file types and encapsulations"]
    pub fn wtap_register_file_type_extension(ei: *const file_extension_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_plugin {
    pub register_wtap_module: ::std::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub fn wtap_register_plugin(plug: *const wtap_plugin);
}
extern "C" {
    pub fn wtap_register_open_info(oi: *mut open_info, first_routine: gboolean);
}
extern "C" {
    pub fn wtap_has_open_info(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn wtap_deregister_open_info(name: *const gchar);
}
extern "C" {
    pub fn open_info_name_to_type(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn wtap_register_file_type_subtypes(
        fi: *const file_type_subtype_info,
        subtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wtap_deregister_file_type_subtype(file_type_subtype: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wtap_register_encap_type(
        description: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup the interal library structures"]
    pub fn wtap_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
pub const packet_char_enc_PACKET_CHAR_ENC_CHAR_ASCII: packet_char_enc = 0;
pub const packet_char_enc_PACKET_CHAR_ENC_CHAR_EBCDIC: packet_char_enc = 1;
#[doc = " @todo XXX - some of this stuff is used only while a packet is being dissected;"]
#[doc = "should we keep that stuff in the \"packet_info\" structure, instead, to"]
#[doc = "save memory?"]
pub type packet_char_enc = i32;
#[doc = " The frame number is the ordinal number of the frame in the capture, so"]
#[doc = "it's 1-origin.  In various contexts, 0 as a frame number means \"frame"]
#[doc = "number unknown\"."]
#[doc = ""]
#[doc = "There is one of these structures for every frame in the capture."]
#[doc = "That means a lot of memory if we have a lot of frames."]
#[doc = "They are packed into power-of-2 chunks, so their size is effectively"]
#[doc = "rounded up to a power of 2."]
#[doc = "Try to keep it close to, and less than or equal to, a power of 2."]
#[doc = "\"Smaller than a power of 2\" is OK for ILP32 platforms."]
#[doc = ""]
#[doc = "XXX - shuffle the fields to try to keep the most commonly-accessed"]
#[doc = "fields within the first 16 or 32 bytes, so they all fit in a cache"]
#[doc = "line?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _color_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _frame_data {
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet length"]
    pub pkt_len: guint32,
    #[doc = "< Amount actually captured"]
    pub cap_len: guint32,
    #[doc = "< Cumulative bytes into the capture"]
    pub cum_bytes: guint32,
    #[doc = "< File offset"]
    pub file_off: gint64,
    #[doc = "< Per frame proto data"]
    pub pfd: *mut GSList,
    #[doc = "< Per-packet matching color_filter_t object"]
    pub color_filter: *const _color_filter,
    #[doc = "< subframe number, for protocols that require this"]
    pub subnum: guint16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    #[doc = "< Absolute timestamp"]
    pub abs_ts: nstime_t,
    #[doc = "< How much the abs_tm of the frame is shifted"]
    pub shift_offset: nstime_t,
    #[doc = "< Previous reference frame (0 if this is one)"]
    pub frame_ref_num: guint32,
    #[doc = "< Previous displayed frame (0 if first one)"]
    pub prev_dis_num: guint32,
}
impl _frame_data {
    #[inline]
    pub fn passed_dfilter(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_passed_dfilter(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dependent_of_displayed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dependent_of_displayed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encoding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encoding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn visited(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_visited(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn marked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_marked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_time(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_time(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignored(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignored(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_ts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_ts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_phdr_comment(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_phdr_comment(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_user_comment(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_user_comment(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_colorize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_colorize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tsprec(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tsprec(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        passed_dfilter: ::std::os::raw::c_uint,
        dependent_of_displayed: ::std::os::raw::c_uint,
        encoding: ::std::os::raw::c_uint,
        visited: ::std::os::raw::c_uint,
        marked: ::std::os::raw::c_uint,
        ref_time: ::std::os::raw::c_uint,
        ignored: ::std::os::raw::c_uint,
        has_ts: ::std::os::raw::c_uint,
        has_phdr_comment: ::std::os::raw::c_uint,
        has_user_comment: ::std::os::raw::c_uint,
        need_colorize: ::std::os::raw::c_uint,
        tsprec: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let passed_dfilter: u32 = unsafe { ::std::mem::transmute(passed_dfilter) };
            passed_dfilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dependent_of_displayed: u32 =
                unsafe { ::std::mem::transmute(dependent_of_displayed) };
            dependent_of_displayed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encoding: u32 = unsafe { ::std::mem::transmute(encoding) };
            encoding as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let visited: u32 = unsafe { ::std::mem::transmute(visited) };
            visited as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let marked: u32 = unsafe { ::std::mem::transmute(marked) };
            marked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ref_time: u32 = unsafe { ::std::mem::transmute(ref_time) };
            ref_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ignored: u32 = unsafe { ::std::mem::transmute(ignored) };
            ignored as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_ts: u32 = unsafe { ::std::mem::transmute(has_ts) };
            has_ts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let has_phdr_comment: u32 = unsafe { ::std::mem::transmute(has_phdr_comment) };
            has_phdr_comment as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_user_comment: u32 = unsafe { ::std::mem::transmute(has_user_comment) };
            has_user_comment as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let need_colorize: u32 = unsafe { ::std::mem::transmute(need_colorize) };
            need_colorize as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let tsprec: u32 = unsafe { ::std::mem::transmute(tsprec) };
            tsprec as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type frame_data = _frame_data;
extern "C" {
    #[doc = " compare two frame_datas"]
    pub fn frame_data_compare(
        epan: *const epan_session,
        fdata1: *const frame_data,
        fdata2: *const frame_data,
        field: ::std::os::raw::c_int,
    ) -> gint;
}
extern "C" {
    pub fn frame_data_reset(fdata: *mut frame_data);
}
extern "C" {
    pub fn frame_data_destroy(fdata: *mut frame_data);
}
extern "C" {
    pub fn frame_data_init(
        fdata: *mut frame_data,
        num: guint32,
        rec: *const wtap_rec,
        offset: gint64,
        cum_bytes: guint32,
    );
}
extern "C" {
    pub fn frame_delta_abs_time(
        epan: *const epan_session,
        fdata: *const frame_data,
        prev_num: guint32,
        delta: *mut nstime_t,
    );
}
extern "C" {
    #[doc = " Sets the frame data struct values before dissection."]
    pub fn frame_data_set_before_dissect(
        fdata: *mut frame_data,
        elapsed_time: *mut nstime_t,
        frame_ref: *mut *const frame_data,
        prev_dis: *const frame_data,
    );
}
extern "C" {
    pub fn frame_data_set_after_dissect(fdata: *mut frame_data, cum_bytes: *mut guint32);
}
pub const address_type_AT_NONE: address_type = 0;
pub const address_type_AT_ETHER: address_type = 1;
pub const address_type_AT_IPv4: address_type = 2;
pub const address_type_AT_IPv6: address_type = 3;
pub const address_type_AT_IPX: address_type = 4;
pub const address_type_AT_FC: address_type = 5;
pub const address_type_AT_FCWWN: address_type = 6;
pub const address_type_AT_STRINGZ: address_type = 7;
pub const address_type_AT_EUI64: address_type = 8;
pub const address_type_AT_IB: address_type = 9;
pub const address_type_AT_AX25: address_type = 10;
pub const address_type_AT_VINES: address_type = 11;
pub const address_type_AT_END_OF_LIST: address_type = 12;
pub type address_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _address {
    pub type_: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
    pub data: *const ::std::os::raw::c_void,
    pub priv_: *mut ::std::os::raw::c_void,
}
pub type address = _address;
extern "C" {
    pub fn address_to_bytes(addr: *const address, buf: *mut guint8, buf_len: guint) -> guint;
}
pub const port_type_PT_NONE: port_type = 0;
pub const port_type_PT_SCTP: port_type = 1;
pub const port_type_PT_TCP: port_type = 2;
pub const port_type_PT_UDP: port_type = 3;
pub const port_type_PT_DCCP: port_type = 4;
pub const port_type_PT_IPX: port_type = 5;
pub const port_type_PT_DDP: port_type = 6;
pub const port_type_PT_IDP: port_type = 7;
pub const port_type_PT_USB: port_type = 8;
pub const port_type_PT_I2C: port_type = 9;
pub const port_type_PT_IBQP: port_type = 10;
pub const port_type_PT_BLUETOOTH: port_type = 11;
pub type port_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    #[doc = "< name of protocol currently being dissected"]
    pub current_proto: *const ::std::os::raw::c_char,
    #[doc = "< Column formatting information"]
    pub cinfo: *mut epan_column_info,
    #[doc = "< Presence flags for some items"]
    pub presence_flags: guint32,
    #[doc = "< Frame number"]
    pub num: guint32,
    #[doc = "< Packet absolute time stamp"]
    pub abs_ts: nstime_t,
    #[doc = "< Relative timestamp (yes, it can be negative)"]
    pub rel_ts: nstime_t,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    #[doc = "< Record metadata"]
    pub rec: *mut wtap_rec,
    #[doc = "< Frame data sources"]
    pub data_src: *mut GSList,
    #[doc = "< link-layer source address"]
    pub dl_src: address,
    #[doc = "< link-layer destination address"]
    pub dl_dst: address,
    #[doc = "< network-layer source address"]
    pub net_src: address,
    #[doc = "< network-layer destination address"]
    pub net_dst: address,
    #[doc = "< source address (net if present, DL otherwise )"]
    pub src: address,
    #[doc = "< destination address (net if present, DL otherwise )"]
    pub dst: address,
    #[doc = "< First encountered VLAN Id if present otherwise 0"]
    pub vlan_id: guint32,
    #[doc = "< reason why reassembly wasn't done, if any"]
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if the protocol is only a fragment"]
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    #[doc = "< type of the following two port numbers"]
    pub ptype: port_type,
    #[doc = "< source port"]
    pub srcport: guint32,
    #[doc = "< destination port"]
    pub destport: guint32,
    #[doc = "< matched uint for calling subdissector from table"]
    pub match_uint: guint32,
    #[doc = "< matched string for calling subdissector from table"]
    pub match_string: *const ::std::os::raw::c_char,
    #[doc = "< TRUE if endpoint member should be used for conversations"]
    pub use_endpoint: gboolean,
    #[doc = "< Data that can be used for conversations"]
    pub conv_endpoint: *mut endpoint,
    #[doc = "< >0 if this segment could be desegmented."]
    #[doc = "A dissector that can offer this API (e.g."]
    #[doc = "TCP) sets can_desegment=2, then"]
    #[doc = "can_desegment is decremented by 1 each time"]
    #[doc = "we pass to the next subdissector. Thus only"]
    #[doc = "the dissector immediately above the"]
    #[doc = "protocol which sets the flag can use it"]
    pub can_desegment: guint16,
    #[doc = "< Value of can_desegment before current"]
    #[doc = "dissector was called.  Supplied so that"]
    #[doc = "dissectors for proxy protocols such as"]
    #[doc = "SOCKS can restore it, allowing the"]
    #[doc = "dissectors that they call to use the"]
    #[doc = "TCP dissector's desegmentation (SOCKS"]
    #[doc = "just retransmits TCP segments once it's"]
    #[doc = "finished setting things up, so the TCP"]
    #[doc = "desegmentor can desegment its payload)."]
    pub saved_can_desegment: guint16,
    #[doc = "< offset to stuff needing desegmentation"]
    pub desegment_offset: ::std::os::raw::c_int,
    #[doc = "< requested desegmentation additional length"]
    #[doc = "or"]
    #[doc = "DESEGMENT_ONE_MORE_SEGMENT:"]
    #[doc = "Desegment one more full segment"]
    #[doc = "(warning! only partially implemented)"]
    #[doc = "DESEGMENT_UNTIL_FIN:"]
    #[doc = "Desgment all data for this tcp session"]
    #[doc = "until the FIN segment."]
    pub desegment_len: guint32,
    #[doc = "< >0 if the subdissector has specified"]
    #[doc = "a value in 'bytes_until_next_pdu'."]
    #[doc = "When a dissector detects that the next PDU"]
    #[doc = "will start beyond the start of the next"]
    #[doc = "segment, it can set this value to 2"]
    #[doc = "and 'bytes_until_next_pdu' to the number of"]
    #[doc = "bytes beyond the next segment where the"]
    #[doc = "next PDU starts."]
    #[doc = ""]
    #[doc = "If the protocol dissector below this"]
    #[doc = "one is capable of PDU tracking it can"]
    #[doc = "use this hint to detect PDUs that starts"]
    #[doc = "unaligned to the segment boundaries."]
    #[doc = "The TCP dissector is using this hint from"]
    #[doc = "(some) protocols to detect when a new PDU"]
    #[doc = "starts in the middle of a tcp segment."]
    #[doc = ""]
    #[doc = "There is intelligence in the glue between"]
    #[doc = "dissector layers to make sure that this"]
    #[doc = "request is only passed down to the protocol"]
    #[doc = "immediately below the current one and not"]
    #[doc = "any further."]
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    #[doc = "< Packet was captured as an"]
    #[doc = "outbound (P2P_DIR_SENT)"]
    #[doc = "inbound (P2P_DIR_RECV)"]
    #[doc = "unknown (P2P_DIR_UNKNOWN)"]
    pub p2p_dir: ::std::os::raw::c_int,
    #[doc = "< a hash table passed from one dissector to another"]
    pub private_table: *mut GHashTable,
    #[doc = "< layers of each protocol"]
    pub layers: *mut wmem_list_t,
    #[doc = "< The current \"depth\" or layer number in the current frame"]
    pub curr_layer_num: guint8,
    pub link_number: guint16,
    #[doc = "< clnp/cotp source reference (can't use srcport, this would confuse tpkt)"]
    pub clnp_srcref: guint16,
    #[doc = "< clnp/cotp destination reference (can't use dstport, this would confuse tpkt)"]
    pub clnp_dstref: guint16,
    #[doc = "< 3GPP messages are sometime different UP link(UL) or Downlink(DL)"]
    pub link_dir: ::std::os::raw::c_int,
    #[doc = "< Per packet proto data"]
    pub proto_data: *mut GSList,
    #[doc = "< A list of frames which this one depends on"]
    pub dependent_frames: *mut GSList,
    pub frame_end_routines: *mut GSList,
    #[doc = "< Memory pool scoped to the pinfo struct"]
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    #[doc = "< name of heur list if this packet is being heuristically dissected"]
    pub heur_list_name: *const gchar,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type packet_info = _packet_info;
pub const ftenum_FT_NONE: ftenum = 0;
pub const ftenum_FT_PROTOCOL: ftenum = 1;
pub const ftenum_FT_BOOLEAN: ftenum = 2;
pub const ftenum_FT_CHAR: ftenum = 3;
pub const ftenum_FT_UINT8: ftenum = 4;
pub const ftenum_FT_UINT16: ftenum = 5;
pub const ftenum_FT_UINT24: ftenum = 6;
pub const ftenum_FT_UINT32: ftenum = 7;
pub const ftenum_FT_UINT40: ftenum = 8;
pub const ftenum_FT_UINT48: ftenum = 9;
pub const ftenum_FT_UINT56: ftenum = 10;
pub const ftenum_FT_UINT64: ftenum = 11;
pub const ftenum_FT_INT8: ftenum = 12;
pub const ftenum_FT_INT16: ftenum = 13;
pub const ftenum_FT_INT24: ftenum = 14;
pub const ftenum_FT_INT32: ftenum = 15;
pub const ftenum_FT_INT40: ftenum = 16;
pub const ftenum_FT_INT48: ftenum = 17;
pub const ftenum_FT_INT56: ftenum = 18;
pub const ftenum_FT_INT64: ftenum = 19;
pub const ftenum_FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const ftenum_FT_IEEE_11073_FLOAT: ftenum = 21;
pub const ftenum_FT_FLOAT: ftenum = 22;
pub const ftenum_FT_DOUBLE: ftenum = 23;
pub const ftenum_FT_ABSOLUTE_TIME: ftenum = 24;
pub const ftenum_FT_RELATIVE_TIME: ftenum = 25;
pub const ftenum_FT_STRING: ftenum = 26;
pub const ftenum_FT_STRINGZ: ftenum = 27;
pub const ftenum_FT_UINT_STRING: ftenum = 28;
pub const ftenum_FT_ETHER: ftenum = 29;
pub const ftenum_FT_BYTES: ftenum = 30;
pub const ftenum_FT_UINT_BYTES: ftenum = 31;
pub const ftenum_FT_IPv4: ftenum = 32;
pub const ftenum_FT_IPv6: ftenum = 33;
pub const ftenum_FT_IPXNET: ftenum = 34;
pub const ftenum_FT_FRAMENUM: ftenum = 35;
pub const ftenum_FT_PCRE: ftenum = 36;
pub const ftenum_FT_GUID: ftenum = 37;
pub const ftenum_FT_OID: ftenum = 38;
pub const ftenum_FT_EUI64: ftenum = 39;
pub const ftenum_FT_AX25: ftenum = 40;
pub const ftenum_FT_VINES: ftenum = 41;
pub const ftenum_FT_REL_OID: ftenum = 42;
pub const ftenum_FT_SYSTEM_ID: ftenum = 43;
pub const ftenum_FT_STRINGZPAD: ftenum = 44;
pub const ftenum_FT_FCWWN: ftenum = 45;
pub const ftenum_FT_NUM_TYPES: ftenum = 46;
pub type ftenum = i32;
pub use self::ftenum as ftenum_t;
pub const ft_framenum_type_FT_FRAMENUM_NONE: ft_framenum_type = 0;
pub const ft_framenum_type_FT_FRAMENUM_REQUEST: ft_framenum_type = 1;
pub const ft_framenum_type_FT_FRAMENUM_RESPONSE: ft_framenum_type = 2;
pub const ft_framenum_type_FT_FRAMENUM_ACK: ft_framenum_type = 3;
pub const ft_framenum_type_FT_FRAMENUM_DUP_ACK: ft_framenum_type = 4;
pub const ft_framenum_type_FT_FRAMENUM_RETRANS_PREV: ft_framenum_type = 5;
pub const ft_framenum_type_FT_FRAMENUM_RETRANS_NEXT: ft_framenum_type = 6;
pub const ft_framenum_type_FT_FRAMENUM_NUM_TYPES: ft_framenum_type = 7;
pub type ft_framenum_type = i32;
pub use self::ft_framenum_type as ft_framenum_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ftype_t {
    _unused: [u8; 0],
}
pub type ftype_t = _ftype_t;
pub const ftrepr_FTREPR_DISPLAY: ftrepr = 0;
pub const ftrepr_FTREPR_DFILTER: ftrepr = 1;
pub type ftrepr = i32;
pub use self::ftrepr as ftrepr_t;
extern "C" {
    pub fn ftypes_initialize();
}
extern "C" {
    pub fn ftype_similar_types(ftype_a: ftenum, ftype_b: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_name(ftype: ftenum_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ftype_pretty_name(ftype: ftenum_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ftype_length(ftype: ftenum_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftype_can_slice(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_eq(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_ne(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_gt(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_ge(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_lt(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_le(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_bitwise_and(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_contains(ftype: ftenum) -> gboolean;
}
extern "C" {
    pub fn ftype_can_matches(ftype: ftenum) -> gboolean;
}
pub const drange_node_end_t_DRANGE_NODE_END_T_UNINITIALIZED: drange_node_end_t = 0;
pub const drange_node_end_t_DRANGE_NODE_END_T_LENGTH: drange_node_end_t = 1;
pub const drange_node_end_t_DRANGE_NODE_END_T_OFFSET: drange_node_end_t = 2;
pub const drange_node_end_t_DRANGE_NODE_END_T_TO_THE_END: drange_node_end_t = 3;
pub type drange_node_end_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drange_node {
    pub start_offset: gint,
    pub length: gint,
    pub end_offset: gint,
    pub ending: drange_node_end_t,
}
pub type drange_node = _drange_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drange {
    pub range_list: *mut GSList,
    pub has_total_length: gboolean,
    pub total_length: gint,
    pub min_start_offset: gint,
    pub max_start_offset: gint,
}
pub type drange_t = _drange;
extern "C" {
    pub fn drange_node_new() -> *mut drange_node;
}
extern "C" {
    pub fn drange_node_free(drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_node_free_list(list: *mut GSList);
}
extern "C" {
    pub fn drange_node_get_start_offset(drnode: *mut drange_node) -> gint;
}
extern "C" {
    pub fn drange_node_get_length(drnode: *mut drange_node) -> gint;
}
extern "C" {
    pub fn drange_node_get_end_offset(drnode: *mut drange_node) -> gint;
}
extern "C" {
    pub fn drange_node_get_ending(drnode: *mut drange_node) -> drange_node_end_t;
}
extern "C" {
    pub fn drange_node_set_start_offset(drnode: *mut drange_node, offset: gint);
}
extern "C" {
    pub fn drange_node_set_length(drnode: *mut drange_node, length: gint);
}
extern "C" {
    pub fn drange_node_set_end_offset(drnode: *mut drange_node, offset: gint);
}
extern "C" {
    pub fn drange_node_set_to_the_end(drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_new() -> *mut drange_t;
}
extern "C" {
    pub fn drange_new_from_list(list: *mut GSList) -> *mut drange_t;
}
extern "C" {
    pub fn drange_dup(org: *mut drange_t) -> *mut drange_t;
}
extern "C" {
    pub fn drange_free(dr: *mut drange_t);
}
extern "C" {
    pub fn drange_has_total_length(dr: *mut drange_t) -> gboolean;
}
extern "C" {
    pub fn drange_get_total_length(dr: *mut drange_t) -> gint;
}
extern "C" {
    pub fn drange_get_min_start_offset(dr: *mut drange_t) -> gint;
}
extern "C" {
    pub fn drange_get_max_start_offset(dr: *mut drange_t) -> gint;
}
extern "C" {
    pub fn drange_append_drange_node(dr: *mut drange_t, drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_prepend_drange_node(dr: *mut drange_t, drnode: *mut drange_node);
}
extern "C" {
    pub fn drange_foreach_drange_node(dr: *mut drange_t, func: GFunc, funcdata: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _protocol_value_t {
    pub tvb: *mut tvbuff_t,
    pub proto_string: *mut gchar,
}
pub type protocol_value_t = _protocol_value_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fvalue_t {
    pub ftype: *mut ftype_t,
    pub value: _fvalue_t__bindgen_ty_1,
    pub fvalue_gboolean1: gboolean,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fvalue_t__bindgen_ty_1 {
    pub uinteger: guint32,
    pub sinteger: gint32,
    pub integer64: guint64,
    pub uinteger64: guint64,
    pub sinteger64: gint64,
    pub floating: gdouble,
    pub string: *mut gchar,
    pub ustring: *mut guchar,
    pub bytes: *mut GByteArray,
    pub ipv4: ipv4_addr_and_mask,
    pub ipv6: ipv6_addr_and_prefix,
    pub guid: e_guid_t,
    pub time: nstime_t,
    pub protocol: protocol_value_t,
    pub re: *mut GRegex,
    pub sfloat_ieee_11073: guint16,
    pub float_ieee_11073: guint32,
    _bindgen_union_align: [u64; 3usize],
}
pub type fvalue_t = _fvalue_t;
extern "C" {
    pub fn fvalue_new(ftype: ftenum_t) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_init(fv: *mut fvalue_t, ftype: ftenum_t);
}
extern "C" {
    pub fn fvalue_from_unparsed(
        ftype: ftenum_t,
        s: *const ::std::os::raw::c_char,
        allow_partial_value: gboolean,
        err_msg: *mut *mut gchar,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_from_string(
        ftype: ftenum_t,
        s: *const ::std::os::raw::c_char,
        err_msg: *mut *mut gchar,
    ) -> *mut fvalue_t;
}
extern "C" {
    pub fn fvalue_string_repr_len(
        fv: *mut fvalue_t,
        rtype: ftrepr_t,
        field_display: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fvalue_to_string_repr(
        scope: *mut wmem_allocator_t,
        fv: *mut fvalue_t,
        rtype: ftrepr_t,
        field_display: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fvalue_type_ftenum(fv: *mut fvalue_t) -> ftenum_t;
}
extern "C" {
    pub fn fvalue_type_name(fv: *mut fvalue_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fvalue_set_byte_array(fv: *mut fvalue_t, value: *mut GByteArray);
}
extern "C" {
    pub fn fvalue_set_bytes(fv: *mut fvalue_t, value: *const guint8);
}
extern "C" {
    pub fn fvalue_set_guid(fv: *mut fvalue_t, value: *const e_guid_t);
}
extern "C" {
    pub fn fvalue_set_time(fv: *mut fvalue_t, value: *const nstime_t);
}
extern "C" {
    pub fn fvalue_set_string(fv: *mut fvalue_t, value: *const gchar);
}
extern "C" {
    pub fn fvalue_set_protocol(fv: *mut fvalue_t, value: *mut tvbuff_t, name: *const gchar);
}
extern "C" {
    pub fn fvalue_set_uinteger(fv: *mut fvalue_t, value: guint32);
}
extern "C" {
    pub fn fvalue_set_sinteger(fv: *mut fvalue_t, value: gint32);
}
extern "C" {
    pub fn fvalue_set_uinteger64(fv: *mut fvalue_t, value: guint64);
}
extern "C" {
    pub fn fvalue_set_sinteger64(fv: *mut fvalue_t, value: gint64);
}
extern "C" {
    pub fn fvalue_set_floating(fv: *mut fvalue_t, value: gdouble);
}
extern "C" {
    pub fn fvalue_get(fv: *mut fvalue_t) -> gpointer;
}
extern "C" {
    pub fn fvalue_get_uinteger(fv: *mut fvalue_t) -> guint32;
}
extern "C" {
    pub fn fvalue_get_sinteger(fv: *mut fvalue_t) -> gint32;
}
extern "C" {
    pub fn fvalue_get_uinteger64(fv: *mut fvalue_t) -> guint64;
}
extern "C" {
    pub fn fvalue_get_sinteger64(fv: *mut fvalue_t) -> gint64;
}
extern "C" {
    pub fn fvalue_get_floating(fv: *mut fvalue_t) -> f64;
}
extern "C" {
    pub fn fvalue_eq(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_ne(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_gt(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_ge(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_lt(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_le(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_bitwise_and(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_contains(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_matches(a: *const fvalue_t, b: *const fvalue_t) -> gboolean;
}
extern "C" {
    pub fn fvalue_length(fv: *mut fvalue_t) -> guint;
}
extern "C" {
    pub fn fvalue_slice(fv: *mut fvalue_t, dr: *mut drange_t) -> *mut fvalue_t;
}
pub const register_action_e_RA_NONE: register_action_e = 0;
pub const register_action_e_RA_DISSECTORS: register_action_e = 1;
pub const register_action_e_RA_LISTENERS: register_action_e = 2;
pub const register_action_e_RA_EXTCAP: register_action_e = 3;
pub const register_action_e_RA_REGISTER: register_action_e = 4;
pub const register_action_e_RA_PLUGIN_REGISTER: register_action_e = 5;
pub const register_action_e_RA_HANDOFF: register_action_e = 6;
pub const register_action_e_RA_PLUGIN_HANDOFF: register_action_e = 7;
pub const register_action_e_RA_LUA_PLUGINS: register_action_e = 8;
pub const register_action_e_RA_LUA_DEREGISTER: register_action_e = 9;
pub const register_action_e_RA_PREFERENCES: register_action_e = 10;
pub const register_action_e_RA_INTERFACES: register_action_e = 11;
pub type register_action_e = i32;
pub type register_cb = ::std::option::Option<
    unsafe extern "C" fn(
        action: register_action_e,
        message: *const ::std::os::raw::c_char,
        client_data: gpointer,
    ),
>;
extern "C" {
    pub static mut hf_text_only: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expert_field {
    _unused: [u8; 0],
}
pub type custom_fmt_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut gchar, arg2: guint32)>;
pub type custom_fmt_func_64_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut gchar, arg2: guint64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _protocol {
    _unused: [u8; 0],
}
#[doc = " Structure for information about a protocol"]
pub type protocol_t = _protocol;
extern "C" {
    #[doc = " Function used for reporting errors in dissectors; it throws a"]
    #[doc = " DissectorError exception, with a string generated from the format"]
    #[doc = " and arguments to the format, as the message for the exception, so"]
    #[doc = " that it can show up in the Info column and the protocol tree."]
    #[doc = ""]
    #[doc = " If the WIRESHARK_ABORT_ON_DISSECTOR_BUG environment variable is set,"]
    #[doc = " it will call abort(), instead, to make it easier to get a stack trace."]
    #[doc = ""]
    #[doc = " @param format format string to use for the message"]
    pub fn proto_report_dissector_bug(format: *const ::std::os::raw::c_char, ...);
}
#[doc = "< none"]
pub const field_display_e_BASE_NONE: field_display_e = 0;
#[doc = "< decimal"]
pub const field_display_e_BASE_DEC: field_display_e = 1;
#[doc = "< hexadecimal"]
pub const field_display_e_BASE_HEX: field_display_e = 2;
#[doc = "< octal"]
pub const field_display_e_BASE_OCT: field_display_e = 3;
#[doc = "< decimal (hexadecimal)"]
pub const field_display_e_BASE_DEC_HEX: field_display_e = 4;
#[doc = "< hexadecimal (decimal)"]
pub const field_display_e_BASE_HEX_DEC: field_display_e = 5;
#[doc = "< call custom routine (in ->strings) to format"]
pub const field_display_e_BASE_CUSTOM: field_display_e = 6;
#[doc = "< decimal-format float"]
pub const field_display_e_BASE_FLOAT: field_display_e = 0;
#[doc = "< shows non-printable ASCII characters as C-style escapes"]
pub const field_display_e_STR_ASCII: field_display_e = 0;
#[doc = "< shows non-printable UNICODE characters as \\\\uXXXX (XXX for now non-printable characters display depends on UI)"]
pub const field_display_e_STR_UNICODE: field_display_e = 7;
#[doc = "< hexadecimal bytes with a period (.) between each byte"]
pub const field_display_e_SEP_DOT: field_display_e = 8;
#[doc = "< hexadecimal bytes with a dash (-) between each byte"]
pub const field_display_e_SEP_DASH: field_display_e = 9;
#[doc = "< hexadecimal bytes with a colon (:) between each byte"]
pub const field_display_e_SEP_COLON: field_display_e = 10;
#[doc = "< hexadecimal bytes with a space between each byte"]
pub const field_display_e_SEP_SPACE: field_display_e = 11;
#[doc = "< Used for IPv4 address that shouldn't be resolved (like for netmasks)"]
pub const field_display_e_BASE_NETMASK: field_display_e = 12;
#[doc = "< UDP port"]
pub const field_display_e_BASE_PT_UDP: field_display_e = 13;
#[doc = "< TCP port"]
pub const field_display_e_BASE_PT_TCP: field_display_e = 14;
#[doc = "< DCCP port"]
pub const field_display_e_BASE_PT_DCCP: field_display_e = 15;
#[doc = "< SCTP port"]
pub const field_display_e_BASE_PT_SCTP: field_display_e = 16;
#[doc = "< OUI resolution"]
pub const field_display_e_BASE_OUI: field_display_e = 17;
pub type field_display_e = i32;
#[doc = "< Field is not referenced"]
pub const hf_ref_type_HF_REF_TYPE_NONE: hf_ref_type = 0;
#[doc = "< Field is indirectly referenced (only applicable for FT_PROTOCOL) via. its child"]
pub const hf_ref_type_HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
#[doc = "< Field is directly referenced"]
pub const hf_ref_type_HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = i32;
#[doc = " information describing a header field"]
pub type header_field_info = _header_field_info;
#[doc = " information describing a header field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    #[doc = "< [FIELDNAME] full name of this field"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDABBREV] abbreviated name of this field"]
    pub abbrev: *const ::std::os::raw::c_char,
    #[doc = "< [FIELDTYPE] field type, one of FT_ (from ftypes.h)"]
    pub r#type: ftenum,
    #[doc = "< [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask"]
    pub display: ::std::os::raw::c_int,
    #[doc = "< [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,"]
    #[doc = "typically converted by VALS(), RVALS() or TFS()."]
    #[doc = "If this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the"]
    #[doc = "associated protocol_t structure"]
    pub strings: *const ::std::os::raw::c_void,
    #[doc = "< [BITMASK] bitmask of interesting bits"]
    pub bitmask: guint64,
    #[doc = "< [FIELDDESCR] Brief description of field"]
    pub blurb: *const ::std::os::raw::c_char,
    #[doc = "< Field ID"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< parent protocol tree"]
    pub parent: ::std::os::raw::c_int,
    #[doc = "< is this field referenced by a filter"]
    pub ref_type: hf_ref_type,
    #[doc = "< ID of previous hfinfo with same abbrev"]
    pub same_name_prev_id: ::std::os::raw::c_int,
    #[doc = "< Link to next hfinfo with same abbrev"]
    pub same_name_next: *mut header_field_info,
}
#[doc = " Used when registering many fields at once, using proto_register_field_array()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    #[doc = "< written to by register() function"]
    pub p_id: *mut ::std::os::raw::c_int,
    #[doc = "< the field info to be registered"]
    pub hfinfo: header_field_info,
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _item_label_t {
    pub representation: [::std::os::raw::c_char; 240usize],
}
#[doc = " string representation, if one of the proto_tree_add_..._format() functions used"]
pub type item_label_t = _item_label_t;
#[doc = " Contains the field information for the proto_item."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct field_info {
    #[doc = "< pointer to registered field information"]
    pub hfinfo: *mut header_field_info,
    #[doc = "< current start of data in field_info.ds_tvb"]
    pub start: gint,
    #[doc = "< current data length of item in field_info.ds_tvb"]
    pub length: gint,
    #[doc = "< start of appendix data"]
    pub appendix_start: gint,
    #[doc = "< length of appendix data"]
    pub appendix_length: gint,
    #[doc = "< one of ETT_ or -1"]
    pub tree_type: gint,
    #[doc = "< bitfield like FI_GENERATED, ..."]
    pub flags: guint32,
    #[doc = "< string for GUI tree"]
    pub rep: *mut item_label_t,
    #[doc = "< data source tvbuff"]
    pub ds_tvb: *mut tvbuff_t,
    pub value: fvalue_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crumb_spec_t {
    pub crumb_bit_offset: guint,
    pub crumb_bit_length: guint8,
}
#[doc = " One of these exists for the entire protocol tree. Each proto_node"]
#[doc = " in the protocol tree points to the same copy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_data_t {
    pub interesting_hfids: *mut GHashTable,
    pub visible: gboolean,
    pub fake_protocols: gboolean,
    pub count: gint,
    pub pinfo: *mut _packet_info,
}
#[doc = " Each proto_tree, proto_item is one of these."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _proto_node {
    pub first_child: *mut _proto_node,
    pub last_child: *mut _proto_node,
    pub next: *mut _proto_node,
    pub parent: *mut _proto_node,
    pub finfo: *mut field_info,
    pub tree_data: *mut tree_data_t,
}
#[doc = " Each proto_tree, proto_item is one of these."]
pub type proto_node = _proto_node;
#[doc = " A protocol tree element."]
pub type proto_tree = proto_node;
#[doc = " A protocol item element."]
pub type proto_item = proto_node;
pub type proto_tree_foreach_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut proto_node, arg2: gpointer)>;
pub type proto_tree_traverse_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut proto_node, arg2: gpointer) -> gboolean>;
extern "C" {
    pub fn proto_tree_traverse_post_order(
        tree: *mut proto_tree,
        func: proto_tree_traverse_func,
        data: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn proto_tree_children_foreach(
        tree: *mut proto_tree,
        func: proto_tree_foreach_func,
        data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_plugin {
    pub register_protoinfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_handoff: ::std::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    #[doc = " Register dissector plugin with the plugin system."]
    pub fn proto_register_plugin(plugin: *const proto_plugin);
}
extern "C" {
    #[doc = " Sets up memory used by proto routines. Called at program startup"]
    pub fn proto_init(
        register_all_plugin_protocols_list: *mut GSList,
        register_all_plugin_handoffs_list: *mut GSList,
        cb: register_cb,
        client_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Frees memory used by proto routines. Called at program shutdown"]
    pub fn proto_cleanup();
}
extern "C" {
    #[doc = " This function takes a tree and a protocol id as parameter and"]
    #[doc = "will return TRUE/FALSE for whether the protocol or any of the filterable"]
    #[doc = "fields in the protocol is referenced by any fitlers."]
    #[doc = "If this function returns FALSE then it is safe to skip any"]
    #[doc = "proto_tree_add_...() calls and just treat the call as if the"]
    #[doc = "dissector was called with tree==NULL."]
    #[doc = "If you reset the tree to NULL by this dissector returning FALSE,"]
    #[doc = "you will still need to call any subdissector with the original value of"]
    #[doc = "tree or filtering will break."]
    #[doc = ""]
    #[doc = "The purpose of this is to optimize wireshark for speed and make it"]
    #[doc = "faster for when filters are being used."]
    pub fn proto_field_is_referenced(
        tree: *mut proto_tree,
        proto_id: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Create a subtree under an existing item."]
    #[doc = "@param ti the parent item of the new subtree"]
    #[doc = "@param idx one of the ett_ array elements registered with proto_register_subtree_array()"]
    #[doc = "@return the new subtree"]
    pub fn proto_item_add_subtree(ti: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get an existing subtree under an item."]
    #[doc = "@param ti the parent item of the subtree"]
    #[doc = "@return the subtree or NULL"]
    pub fn proto_item_get_subtree(ti: *mut proto_item) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the parent of a subtree item."]
    #[doc = "@param ti the child item in the subtree"]
    #[doc = "@return parent item or NULL"]
    pub fn proto_item_get_parent(ti: *const proto_item) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get Nth generation parent item."]
    #[doc = "@param ti the child item in the subtree"]
    #[doc = "@param gen the generation to get (using 1 here is the same as using proto_item_get_parent())"]
    #[doc = "@return parent item"]
    pub fn proto_item_get_parent_nth(
        ti: *mut proto_item,
        gen: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Replace text of item after it already has been created."]
    #[doc = "@param ti the item to set the text"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_set_text(ti: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Append to text of item after it has already been created."]
    #[doc = "@param ti the item to append the text to"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_append_text(ti: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Prepend to text of item after it has already been created."]
    #[doc = "@param ti the item to prepend the text to"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    pub fn proto_item_prepend_text(ti: *mut proto_item, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Set proto_item's length inside tvb, after it has already been created."]
    #[doc = "@param ti the item to set the length"]
    #[doc = "@param length the new length ot the item"]
    pub fn proto_item_set_len(ti: *mut proto_item, length: gint);
}
extern "C" {
    #[doc = " Sets the length of the item based on its start and on the specified"]
    #[doc = " offset, which is the offset past the end of the item; as the start"]
    #[doc = " in the item is relative to the beginning of the data source tvbuff,"]
    #[doc = " we need to pass in a tvbuff."]
    #[doc = "@param ti the item to set the length"]
    #[doc = "@param tvb end is relative to this tvbuff"]
    #[doc = "@param end this end offset is relative to the beginning of tvb"]
    #[doc = "@todo make usage clearer, I don't understand it!"]
    pub fn proto_item_set_end(ti: *mut proto_item, tvb: *mut tvbuff_t, end: gint);
}
extern "C" {
    #[doc = " Get length of a proto_item. Useful after using proto_tree_add_item()"]
    #[doc = " to add a variable-length field (e.g., FT_NSTRING_UINT8)."]
    #[doc = "@param ti the item to get the length from"]
    #[doc = "@return the current length"]
    pub fn proto_item_get_len(ti: *const proto_item) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new proto_tree root."]
    #[doc = "@return the new tree root"]
    pub fn proto_tree_create_root(pinfo: *mut _packet_info) -> *mut proto_tree;
}
extern "C" {
    pub fn proto_tree_reset(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Clear memory for entry proto_tree. Clears proto_tree struct also."]
    #[doc = "@param tree the tree to free"]
    pub fn proto_tree_free(tree: *mut proto_tree);
}
extern "C" {
    #[doc = " Set the tree visible or invisible."]
    #[doc = "Is the parsing being done for a visible proto_tree or an invisible one?"]
    #[doc = "By setting this correctly, the proto_tree creation is sped up by not"]
    #[doc = "having to call g_vsnprintf and copy strings around."]
    #[doc = "@param tree the tree to be set"]
    #[doc = "@param visible ... or not"]
    #[doc = "@return the old value"]
    pub fn proto_tree_set_visible(tree: *mut proto_tree, visible: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " Indicate whether we should fake protocols during dissection (default = TRUE)"]
    #[doc = "@param tree the tree to be set"]
    #[doc = "@param fake_protocols TRUE if we should fake protocols"]
    pub fn proto_tree_set_fake_protocols(tree: *mut proto_tree, fake_protocols: gboolean);
}
extern "C" {
    #[doc = " Mark a field/protocol ID as \"interesting\"."]
    #[doc = "@param tree the tree to be set (currently ignored)"]
    #[doc = "@param hfid the interesting field id"]
    #[doc = "@todo what *does* interesting mean?"]
    pub fn proto_tree_prime_with_hfid(tree: *mut proto_tree, hfid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get a parent item of a subtree."]
    #[doc = "@param tree the tree to get the parent from"]
    #[doc = "@return parent item"]
    pub fn proto_tree_get_parent(tree: *mut proto_tree) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get the parent tree of a subtree."]
    #[doc = "@param tree the tree to get the parent from"]
    #[doc = "@return parent tree"]
    pub fn proto_tree_get_parent_tree(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Get the root tree from any subtree."]
    #[doc = "@param tree the tree to get the root from"]
    #[doc = "@return root tree"]
    pub fn proto_tree_get_root(tree: *mut proto_tree) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Move an existing item behind another existing item."]
    #[doc = "@param tree the tree to which both items belong"]
    #[doc = "@param fixed_item the item which keeps its position"]
    #[doc = "@param item_to_move the item which will be moved"]
    pub fn proto_tree_move_item(
        tree: *mut proto_tree,
        fixed_item: *mut proto_item,
        item_to_move: *mut proto_item,
    );
}
extern "C" {
    #[doc = " Set start and length of an appendix for a proto_tree."]
    #[doc = "@param tree the tree to set the appendix start and length"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start the start offset of the appendix"]
    #[doc = "@param length the length of the appendix"]
    pub fn proto_tree_set_appendix(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    );
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item."]
    #[doc = "The item is extracted from the tvbuff handed to it."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfinfo field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param encoding data encoding"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_item_new(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an item to a proto_tree, using the text label registered to that item."]
    #[doc = "The item is extracted from the tvbuff handed to it."]
    #[doc = ""]
    #[doc = "Return the length of the item through the pointer."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfinfo field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param encoding data encoding"]
    #[doc = "@param[out] lenretval points to a gint that will be set to the item length"]
    #[doc = "@return the newly created item, and *lenretval is set to the item length"]
    pub fn proto_tree_add_item_new_ret_length(
        tree: *mut proto_tree,
        hfinfo: *mut header_field_info,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an integer data item to a proto_tree, using the text label registered to that item."]
    #[doc = "The item is extracted from the tvbuff handed to it, and the retrieved"]
    #[doc = "value is also set to *retval so the caller gets it back for other uses."]
    #[doc = ""]
    #[doc = "This function retrieves the value even if the passed-in tree param is NULL,"]
    #[doc = "so that it can be used by dissectors at all times to both get the value"]
    #[doc = "and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported."]
    #[doc = ""]
    #[doc = "This function accepts ENC_LITTLE_ENDIAN and ENC_BIG_ENDIAN for native number"]
    #[doc = "encoding in the tvbuff"]
    #[doc = ""]
    #[doc = "The length argument must"]
    #[doc = "be set to the appropriate size of the native type as in other proto_add routines."]
    #[doc = ""]
    #[doc = "Integers of 8, 16, 24 and 32 bits can be retrieved with the _ret_int and"]
    #[doc = "ret_uint functions; integers of 40, 48, 56, and 64 bits can be retrieved"]
    #[doc = "with the _ret_uint64 function; Boolean values of 8, 16, 24, 32, 40, 48,"]
    #[doc = "56, and 64 bits can be retrieved with the _ret_boolean function."]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_BIG_ENDIAN, ENC_ASCII|ENC_STRING, etc.)"]
    #[doc = "@param[out] retval points to a gint32 or guint32 which will be set to the value"]
    #[doc = "@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_item_ret_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint32,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_varint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut guint64,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    pub fn proto_tree_add_item_ret_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut gboolean,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to"]
    #[doc = "that item."]
    #[doc = ""]
    #[doc = "The item is extracted from the tvbuff handed to it, and the retrieved"]
    #[doc = "value and its length are returned through pointers so the caller can use"]
    #[doc = "them.  The value is allocated using the wmem scope passed in."]
    #[doc = ""]
    #[doc = "This function retrieves the value and length even if the passed-in tree"]
    #[doc = "param is NULL, so that then can be used by dissectors at all times to"]
    #[doc = "both get the value and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported."]
    #[doc = ""]
    #[doc = "This function accepts string encodings."]
    #[doc = ""]
    #[doc = "@param scope the wmem scope to use to allocate the string"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)"]
    #[doc = "@param[out] retval points to a guint8 * that will be set to point to the"]
    #[doc = "string value"]
    #[doc = "@param[out] lenretval points to a gint that will be set to the item length"]
    #[doc = "@return the newly created item, *retval is set to the decoded value,"]
    #[doc = "and *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string item to a proto_tree, using the text label registered to"]
    #[doc = "that item."]
    #[doc = ""]
    #[doc = "The item is extracted from the tvbuff handed to it, and the retrieved"]
    #[doc = "value is returned through a pointer so the caller can use it.  The value"]
    #[doc = "is allocated using the wmem scope passed in."]
    #[doc = ""]
    #[doc = "This function retrieves the value even if the passed-in tree param is NULL,"]
    #[doc = "so that it can be used by dissectors at all times to both get the value"]
    #[doc = "and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported."]
    #[doc = ""]
    #[doc = "This function accepts string encodings."]
    #[doc = ""]
    #[doc = "@param scope the wmem scope to use to allocate the string"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)"]
    #[doc = "@param[out] retval points to a guint8 * that will be set to point to the"]
    #[doc = "string value"]
    #[doc = "@return the newly created item, and *retval is set to the decoded value"]
    pub fn proto_tree_add_item_ret_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the"]
    #[doc = "text label registered to that item."]
    #[doc = ""]
    #[doc = "This provides a string that is a display representation of the value,"]
    #[doc = "and the length of the item, similar to what"]
    #[doc = "proto_tree_add_item_ret_string_and_length() does."]
    #[doc = ""]
    #[doc = "@param scope the wmem scope to use to allocate the string"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)"]
    #[doc = "@param[out] retval points to a guint8 * that will be set to point to the"]
    #[doc = "string value"]
    #[doc = "@param[out] lenretval points to a gint that will be set to the item length"]
    #[doc = "@return the newly created item, *retval is set to the display string,"]
    #[doc = "and *lenretval is set to the item length"]
    pub fn proto_tree_add_item_ret_display_string_and_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
        lenretval: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an string or byte array item to a proto_tree, using the"]
    #[doc = "text label registered to that item."]
    #[doc = ""]
    #[doc = "This provides a string that is a display representation of the value,"]
    #[doc = "similar to what proto_tree_add_item_ret_string() does."]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)"]
    #[doc = "@param scope the wmem scope to use to allocate the string"]
    #[doc = "@param[out] retval points to a guint8 * that will be set to point to the"]
    #[doc = "string value"]
    #[doc = "@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_display_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a time item to a proto_tree, using thetext label registered to that item."]
    #[doc = ""]
    #[doc = "This provides a string that is a display representation of the time value"]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb (cannot be negative)"]
    #[doc = "@param length length of data in tvb (for strings can be -1 for remaining)"]
    #[doc = "@param encoding data encoding (e.g, ENC_ASCII, ENC_UTF_8, etc.)"]
    #[doc = "@param scope the wmem scope to use to allocate the string"]
    #[doc = "@param[out] retval points to a guint8 * that will be set to point to the"]
    #[doc = "string value"]
    #[doc = "@return the newly created item, *retval is set to the display string"]
    pub fn proto_tree_add_item_ret_time_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        scope: *mut wmem_allocator_t,
        retval: *mut *mut ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_text_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " (INTERNAL USE ONLY) Add a text-only node to a proto_tree using a variable argument list."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ap variable argument list"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_text_valist_internal(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param idx one of the ett_ array elements registered with proto_register_subtree_array()"]
    #[doc = "@param tree_item item returned with tree creation. Can be NULL if going to be unused"]
    #[doc = "@param text label for the tree"]
    #[doc = "@return the newly created tree"]
    pub fn proto_tree_add_subtree(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        text: *const ::std::os::raw::c_char,
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node that creates a subtree underneath."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param idx one of the ett_ array elements registered with proto_register_subtree_array()"]
    #[doc = "@param tree_item item returned with tree creation. Can be NULL if going to be unused"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created tree"]
    pub fn proto_tree_add_subtree_format(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        idx: gint,
        tree_item: *mut *mut proto_item,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_tree;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text() string."]
    pub fn proto_tree_add_format_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text-only node to a proto_tree with tvb_format_text_wsp() string."]
    pub fn proto_tree_add_format_wsp_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_NONE field to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_none_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_PROTOCOL to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_protocol_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BYTES to a proto_tree like proto_tree_add_bytes,"]
    #[doc = "but used when the tvb data length does not match the bytes length."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param ptr_length length of data in start_ptr"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_with_length(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        ptr_length: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a byte-array-based FT_* to a proto_tree."]
    #[doc = ""]
    #[doc = "Supported: FT_BYTES, FT_UINT_BYTES, FT_OID, FT_REL_OID, and FT_SYSTEM_ID."]
    #[doc = ""]
    #[doc = "The item is extracted from the tvbuff handed to it, based on the ENC_* passed"]
    #[doc = "in for the encoding, and the retrieved byte array is also set to *retval so the"]
    #[doc = "caller gets it back for other uses."]
    #[doc = ""]
    #[doc = "This function retrieves the value even if the passed-in tree param is NULL,"]
    #[doc = "so that it can be used by dissectors at all times to both get the value"]
    #[doc = "and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported. For string"]
    #[doc = "encoding, this means that a failure to decode the hex value from the string"]
    #[doc = "results in an expert info error being added to the tree."]
    #[doc = ""]
    #[doc = "If encoding is string-based, it will convert using tvb_get_string_bytes(); see"]
    #[doc = "that function's comments for details."]
    #[doc = ""]
    #[doc = "@note The GByteArray retval must be pre-constructed using g_byte_array_new()."]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, or ENC_UTF_8|ENC_STR_HEX)"]
    #[doc = "@param[in,out] retval points to a GByteArray which will be set to the bytes from the Tvb."]
    #[doc = "@param[in,out] endoff if not NULL, gets set to the character after those consumed."]
    #[doc = "@param[in,out] err if not NULL, gets set to 0 if no failure, else the errno code (e.g., EDOM, ERANGE)."]
    #[doc = "@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_bytes_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut GByteArray,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BYTES to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param start_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bytes_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        start_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr pointer to the data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_time(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const nstime_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Get and add a FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree."]
    #[doc = "The item is extracted from the tvbuff handed to it, based on the ENC_* passed"]
    #[doc = "in for the encoding, and the retrieved value is also set to *retval so the"]
    #[doc = "caller gets it back for other uses."]
    #[doc = ""]
    #[doc = "This function retrieves the value even if the passed-in tree param is NULL,"]
    #[doc = "so that it can be used by dissectors at all times to both get the value"]
    #[doc = "and set the tree item to it."]
    #[doc = ""]
    #[doc = "Like other proto_tree_add functions, if there is a tree and the value cannot"]
    #[doc = "be decoded from the tvbuff, then an expert info error is reported. For string"]
    #[doc = "encoding, this means that a failure to decode the time value from the string"]
    #[doc = "results in an expert info error being added to the tree."]
    #[doc = ""]
    #[doc = "If encoding is string-based, it will convert using tvb_get_string_time(); see"]
    #[doc = "that function's comments for details."]
    #[doc = ""]
    #[doc = "@note The nstime_t *retval must be pre-allocated as a nstime_t."]
    #[doc = ""]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param encoding data encoding (e.g, ENC_LITTLE_ENDIAN, ENC_UTF_8|ENC_ISO_8601_DATE_TIME, etc.)"]
    #[doc = "@param[in,out] retval points to a nstime_t which will be set to the value"]
    #[doc = "@param[in,out] endoff if not NULL, gets set to the character after those consumed."]
    #[doc = "@param[in,out] err if not NULL, gets set to 0 if no failure, else the errno code (e.g., EDOM, ERANGE)."]
    #[doc = "@return the newly created item, and retval is set to the decoded value"]
    pub fn proto_tree_add_time_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
        retval: *mut nstime_t,
        endoff: *mut gint,
        err: *mut gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field name"]
    #[doc = "being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_time_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ABSOLUTE_TIME or FT_RELATIVE_TIME to a proto_tree, with"]
    #[doc = "the format generating the entire string for the entry, including any field"]
    #[doc = "name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr pointer to the data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_time_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *mut nstime_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPXNET to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipxnet(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPXNET to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipxnet_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv4 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv4(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv4_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv4 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv4_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_IPv6 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv6(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv6_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_IPv6 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ipv6_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const ws_in6_addr,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_ETHER to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ether(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ether_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_ETHER to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ether_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_GUID to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_GUID to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_guid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const e_guid_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_OID to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_oid(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_oid_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_OID to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value_ptr data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_oid_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value_ptr: *const guint8,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING or FT_STRINGZPAD to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING or FT_STRINGZPAD to a proto_tree, with the"]
    #[doc = "format generating the string for the value and with the field name"]
    #[doc = "being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_STRING or FT_STRINGZPAD to a proto_tree, with the"]
    #[doc = "format generating the entire string for the entry, including any field"]
    #[doc = "name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_BOOLEAN to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_BOOLEAN to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_FLOAT to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_FLOAT to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_DOUBLE to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_double(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_double_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_DOUBLE to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_double_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: f64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,"]
    #[doc = "with the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including any"]
    #[doc = "field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_UINT64 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_UINT64 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add one of FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,"]
    #[doc = "with the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT8, FT_INT16, FT_INT24 or FT_INT32 to a proto_tree,"]
    #[doc = "with the format generating the entire string for the entry, including"]
    #[doc = "any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add an FT_INT64 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_INT64 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_EUI64 to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_eui64(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating"]
    #[doc = "the string for the value and with the field name being included"]
    #[doc = "automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_eui64_format_value(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a formatted FT_EUI64 to a proto_tree, with the format generating"]
    #[doc = "the entire string for the entry, including any field name."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param start start of data in tvb"]
    #[doc = "@param length length of data in tvb"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_eui64_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Useful for quick debugging. Also sends string to STDOUT, so don't"]
    #[doc = "leave call to this function in production code."]
    #[doc = "@param tree the tree to append the text to"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_debug_text(
        tree: *mut proto_tree,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Fill given label_str with string representation of field"]
    #[doc = "@param fi the item to get the info from"]
    #[doc = "@param label_str the string to fill"]
    #[doc = "@todo think about changing the parameter profile"]
    pub fn proto_item_fill_label(fi: *mut field_info, label_str: *mut gchar);
}
extern "C" {
    #[doc = " Register a new protocol."]
    #[doc = "@param name the full name of the new protocol"]
    #[doc = "@param short_name abbreviated name of the new protocol"]
    #[doc = "@param filter_name protocol name used for a display filter string"]
    #[doc = "@return the new protocol handle"]
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a \"helper\" protocol (pino - protocol in name only)."]
    #[doc = "This is for dissectors that need distinguishing names and don't need the other"]
    #[doc = "features (like enable/disable).  One use case is a protocol with multiple dissection"]
    #[doc = "functions in a single dissector table needing unique \"dissector names\" to remove"]
    #[doc = "confusion with Decode As dialog.  Another use case is for a dissector table set"]
    #[doc = "up to handle TLVs within a single protocol (and allow \"external\" TLVs being"]
    #[doc = "registered through the dissector table)."]
    #[doc = "@param name the full name of the new protocol"]
    #[doc = "@param short_name abbreviated name of the new protocol"]
    #[doc = "@param filter_name protocol name used for a display filter string"]
    #[doc = "@param parent_proto the \"real\" protocol for the helper.  The parent decides enable/disable"]
    #[doc = "@param field_type FT_PROTOCOL or FT_BYTES.  Allows removal of \"protocol highlighting\" (FT_BYTES)"]
    #[doc = "if pino is part of TLV."]
    #[doc = "@return the new protocol handle"]
    pub fn proto_register_protocol_in_name_only(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
        parent_proto: ::std::os::raw::c_int,
        field_type: ftenum,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deregister a protocol."]
    #[doc = "@param short_name abbreviated name of the protocol"]
    #[doc = "@return TRUE if protocol is removed"]
    pub fn proto_deregister_protocol(short_name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[doc = " Register a protocol alias."]
    #[doc = "This is for dissectors whose original name has changed, e.g. BOOTP to DHCP."]
    #[doc = "@param proto_id protocol id returned by proto_register_protocol (0-indexed)"]
    #[doc = "@param alias_name alias for the protocol's filter name"]
    pub fn proto_register_alias(
        proto_id: ::std::os::raw::c_int,
        alias_name: *const ::std::os::raw::c_char,
    );
}
#[doc = " This type of function can be registered to get called whenever"]
#[doc = "a given field was not found but a its prefix is matched;"]
#[doc = "It can be used to procrastinate the hf array registration."]
#[doc = "@param match  what's being matched"]
pub type prefix_initializer_t =
    ::std::option::Option<unsafe extern "C" fn(match_: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Register a new prefix for delayed initialization of field arrays"]
    #[doc = "Note that the initializer function MAY NOT be called before the dissector"]
    #[doc = "is first called.  That is, dissectors using this function must be prepared"]
    #[doc = "to call the initializer before beginning dissection; they should do this by"]
    #[doc = "calling proto_registrar_get_byname() on one of the dissector's field names."]
    #[doc = "@param prefix the prefix for the new protocol"]
    #[doc = "@param initializer function that will initialize the field array for the given prefix"]
    pub fn proto_register_prefix(
        prefix: *const ::std::os::raw::c_char,
        initializer: prefix_initializer_t,
    );
}
extern "C" {
    #[doc = " Initialize every remaining uninitialized prefix."]
    pub fn proto_initialize_all_prefixes();
}
extern "C" {
    pub fn proto_register_fields_manual(
        parent: ::std::os::raw::c_int,
        hfi: *mut *mut header_field_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proto_register_fields_section(
        parent: ::std::os::raw::c_int,
        hfi: *mut header_field_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a header_field array."]
    #[doc = "@param parent the protocol handle from proto_register_protocol()"]
    #[doc = "@param hf the hf_register_info array"]
    #[doc = "@param num_records the number of records in hf"]
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Deregister an already registered field."]
    #[doc = "@param parent the protocol handle from proto_register_protocol()"]
    #[doc = "@param hf_id the field to deregister"]
    pub fn proto_deregister_field(parent: ::std::os::raw::c_int, hf_id: gint);
}
extern "C" {
    #[doc = " Add data to be freed when deregistered fields are freed."]
    #[doc = "@param data a pointer to data to free"]
    pub fn proto_add_deregistered_data(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free strings in a field."]
    #[doc = "@param field_type the field type (one of FT_ values)"]
    #[doc = "@param field_display field display value (one of BASE_ values)"]
    #[doc = "@param field_strings field strings"]
    pub fn proto_free_field_strings(
        field_type: ftenum_t,
        field_display: ::std::os::raw::c_uint,
        field_strings: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Free fields deregistered in proto_deregister_field()."]
    pub fn proto_free_deregistered_fields();
}
extern "C" {
    #[doc = " Register a protocol subtree (ett) array."]
    #[doc = "@param indices array of ett indices"]
    #[doc = "@param num_indices the number of records in indices"]
    pub fn proto_register_subtree_array(
        indices: *const *mut gint,
        num_indices: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get name of registered header_field number n."]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return the name of this registered item"]
    pub fn proto_registrar_get_name(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get abbreviation of registered header_field number n."]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return the abbreviation of this registered item"]
    pub fn proto_registrar_get_abbrev(n: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field or protocol id."]
    #[doc = "@param hfindex item # n (0-indexed)"]
    #[doc = "@return the registered item"]
    pub fn proto_registrar_get_nth(hfindex: guint) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field name."]
    #[doc = "@param field_name the field name to search for"]
    #[doc = "@return the registered item"]
    pub fn proto_registrar_get_byname(
        field_name: *const ::std::os::raw::c_char,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field information based upon a field alias."]
    #[doc = "@param alias_name the aliased field name to search for"]
    #[doc = "@return the registered item"]
    pub fn proto_registrar_get_byalias(
        alias_name: *const ::std::os::raw::c_char,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Get the header_field id based upon a field name."]
    #[doc = "@param field_name the field name to search for"]
    #[doc = "@return the field id for the registered item"]
    pub fn proto_registrar_get_id_byname(
        field_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get enum ftenum FT_ of registered header_field number n."]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return the registered item"]
    pub fn proto_registrar_get_ftype(n: ::std::os::raw::c_int) -> ftenum;
}
extern "C" {
    #[doc = " Get parent protocol of registered header_field number n."]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return -1 if item _is_ a protocol"]
    pub fn proto_registrar_get_parent(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is item # n a protocol?"]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return TRUE if it's a protocol, FALSE if it's not"]
    pub fn proto_registrar_is_protocol(n: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Get length of registered field according to field type."]
    #[doc = "@param n item # n (0-indexed)"]
    #[doc = "@return 0 means undeterminable at registration time, -1 means unknown field"]
    pub fn proto_registrar_get_length(n: ::std::os::raw::c_int) -> gint;
}
extern "C" {
    #[doc = " Routines to use to iterate over the protocols and their fields;"]
    #[doc = " they return the item number of the protocol in question or the"]
    #[doc = " appropriate hfinfo pointer, and keep state in \"*cookie\"."]
    pub fn proto_get_first_protocol(
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_data_protocol(cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_next_protocol(
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proto_get_first_protocol_field(
        proto_id: ::std::os::raw::c_int,
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> *mut header_field_info;
}
extern "C" {
    pub fn proto_get_next_protocol_field(
        proto_id: ::std::os::raw::c_int,
        cookie: *mut *mut ::std::os::raw::c_void,
    ) -> *mut header_field_info;
}
extern "C" {
    #[doc = " Check if a protocol name is already registered."]
    #[doc = "@param name the name to search for"]
    #[doc = "@return proto_id"]
    pub fn proto_name_already_registered(name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a protocol's filter_name."]
    #[doc = "@param filter_name the filter name to search for"]
    #[doc = "@return proto_id"]
    pub fn proto_get_id_by_filter_name(filter_name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a protocol's short name."]
    #[doc = "@param short_name the protocol short name to search for"]
    #[doc = "@return proto_id"]
    pub fn proto_get_id_by_short_name(short_name: *const gchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Can item # n decoding be disabled?"]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    #[doc = "@return TRUE if it's a protocol, FALSE if it's not"]
    pub fn proto_can_toggle_protocol(proto_id: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Get the \"protocol_t\" structure for the given protocol's item number."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    pub fn find_protocol_by_id(proto_id: ::std::os::raw::c_int) -> *mut protocol_t;
}
extern "C" {
    #[doc = " Get the protocol's name for the given protocol's item number."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    #[doc = "@return its name"]
    pub fn proto_get_protocol_name(
        proto_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the protocol's item number, for the given protocol's \"protocol_t\"."]
    #[doc = "@return its proto_id"]
    pub fn proto_get_id(protocol: *const protocol_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the protocol's short name, for the given protocol's \"protocol_t\"."]
    #[doc = "@return its short name."]
    pub fn proto_get_protocol_short_name(
        protocol: *const protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the protocol's long name, for the given protocol's \"protocol_t\"."]
    #[doc = "@return its long name."]
    pub fn proto_get_protocol_long_name(
        protocol: *const protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Is protocol's decoding enabled ?"]
    #[doc = "@return TRUE if decoding is enabled, FALSE if not"]
    pub fn proto_is_protocol_enabled(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Is protocol's enabled by default (most are)?"]
    #[doc = "@return TRUE if decoding is enabled by default, FALSE if not"]
    pub fn proto_is_protocol_enabled_by_default(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Is this a protocol in name only (i.e. not a real one)?"]
    #[doc = "@return TRUE if helper, FALSE if not"]
    pub fn proto_is_pino(protocol: *const protocol_t) -> gboolean;
}
extern "C" {
    #[doc = " Get a protocol's filter name by its item number."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    #[doc = "@return its filter name."]
    pub fn proto_get_protocol_filter_name(
        proto_id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Associate a heuristic dissector with a protocol"]
    #[doc = " INTERNAL USE ONLY!!!"]
    #[doc = " @param protocol to associate the heuristic with"]
    #[doc = " @param short_name heuristic dissector's short name"]
    pub fn proto_add_heuristic_dissector(
        protocol: *mut protocol_t,
        short_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Apply func to all heuristic dissectors of a protocol"]
    #[doc = " @param protocol to iterate over heuristics"]
    #[doc = " @param func function to execute on heuristics"]
    #[doc = " @param user_data user-specific data for function"]
    pub fn proto_heuristic_dissector_foreach(
        protocol: *const protocol_t,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Find commonly-used protocols in a layer list."]
    #[doc = " @param layers Protocol layer list"]
    #[doc = " @param is_ip Set to TRUE if the layer list contains IPv4 or IPv6, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_tcp Set to TRUE if the layer list contains TCP, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_udp Set to TRUE if the layer list contains UDP, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_sctp Set to TRUE if the layer list contains SCTP, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_tls Set to TRUE if the layer list contains SSL/TLS, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_rtp Set to TRUE if the layer list contains RTP, otherwise"]
    #[doc = " unchanged. May be NULL."]
    #[doc = " @param is_lte_rlc Set to TRUE if the layer list contains LTE RLC, otherwise"]
    #[doc = " unchanged. May be NULL."]
    pub fn proto_get_frame_protocols(
        layers: *const wmem_list_t,
        is_ip: *mut gboolean,
        is_tcp: *mut gboolean,
        is_udp: *mut gboolean,
        is_sctp: *mut gboolean,
        is_tls: *mut gboolean,
        is_rtp: *mut gboolean,
        is_lte_rlc: *mut gboolean,
    );
}
extern "C" {
    #[doc = " Check whether a protocol, specified by name, is in a layer list."]
    #[doc = " @param layers Protocol layer list"]
    #[doc = " @param proto_name Name of protocol to find"]
    #[doc = " @return TRUE if the protocol is found, FALSE if it isn't"]
    pub fn proto_is_frame_protocol(
        layers: *const wmem_list_t,
        proto_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Mark protocol with the given item number as disabled by default."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    pub fn proto_disable_by_default(proto_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Enable / Disable protocol of the given item number."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    #[doc = "@param enabled enable / disable the protocol"]
    pub fn proto_set_decoding(proto_id: ::std::os::raw::c_int, enabled: gboolean);
}
extern "C" {
    #[doc = " Re-enable all protocols that are not marked as disabled by default."]
    pub fn proto_reenable_all();
}
extern "C" {
    #[doc = " Disable disabling/enabling of protocol of the given item number."]
    #[doc = "@param proto_id protocol id (0-indexed)"]
    pub fn proto_set_cant_toggle(proto_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Checks for existence any protocol or field within a tree."]
    #[doc = "@param tree \"Protocols\" are assumed to be a child of the [empty] root node."]
    #[doc = "@param id hfindex of protocol or field"]
    #[doc = "@return TRUE = found, FALSE = not found"]
    #[doc = "@todo add explanation of id parameter"]
    pub fn proto_check_for_protocol_or_field(
        tree: *const proto_tree,
        id: ::std::os::raw::c_int,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers for all hfindex that appear in"]
    #[doc = "tree. Only works with primed trees, and is fast."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@param hfindex primed hfindex"]
    #[doc = "@return GPtrArray pointer"]
    pub fn proto_get_finfo_ptr_array(
        tree: *const proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return whether we're tracking any interesting fields."]
    #[doc = "Only works with primed trees, and is fast."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@return TRUE if we're tracking interesting fields"]
    pub fn proto_tracking_interesting_fields(tree: *const proto_tree) -> gboolean;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers for all hfindex that appear in"]
    #[doc = "tree. Works with any tree, primed or unprimed, and is slower than"]
    #[doc = "proto_get_finfo_ptr_array because it has to search through the tree."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@param hfindex index of field info of interest"]
    #[doc = "@return GPtrArry pointer"]
    pub fn proto_find_finfo(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointer for first hfindex that appear in"]
    #[doc = "tree. Works with any tree, primed or unprimed, and is slower than"]
    #[doc = "proto_get_finfo_ptr_array because it has to search through the tree."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@param hfindex index of field info of interest"]
    #[doc = "@return GPtrArry pointer"]
    pub fn proto_find_first_finfo(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Return GPtrArray* of field_info pointers containg all hfindexes that appear"]
    #[doc = "in tree."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@return GPtrArry pointer"]
    pub fn proto_all_finfos(tree: *mut proto_tree) -> *mut GPtrArray;
}
extern "C" {
    #[doc = " Dumps a glossary of the protocol registrations to STDOUT"]
    pub fn proto_registrar_dump_protocols();
}
extern "C" {
    #[doc = " Dumps a glossary of the field value strings or true/false strings to STDOUT"]
    pub fn proto_registrar_dump_values();
}
extern "C" {
    #[doc = " Dumps a mapping file for loading tshark output into ElasticSearch"]
    pub fn proto_registrar_dump_elastic(filter: *const gchar);
}
extern "C" {
    #[doc = " Dumps the number of protocol and field registrations to STDOUT."]
    #[doc = "@return FALSE if we pre-allocated enough fields, TRUE otherwise."]
    pub fn proto_registrar_dump_fieldcount() -> gboolean;
}
extern "C" {
    #[doc = " Dumps a glossary of the protocol and field registrations to STDOUT."]
    pub fn proto_registrar_dump_fields();
}
extern "C" {
    #[doc = " Dumps a glossary field types and descriptive names to STDOUT"]
    pub fn proto_registrar_dump_ftypes();
}
extern "C" {
    #[doc = " Get string representation of display field value"]
    #[doc = "@param field_display field display value (one of BASE_ values)"]
    #[doc = "@return string representation of display field value or \"Unknown\" if doesn't exist"]
    pub fn proto_field_display_to_string(
        field_display: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut num_tree_types: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns TRUE if subtrees of that type are to be expanded."]
    pub fn tree_expanded(tree_type: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    #[doc = " Sets if subtrees of that type are to be expanded."]
    pub fn tree_expanded_set(tree_type: ::std::os::raw::c_int, value: gboolean);
}
extern "C" {
    pub fn hfinfo_bitshift(hfinfo: *const header_field_info) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_dissect {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Can we do a \"match selected\" on this field."]
    #[doc = "@param finfo field_info"]
    #[doc = "@param edt epan dissecting"]
    #[doc = "@return TRUE if we can do a \"match selected\" on the field, FALSE otherwise."]
    pub fn proto_can_match_selected(finfo: *mut field_info, edt: *mut epan_dissect) -> gboolean;
}
extern "C" {
    #[doc = " Construct a \"match selected\" display filter string."]
    #[doc = "@param finfo field_info"]
    #[doc = "@param edt epan dissecting"]
    #[doc = "@return the wmem NULL alloced display filter string.  Needs to be freed with wmem_free(NULL, ...)"]
    pub fn proto_construct_match_selected_string(
        finfo: *mut field_info,
        edt: *mut epan_dissect,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Find field from offset in tvb."]
    #[doc = "@param tree tree of interest"]
    #[doc = "@param offset offset in the tvb"]
    #[doc = "@param tvb the tv buffer"]
    #[doc = "@return the corresponding field_info"]
    pub fn proto_find_field_from_offset(
        tree: *mut proto_tree,
        offset: guint,
        tvb: *mut tvbuff_t,
    ) -> *mut field_info;
}
extern "C" {
    #[doc = " Find undecoded bytes in a tree"]
    #[doc = "@param tree tree of interest"]
    #[doc = "@param length the length of the frame"]
    #[doc = "@return an array to be used as bitmap of decoded bytes"]
    pub fn proto_find_undecoded_data(tree: *mut proto_tree, length: guint) -> *mut gchar;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the"]
    #[doc = "bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields"]
    #[doc = "of the bitmask are dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask."]
    #[doc = "The value of the integer containing the bitmask is returned through"]
    #[doc = "a pointer."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the"]
    #[doc = "bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields"]
    #[doc = "of the bitmask are dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@param[out] retval points to a guint64 which will be set"]
    #[doc = "@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask."]
    #[doc = "This has \"filterable\" bitmask header functionality of proto_tree_add_bitmask"]
    #[doc = "with the ability to control what data is appended to the header like"]
    #[doc = "proto_tree_add_bitmask_text"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the"]
    #[doc = "bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields"]
    #[doc = "of the bitmask are dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@param flags bitmask field using BMT_NO_* flags to determine behavior"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask."]
    #[doc = "This has \"filterable\" bitmask header functionality of proto_tree_add_bitmask"]
    #[doc = "with the ability to control what data is appended to the header like"]
    #[doc = "proto_tree_add_bitmask_text"]
    #[doc = "The value of the integer containing the bitmask is returned through"]
    #[doc = "a pointer."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/40/48/56/64 bit integer that describes the"]
    #[doc = "bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields"]
    #[doc = "of the bitmask are dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|40|48|56|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@param flags bitmask field using BMT_NO_* flags to determine behavior"]
    #[doc = "@param[out] retval points to a guint64 which will be set"]
    #[doc = "@return the newly created item, and *retval is set to the decoded value masked/shifted according to bitmask"]
    pub fn proto_tree_add_bitmask_with_flags_ret_uint64(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
        retval: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),"]
    #[doc = "but with a passed in value (presumably because it can't be retrieved directly from tvb)"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields of the"]
    #[doc = "bitmask is dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param value bitmask value"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        value: guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask(),"]
    #[doc = "but with a passed in value (presumably because it can't be retrieved directly from tvb)"]
    #[doc = "This has \"filterable\" bitmask header functionality of proto_tree_add_bitmask_value"]
    #[doc = "with the ability to control what data is appended to the header like"]
    #[doc = "proto_tree_add_bitmask_text"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_hdr an 8/16/24/32/64 bit integer that describes the bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields of the"]
    #[doc = "bitmask is dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32|64}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param value bitmask value"]
    #[doc = "@param flags bitmask field using BMT_NO_* flags to determine behavior"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask_value_with_flags(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        value: guint64,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask. Similar"]
    #[doc = "to proto_tree_add_bitmask(), but with no \"header\" item to group all of the fields"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param len number of bytes of data"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    pub fn proto_tree_add_bitmask_list(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
    );
}
extern "C" {
    #[doc = " This function will dissect a value that describe a bitmask. Similar to proto_tree_add_bitmask_list(),"]
    #[doc = "but with a passed in value (presumably because it can't be retrieved directly from tvb)"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param len number of bytes of data"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer of the same type/size as hf_hdr with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param value bitmask value"]
    pub fn proto_tree_add_bitmask_list_value(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: ::std::os::raw::c_int,
        fields: *mut *const ::std::os::raw::c_int,
        value: guint64,
    );
}
extern "C" {
    #[doc = " This function will dissect a sequence of bytes that describe a bitmask."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param len number of bytes of data"]
    #[doc = "@param hf_hdr an 8/16/24/32 bit integer that describes the bitmask to be dissected."]
    #[doc = "This field will form an expansion under which the individual fields of the"]
    #[doc = "bitmask are dissected and displayed."]
    #[doc = "This field must be of the type FT_[U]INT{8|16|24|32}."]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields an array of pointers to int that lists all the fields of the"]
    #[doc = "bitmask. These fields can be either of the type FT_BOOLEAN for flags"]
    #[doc = "or another integer with a mask specified."]
    #[doc = "This array is terminated by a NULL entry."]
    #[doc = "FT_BOOLEAN bits that are set to 1 will have the name added to the expansion."]
    #[doc = "FT_integer fields that have a value_string attached will have the"]
    #[doc = "matched string displayed on the expansion line."]
    #[doc = "@param exp expert info field used when decodable_len < len.  This also means this function"]
    #[doc = "should be called even when tree == NULL"]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask_len(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        hf_hdr: ::std::os::raw::c_int,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        exp: *mut expert_field,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a text with a subtree of bitfields."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param len length of the field name"]
    #[doc = "@param name field name (NULL if bitfield contents should be used)"]
    #[doc = "@param fallback field name if none of bitfields were usable"]
    #[doc = "@param ett subtree index"]
    #[doc = "@param fields NULL-terminated array of bitfield indexes"]
    #[doc = "@param encoding big or little endian byte representation (ENC_BIG_ENDIAN/ENC_LITTLE_ENDIAN/ENC_HOST_ENDIAN)"]
    #[doc = "@param flags bitmask field"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bitmask_text(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        len: guint,
        name: *const ::std::os::raw::c_char,
        fallback: *const ::std::os::raw::c_char,
        ett: gint,
        fields: *mut *const ::std::os::raw::c_int,
        encoding: guint,
        flags: ::std::os::raw::c_int,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item."]
    #[doc = "The item is extracted from the tvbuff handed to it."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index. Fields for use with this function should have bitmask==0."]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bits"]
    #[doc = "@param encoding data encoding"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bits_item(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item."]
    #[doc = "  The item is extracted from the tvbuff handed to it as a set"]
    #[doc = "  of crumbs (segments) of contiguous bits, specified by an"]
    #[doc = "  array of crumb_spec elements.  The crumbs are assembled to"]
    #[doc = "  create the value.  There may be any number of crumbs"]
    #[doc = "  specifying up to a total of 64 bits which may occur anywhere"]
    #[doc = "  within the tvb. If the span of the crumbs within the tvb is 4"]
    #[doc = "  octets or less, a bitmap of the crumbs is produced."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index. Fields for use with this function should have bitmask==0."]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset of the first crumb in tvb expressed in bits"]
    #[doc = "@param crumb_spec pointer to crumb_spec array"]
    #[doc = "@param return_value if a pointer is passed here the value is returned."]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_split_bits_item_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        return_value: *mut guint64,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bitmap text for a split-bits crumb to a proto_tree,"]
    #[doc = "  using the text label registered to an item. The bitmap is"]
    #[doc = "  extracted from the tvbuff handed to it as a crumb (segment)"]
    #[doc = "  of contiguous bits, specified by one of an array of"]
    #[doc = "  crumb_spec elements. This function is normally called once"]
    #[doc = "  per crumb, after the call to"]
    #[doc = "proto_tree_add_split_bits_item_ret_val"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index. Fields for use with this function should have bitmask==0."]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset of the first crumb in tvb expressed in bits"]
    #[doc = "@param crumb_spec pointer to crumb_spec array"]
    #[doc = "@param crumb_index into the crumb_spec array for this crumb"]
    pub fn proto_tree_add_split_bits_crumb(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        crumb_spec: *const crumb_spec_t,
        crumb_index: guint16,
    );
}
extern "C" {
    #[doc = " Add bits to a proto_tree, using the text label registered to that item."]
    #[doc = "The item is extracted from the tvbuff handed to it."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index. Fields for use with this function should have bitmask==0."]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bits"]
    #[doc = "@param return_value if a pointer is passed here the value is returned."]
    #[doc = "@param encoding data encoding"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_bits_ret_val(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        return_value: *mut guint64,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_uint64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_BOOLEAN header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_boolean_bits_format_value64(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: guint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_INT8, FT_INT16, FT_INT24 or FT_INT32"]
    #[doc = "header field to a proto_tree, with the format generating the"]
    #[doc = "string for the value and with the field name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_int64_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: gint64,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add bits for a FT_FLOAT header field to a proto_tree, with"]
    #[doc = "the format generating the string for the value and with the field"]
    #[doc = "name being included automatically."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hf_index field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_bits length of data in tvb expressed in bit"]
    #[doc = "@param value data to display"]
    #[doc = "@param format printf like format string"]
    #[doc = "@param ... printf like parameters"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_float_bits_format_value(
        tree: *mut proto_tree,
        hf_index: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_bits: gint,
        value: f32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_3GPP_TS_23_038_7BITS encoding to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_chars number of 7bits characters to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ts_23_038_7bits_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a FT_STRING with ENC_ASCII_7BITS encoding to a proto_tree."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param hfindex field index"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param bit_offset start of data in tvb expressed in bits"]
    #[doc = "@param no_of_chars number of 7bits characters to display"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_ascii_7bits_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        bit_offset: guint,
        no_of_chars: gint,
    ) -> *mut proto_item;
}
extern "C" {
    #[doc = " Add a checksum filed to a proto_tree."]
    #[doc = "This standardizes the display of a checksum field as well as any"]
    #[doc = "status and expert info supporting it."]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param tvb the tv buffer of the current data"]
    #[doc = "@param offset start of data in tvb"]
    #[doc = "@param hf_checksum checksum field index"]
    #[doc = "@param hf_checksum_status optional checksum status field index.  If none"]
    #[doc = "exists, just pass -1"]
    #[doc = "@param bad_checksum_expert optional expert info for a bad checksum.  If"]
    #[doc = "none exists, just pass NULL"]
    #[doc = "@param pinfo Packet info used for optional expert info.  If unused, NULL can"]
    #[doc = "be passed"]
    #[doc = "@param computed_checksum Checksum to verify against"]
    #[doc = "@param encoding data encoding of checksum from tvb"]
    #[doc = "@param flags bitmask field of PROTO_CHECKSUM_ options"]
    #[doc = "@return the newly created item"]
    pub fn proto_tree_add_checksum(
        tree: *mut proto_tree,
        tvb: *mut tvbuff_t,
        offset: guint,
        hf_checksum: ::std::os::raw::c_int,
        hf_checksum_status: ::std::os::raw::c_int,
        bad_checksum_expert: *mut expert_field,
        pinfo: *mut packet_info,
        computed_checksum: guint32,
        encoding: guint,
        flags: guint,
    ) -> *mut proto_item;
}
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_BAD: proto_checksum_enum_e = 0;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_GOOD: proto_checksum_enum_e = 1;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_UNVERIFIED: proto_checksum_enum_e = 2;
pub const proto_checksum_enum_e_PROTO_CHECKSUM_E_NOT_PRESENT: proto_checksum_enum_e = 3;
pub type proto_checksum_enum_e = i32;
extern "C" {
    pub static mut proto_checksum_vals: [value_string; 0usize];
}
extern "C" {
    #[doc = " Check if given string is a valid field name"]
    #[doc = "@param field_name the field name to check"]
    #[doc = "@return 0 if valid, else first illegal character"]
    pub fn proto_check_field_name(field_name: *const gchar) -> guchar;
}
extern "C" {
    #[doc = " Check if given string is a valid field name"]
    #[doc = "@param tree the tree to append this item to"]
    #[doc = "@param field_id the field id used for custom column"]
    #[doc = "@param occurrence the occurrence of the field used for custom column"]
    #[doc = "@param result the buffer to fill with the field string"]
    #[doc = "@param expr the filter expression"]
    #[doc = "@param size the size of the string buffer"]
    pub fn proto_custom_set(
        tree: *mut proto_tree,
        field_id: *mut GSList,
        occurrence: gint,
        result: *mut gchar,
        expr: *mut gchar,
        size: ::std::os::raw::c_int,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct enum_val_t {
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub value: gint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range_admin_tag {
    pub low: guint32,
    pub high: guint32,
}
pub type range_admin_t = range_admin_tag;
#[doc = " user specified range(s)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_range {
    #[doc = "< number of entries in ranges"]
    pub nranges: guint,
    #[doc = "< variable-length array"]
    pub ranges: [range_admin_t; 1usize],
}
#[doc = " user specified range(s)"]
pub type range_t = epan_range;
pub const convert_ret_t_CVT_NO_ERROR: convert_ret_t = 0;
pub const convert_ret_t_CVT_SYNTAX_ERROR: convert_ret_t = 1;
pub const convert_ret_t_CVT_NUMBER_TOO_BIG: convert_ret_t = 2;
#[doc = " Return value from range_convert_str()."]
pub type convert_ret_t = i32;
extern "C" {
    pub fn range_empty(scope: *mut wmem_allocator_t) -> *mut range_t;
}
extern "C" {
    #[doc = " Converts a range string to a fast comparable array of ranges."]
    #[doc = " This function allocates a range_t large enough to hold the number"]
    #[doc = " of ranges specified, and fills the array range->ranges containing"]
    #[doc = " low and high values with the number of ranges being range->nranges."]
    #[doc = " After having called this function, the function value_is_in_range()"]
    #[doc = " determines whether a given number is within the range or not.<BR>"]
    #[doc = " In case of a single number, we make a range where low is equal to high."]
    #[doc = " We take care on wrongly entered ranges; opposite order will be taken"]
    #[doc = " care of."]
    #[doc = ""]
    #[doc = " The following syntax is accepted :"]
    #[doc = ""]
    #[doc = "   1-20,30-40     Range from 1 to 20, and packets 30 to 40"]
    #[doc = "   -20,30         Range from 1 to 20, and packet 30"]
    #[doc = "   20,30,40-      20, 30, and the range from 40 to the end"]
    #[doc = "   20-10,30-25    Range from 10 to 20, and from 25 to 30"]
    #[doc = "   -              All values"]
    #[doc = " @param scope memory scope for the range"]
    #[doc = " @param range the range"]
    #[doc = " @param es points to the string to be converted."]
    #[doc = " @param max_value specifies the maximum value in a range."]
    #[doc = " @return convert_ret_t"]
    pub fn range_convert_str(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        es: *const gchar,
        max_value: guint32,
    ) -> convert_ret_t;
}
extern "C" {
    pub fn range_convert_str_work(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        es: *const gchar,
        max_value: guint32,
        err_on_max: gboolean,
    ) -> convert_ret_t;
}
extern "C" {
    #[doc = " This function returns TRUE if a given value is within one of the ranges"]
    #[doc = " stored in the ranges array."]
    #[doc = " @param range the range"]
    #[doc = " @param val the value to check"]
    #[doc = " @return TRUE if the value is in range"]
    pub fn value_is_in_range(range: *mut range_t, val: guint32) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if val has successfully been added to"]
    #[doc = " a range.  This may extend an existing range or create a new one"]
    #[doc = " @param scope memory scope of range (in case of reallocation)"]
    #[doc = " @param range to add value"]
    #[doc = " @param val value to add to range"]
    #[doc = " @return TRUE if the value is successsfully added to range"]
    pub fn range_add_value(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        val: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if val has successfully been removed from"]
    #[doc = " a range.  This may remove an existing range."]
    #[doc = " @param scope memory scope of range (in case of reallocation)"]
    #[doc = " @param range to remove value"]
    #[doc = " @param val value to remove within range"]
    #[doc = " @return TRUE if the value is successsfully removed to range"]
    pub fn range_remove_value(
        scope: *mut wmem_allocator_t,
        range: *mut *mut range_t,
        val: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " This function returns TRUE if the two given range_t's are equal."]
    #[doc = " @param a first range"]
    #[doc = " @param b second range"]
    #[doc = " @return TRUE if the value is in range"]
    pub fn ranges_are_equal(a: *mut range_t, b: *mut range_t) -> gboolean;
}
extern "C" {
    #[doc = " This function calls the provided callback function for each value in"]
    #[doc = " in the range. Takes a pointer argument, which is passed to the"]
    #[doc = " callback, along with the value in the range."]
    #[doc = " @param range the range"]
    #[doc = " @param callback the callback function"]
    #[doc = " @param ptr pointer passed to the callback"]
    pub fn range_foreach(
        range: *mut range_t,
        callback: ::std::option::Option<unsafe extern "C" fn(val: guint32, ptr: gpointer)>,
        ptr: gpointer,
    );
}
extern "C" {
    #[doc = " This function converts a range_t to a (wmem_alloc()-allocated) string."]
    pub fn range_convert_range(
        scope: *mut wmem_allocator_t,
        range: *const range_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a (wmem-alloc()ed) copy of a range"]
    #[doc = " @param scope memory scope for the copied range"]
    #[doc = " @param src the range to copy"]
    #[doc = " @return ep allocated copy of the range"]
    pub fn range_copy(scope: *mut wmem_allocator_t, src: *mut range_t) -> *mut range_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct color_t {
    pub red: guint16,
    pub green: guint16,
    pub blue: guint16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_uat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_addr_resolve {
    _unused: [u8; 0],
}
extern "C" {
    pub fn string_to_name_resolve(
        string: *const ::std::os::raw::c_char,
        name_resolve: *mut _e_addr_resolve,
    ) -> ::std::os::raw::c_char;
}
pub const layout_type_e_layout_unused: layout_type_e = 0;
pub const layout_type_e_layout_type_5: layout_type_e = 1;
pub const layout_type_e_layout_type_2: layout_type_e = 2;
pub const layout_type_e_layout_type_1: layout_type_e = 3;
pub const layout_type_e_layout_type_4: layout_type_e = 4;
pub const layout_type_e_layout_type_3: layout_type_e = 5;
pub const layout_type_e_layout_type_6: layout_type_e = 6;
pub const layout_type_e_layout_type_max: layout_type_e = 7;
pub type layout_type_e = i32;
pub const layout_pane_content_e_layout_pane_content_none: layout_pane_content_e = 0;
pub const layout_pane_content_e_layout_pane_content_plist: layout_pane_content_e = 1;
pub const layout_pane_content_e_layout_pane_content_pdetails: layout_pane_content_e = 2;
pub const layout_pane_content_e_layout_pane_content_pbytes: layout_pane_content_e = 3;
pub type layout_pane_content_e = i32;
pub const console_open_e_console_open_never: console_open_e = 0;
pub const console_open_e_console_open_auto: console_open_e = 1;
pub const console_open_e_console_open_always: console_open_e = 2;
pub type console_open_e = i32;
pub const version_info_e_version_welcome_only: version_info_e = 0;
pub const version_info_e_version_title_only: version_info_e = 1;
pub const version_info_e_version_both: version_info_e = 2;
pub const version_info_e_version_neither: version_info_e = 3;
pub type version_info_e = i32;
pub const pref_source_t_pref_default: pref_source_t = 0;
pub const pref_source_t_pref_stashed: pref_source_t = 1;
pub const pref_source_t_pref_current: pref_source_t = 2;
pub type pref_source_t = i32;
pub const elide_mode_e_ELIDE_LEFT: elide_mode_e = 0;
pub const elide_mode_e_ELIDE_RIGHT: elide_mode_e = 1;
pub const elide_mode_e_ELIDE_MIDDLE: elide_mode_e = 2;
pub const elide_mode_e_ELIDE_NONE: elide_mode_e = 3;
pub type elide_mode_e = i32;
pub const software_update_channel_e_UPDATE_CHANNEL_DEVELOPMENT: software_update_channel_e = 0;
pub const software_update_channel_e_UPDATE_CHANNEL_STABLE: software_update_channel_e = 1;
pub type software_update_channel_e = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _e_prefs {
    pub col_list: *mut GList,
    pub num_cols: gint,
    pub st_client_fg: color_t,
    pub st_client_bg: color_t,
    pub st_server_fg: color_t,
    pub st_server_bg: color_t,
    pub gui_text_valid: color_t,
    pub gui_text_invalid: color_t,
    pub gui_text_deprecated: color_t,
    pub restore_filter_after_following_stream: gboolean,
    pub gui_toolbar_main_style: gint,
    pub gui_qt_font_name: *mut gchar,
    pub gui_active_fg: color_t,
    pub gui_active_bg: color_t,
    pub gui_active_style: gint,
    pub gui_inactive_fg: color_t,
    pub gui_inactive_bg: color_t,
    pub gui_inactive_style: gint,
    pub gui_marked_fg: color_t,
    pub gui_marked_bg: color_t,
    pub gui_ignored_fg: color_t,
    pub gui_ignored_bg: color_t,
    pub gui_colorized_fg: *mut gchar,
    pub gui_colorized_bg: *mut gchar,
    pub gui_geometry_save_position: gboolean,
    pub gui_geometry_save_size: gboolean,
    pub gui_geometry_save_maximized: gboolean,
    pub gui_console_open: console_open_e,
    pub gui_recent_df_entries_max: guint,
    pub gui_recent_files_count_max: guint,
    pub gui_fileopen_style: guint,
    pub gui_fileopen_dir: *mut gchar,
    pub gui_fileopen_preview: guint,
    pub gui_ask_unsaved: gboolean,
    pub gui_autocomplete_filter: gboolean,
    pub gui_find_wrap: gboolean,
    pub gui_window_title: *mut gchar,
    pub gui_prepend_window_title: *mut gchar,
    pub gui_start_title: *mut gchar,
    pub gui_version_placement: version_info_e,
    pub gui_max_export_objects: guint,
    pub gui_layout_type: layout_type_e,
    pub gui_layout_content_1: layout_pane_content_e,
    pub gui_layout_content_2: layout_pane_content_e,
    pub gui_layout_content_3: layout_pane_content_e,
    pub gui_interfaces_hide_types: *mut gchar,
    pub gui_interfaces_show_hidden: gboolean,
    pub gui_interfaces_remote_display: gboolean,
    pub console_log_level: gint,
    pub capture_device: *mut gchar,
    pub capture_devices_linktypes: *mut gchar,
    pub capture_devices_descr: *mut gchar,
    pub capture_devices_hide: *mut gchar,
    pub capture_devices_monitor_mode: *mut gchar,
    pub capture_devices_buffersize: *mut gchar,
    pub capture_devices_snaplen: *mut gchar,
    pub capture_devices_pmode: *mut gchar,
    pub capture_devices_filter: *mut gchar,
    pub capture_prom_mode: gboolean,
    pub capture_pcap_ng: gboolean,
    pub capture_real_time: gboolean,
    pub capture_auto_scroll: gboolean,
    pub capture_no_interface_load: gboolean,
    pub capture_no_extcap: gboolean,
    pub capture_show_info: gboolean,
    pub capture_columns: *mut GList,
    pub tap_update_interval: guint,
    pub display_hidden_proto_items: gboolean,
    pub display_byte_fields_with_spaces: gboolean,
    pub enable_incomplete_dissectors_check: gboolean,
    pub incomplete_dissectors_check_debug: gboolean,
    pub strict_conversation_tracking_heuristics: gboolean,
    pub filter_expressions_old: gboolean,
    pub gui_update_enabled: gboolean,
    pub gui_update_channel: software_update_channel_e,
    pub gui_update_interval: gint,
    pub saved_at_version: *mut gchar,
    pub unknown_prefs: gboolean,
    pub unknown_colorfilters: gboolean,
    pub gui_qt_packet_list_separator: gboolean,
    pub gui_qt_packet_header_column_definition: gboolean,
    pub gui_qt_show_selected_packet: gboolean,
    pub gui_qt_show_file_load_time: gboolean,
    pub gui_packet_editor: gboolean,
    pub gui_packet_list_elide_mode: elide_mode_e,
    pub gui_packet_list_show_related: gboolean,
    pub gui_packet_list_show_minimap: gboolean,
    pub st_enable_burstinfo: gboolean,
    pub st_burst_showcount: gboolean,
    pub st_burst_resolution: gint,
    pub st_burst_windowlen: gint,
    pub st_sort_casesensitve: gboolean,
    pub st_sort_rng_fixorder: gboolean,
    pub st_sort_rng_nameonly: gboolean,
    pub st_sort_defcolflag: gint,
    pub st_sort_defdescending: gboolean,
    pub st_sort_showfullname: gboolean,
    pub extcap_save_on_start: gboolean,
}
pub type e_prefs = _e_prefs;
extern "C" {
    pub static mut prefs: e_prefs;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pref_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pref_custom_cbs {
    _unused: [u8; 0],
}
pub type module_t = pref_module;
extern "C" {
    #[doc = " Sets up memory used by proto routines. Called at program startup"]
    pub fn prefs_init();
}
extern "C" {
    #[doc = " Reset preferences to default values.  Called at profile change"]
    pub fn prefs_reset();
}
extern "C" {
    #[doc = " Frees memory used by proto routines. Called at program shutdown"]
    pub fn prefs_cleanup();
}
extern "C" {
    #[doc = " Provide a hint about the darkness of the current UI theme so that we can adjust colors when needed"]
    pub fn prefs_set_gui_theme_is_dark(is_dark: gboolean);
}
extern "C" {
    pub fn prefs_register_protocol(
        id: ::std::os::raw::c_int,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    pub fn prefs_register_module_alias(name: *const ::std::os::raw::c_char, module: *mut module_t);
}
extern "C" {
    #[doc = " Deregister preferences from a protocol."]
    pub fn prefs_deregister_protocol(id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn prefs_register_stat(
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    pub fn prefs_register_codec(
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    pub fn prefs_register_protocol_subtree(
        subtree: *const ::std::os::raw::c_char,
        id: ::std::os::raw::c_int,
        apply_cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> *mut module_t;
}
extern "C" {
    pub fn prefs_register_protocol_obsolete(id: ::std::os::raw::c_int) -> *mut module_t;
}
pub type module_cb = ::std::option::Option<
    unsafe extern "C" fn(module: *mut module_t, user_data: gpointer) -> guint,
>;
extern "C" {
    pub fn prefs_module_has_submodules(module: *mut module_t) -> gboolean;
}
extern "C" {
    pub fn prefs_modules_foreach(callback: module_cb, user_data: gpointer) -> guint;
}
extern "C" {
    pub fn prefs_modules_foreach_submodules(
        module: *mut module_t,
        callback: module_cb,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn prefs_apply_all();
}
extern "C" {
    pub fn prefs_apply(module: *mut module_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct preference {
    _unused: [u8; 0],
}
pub type pref_t = preference;
extern "C" {
    pub fn prefs_is_registered_protocol(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn prefs_get_title_by_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given a module name, return a pointer to its pref_module struct,"]
    #[doc = " or NULL if it's not found."]
    #[doc = ""]
    #[doc = " @param name The preference module name.  Usually the same as the protocol"]
    #[doc = " name, e.g. \"tcp\"."]
    #[doc = " @return A pointer to the corresponding preference module, or NULL if it"]
    #[doc = " wasn't found."]
    pub fn prefs_find_module(name: *const ::std::os::raw::c_char) -> *mut module_t;
}
extern "C" {
    #[doc = " Given a module name, and a preference name return a pointer to the given"]
    #[doc = " module's given preference or NULL if it's not found."]
    #[doc = ""]
    #[doc = " @param module The preference module name.  Usually the same as the protocol"]
    #[doc = " name, e.g. \"tcp\"."]
    #[doc = " @param pref The preference name, e.g. \"desegment\"."]
    #[doc = " @return A pointer to the corresponding preference, or NULL if it"]
    #[doc = " wasn't found."]
    pub fn prefs_find_preference(
        module: *mut module_t,
        pref: *const ::std::os::raw::c_char,
    ) -> *mut pref_t;
}
extern "C" {
    pub fn prefs_register_uint_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        base: guint,
        var: *mut guint,
    );
}
extern "C" {
    pub fn prefs_register_bool_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut gboolean,
    );
}
extern "C" {
    pub fn prefs_register_enum_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut gint,
        enumvals: *const enum_val_t,
        radio_buttons: gboolean,
    );
}
extern "C" {
    pub fn prefs_register_string_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn prefs_register_filename_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
        for_writing: gboolean,
    );
}
extern "C" {
    pub fn prefs_register_directory_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn prefs_register_range_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *mut range_t,
        max_value: guint32,
    );
}
extern "C" {
    pub fn prefs_register_static_text_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn prefs_register_uat_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        uat: *mut epan_uat,
    );
}
extern "C" {
    pub fn prefs_register_uat_preference_qt(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        uat: *mut epan_uat,
    );
}
extern "C" {
    pub fn prefs_register_color_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        color: *mut color_t,
    );
}
extern "C" {
    pub fn prefs_register_custom_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        custom_cbs: *mut pref_custom_cbs,
        custom_data: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn prefs_register_decode_as_range_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut *mut range_t,
        max_value: guint32,
    );
}
extern "C" {
    pub fn prefs_register_decode_as_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        var: *mut guint,
    );
}
extern "C" {
    pub fn prefs_register_obsolete_preference(
        module: *mut module_t,
        name: *const ::std::os::raw::c_char,
    );
}
pub type pref_cb =
    ::std::option::Option<unsafe extern "C" fn(pref: *mut pref_t, user_data: gpointer) -> guint>;
extern "C" {
    pub fn prefs_pref_foreach(
        module: *mut module_t,
        callback: pref_cb,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn prefs_get_string_list(str: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn prefs_clear_string_list(sl: *mut GList);
}
extern "C" {
    #[doc = " Fetch a short preference type name, e.g. \"Integer\"."]
    #[doc = ""]
    #[doc = " @param pref A preference."]
    #[doc = ""]
    #[doc = " @return The preference type name. May be NULL."]
    pub fn prefs_pref_type_name(pref: *mut pref_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch a long description of the preference type"]
    #[doc = ""]
    #[doc = " @param pref A preference."]
    #[doc = ""]
    #[doc = " @return A description of the preference type including allowed"]
    #[doc = " values for enums. The description may include newlines. Must be"]
    #[doc = " g_free()d."]
    pub fn prefs_pref_type_description(pref: *mut pref_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fetch a string representation of the preference."]
    #[doc = ""]
    #[doc = " @param pref A preference."]
    #[doc = " @param source Which value of the preference to return, see pref_source_t."]
    #[doc = ""]
    #[doc = " @return A string representation of the preference. Must be g_free()d."]
    pub fn prefs_pref_to_str(
        pref: *mut pref_t,
        source: pref_source_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn read_prefs() -> *mut e_prefs;
}
extern "C" {
    pub fn write_prefs(arg1: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub const prefs_set_pref_e_PREFS_SET_OK: prefs_set_pref_e = 0;
pub const prefs_set_pref_e_PREFS_SET_SYNTAX_ERR: prefs_set_pref_e = 1;
pub const prefs_set_pref_e_PREFS_SET_NO_SUCH_PREF: prefs_set_pref_e = 2;
pub const prefs_set_pref_e_PREFS_SET_OBSOLETE: prefs_set_pref_e = 3;
#[doc = " Result of setting a preference."]
pub type prefs_set_pref_e = i32;
extern "C" {
    pub fn prefs_set_pref(
        prefarg: *mut ::std::os::raw::c_char,
        errmsg: *mut *mut ::std::os::raw::c_char,
    ) -> prefs_set_pref_e;
}
extern "C" {
    pub fn prefs_get_preference_obsolete(pref: *mut pref_t) -> gboolean;
}
extern "C" {
    pub fn prefs_set_preference_obsolete(pref: *mut pref_t) -> prefs_set_pref_e;
}
extern "C" {
    pub fn prefs_get_uint_value(
        module_name: *const ::std::os::raw::c_char,
        pref_name: *const ::std::os::raw::c_char,
    ) -> guint;
}
extern "C" {
    pub fn prefs_get_range_value(
        module_name: *const ::std::os::raw::c_char,
        pref_name: *const ::std::os::raw::c_char,
    ) -> *mut range_t;
}
extern "C" {
    pub fn prefs_is_capture_device_hidden(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn prefs_capture_device_monitor_mode(name: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn prefs_capture_options_dialog_column_is_visible(column: *const gchar) -> gboolean;
}
extern "C" {
    pub fn prefs_has_layout_pane_content(layout_pane_content: layout_pane_content_e) -> gboolean;
}
extern "C" {
    pub static mut wireshark_abort_on_dissector_bug: gboolean;
}
pub type epan_dissect_t = epan_dissect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_dfilter {
    _unused: [u8; 0],
}
#[doc = "  Helper routines for column utility structures and routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
#[doc = " Opaque structure provided when an epan_t is created; it contains"]
#[doc = " information needed to allow the user of libwireshark to provide"]
#[doc = " time stamps, comments, and other information outside the packet"]
#[doc = " data itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_provider_data {
    _unused: [u8; 0],
}
#[doc = " Structure containing pointers to functions supplied by the user"]
#[doc = " of libwireshark."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_provider_funcs {
    pub get_frame_ts: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            frame_num: guint32,
        ) -> *const nstime_t,
    >,
    pub get_interface_name: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            interface_id: guint32,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_interface_description: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            interface_id: guint32,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub get_user_comment: ::std::option::Option<
        unsafe extern "C" fn(
            prov: *mut packet_provider_data,
            fd: *const frame_data,
        ) -> *const ::std::os::raw::c_char,
    >,
}
extern "C" {
    pub static mut libwireshark_plugins: *mut plugins_t;
}
extern "C" {
    #[doc = " Init the whole epan module."]
    #[doc = ""]
    #[doc = " Must be called only once in a program."]
    #[doc = ""]
    #[doc = " Returns TRUE on success, FALSE on failure."]
    pub fn epan_init(
        cb: register_cb,
        client_data: *mut ::std::os::raw::c_void,
        load_plugins: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Load all settings, from the current profile, that affect epan."]
    pub fn epan_load_settings() -> *mut e_prefs;
}
extern "C" {
    #[doc = " cleanup the whole epan module, this is used to be called only once in a program"]
    pub fn epan_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_plugin {
    pub init: ::std::option::Option<unsafe extern "C" fn()>,
    pub dissect_init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut epan_dissect_t)>,
    pub dissect_cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut epan_dissect_t)>,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_all_protocols:
        ::std::option::Option<unsafe extern "C" fn(arg1: register_cb, arg2: gpointer)>,
    pub register_all_handoffs:
        ::std::option::Option<unsafe extern "C" fn(arg1: register_cb, arg2: gpointer)>,
    pub register_all_tap_listeners: ::std::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub fn epan_register_plugin(plugin: *const epan_plugin);
}
extern "C" {
    #[doc = " Initialize the table of conversations.  Conversations are identified by"]
    #[doc = " their endpoints; they are used for protocols such as IP, TCP, and UDP,"]
    #[doc = " where packets contain endpoint information but don't contain a single"]
    #[doc = " value indicating to which flow the packet belongs."]
    pub fn epan_conversation_init();
}
#[doc = " A client will create one epan_t for an entire dissection session."]
#[doc = " A single epan_t will be used to analyze the entire sequence of packets,"]
#[doc = " sequentially, in a single session. A session corresponds to a single"]
#[doc = " packet trace file. The reasons epan_t exists is that some packets in"]
#[doc = " some protocols cannot be decoded without knowledge of previous packets."]
#[doc = " This inter-packet \"state\" is stored in the epan_t."]
pub type epan_t = epan_session;
extern "C" {
    pub fn epan_new(
        prov: *mut packet_provider_data,
        funcs: *const packet_provider_funcs,
    ) -> *mut epan_t;
}
extern "C" {
    pub fn epan_get_user_comment(
        session: *const epan_t,
        fd: *const frame_data,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn epan_get_interface_name(
        session: *const epan_t,
        interface_id: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn epan_get_interface_description(
        session: *const epan_t,
        interface_id: guint32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn epan_get_frame_ts(session: *const epan_t, frame_num: guint32) -> *const nstime_t;
}
extern "C" {
    pub fn epan_free(session: *mut epan_t);
}
extern "C" {
    pub fn epan_get_version() -> *const gchar;
}
extern "C" {
    pub fn epan_get_version_number(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        micro: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set/unset the tree to always be visible when epan_dissect_init() is called."]
    #[doc = " This state change sticks until cleared, rather than being done per function call."]
    #[doc = " This is currently used when Lua scripts request all fields be generated."]
    #[doc = " By default it only becomes visible if epan_dissect_init() makes it so, usually"]
    #[doc = " only when a packet is selected."]
    #[doc = " Setting this overrides that so it's always visible, although it will still not be"]
    #[doc = " created if create_proto_tree is false in the call to epan_dissect_init()."]
    #[doc = " Clearing this reverts the decision to epan_dissect_init() and proto_tree_visible."]
    pub fn epan_set_always_visible(force: gboolean);
}
extern "C" {
    #[doc = " initialize an existing single packet dissection"]
    pub fn epan_dissect_init(
        edt: *mut epan_dissect_t,
        session: *mut epan_t,
        create_proto_tree: gboolean,
        proto_tree_visible: gboolean,
    );
}
extern "C" {
    #[doc = " get a new single packet dissection"]
    #[doc = " should be freed using epan_dissect_free() after packet dissection completed"]
    pub fn epan_dissect_new(
        session: *mut epan_t,
        create_proto_tree: gboolean,
        proto_tree_visible: gboolean,
    ) -> *mut epan_dissect_t;
}
extern "C" {
    pub fn epan_dissect_reset(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " Indicate whether we should fake protocols or not"]
    pub fn epan_dissect_fake_protocols(edt: *mut epan_dissect_t, fake_protocols: gboolean);
}
extern "C" {
    #[doc = " run a single packet dissection"]
    pub fn epan_dissect_run(
        edt: *mut epan_dissect_t,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    pub fn epan_dissect_run_with_taps(
        edt: *mut epan_dissect_t,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    #[doc = " run a single file packet dissection"]
    pub fn epan_dissect_file_run(
        edt: *mut epan_dissect_t,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    pub fn epan_dissect_file_run_with_taps(
        edt: *mut epan_dissect_t,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut epan_column_info,
    );
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree using the fields/protocols used in a dfilter."]
    pub fn epan_dissect_prime_with_dfilter(edt: *mut epan_dissect_t, dfcode: *const epan_dfilter);
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree with a field/protocol specified by its hfid"]
    pub fn epan_dissect_prime_with_hfid(edt: *mut epan_dissect_t, hfid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Prime an epan_dissect_t's proto_tree with a set of fields/protocols specified by their hfids in a GArray"]
    pub fn epan_dissect_prime_with_hfid_array(edt: *mut epan_dissect_t, hfids: *mut GArray);
}
extern "C" {
    #[doc = " fill the dissect run output into the packet list columns"]
    pub fn epan_dissect_fill_in_columns(
        edt: *mut epan_dissect_t,
        fill_col_exprs: gboolean,
        fill_fd_colums: gboolean,
    );
}
extern "C" {
    #[doc = " Check whether a dissected packet contains a given named field"]
    pub fn epan_dissect_packet_contains_field(
        edt: *mut epan_dissect_t,
        field_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " releases resources attached to the packet dissection. DOES NOT free the actual pointer"]
    pub fn epan_dissect_cleanup(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " free a single packet dissection"]
    pub fn epan_dissect_free(edt: *mut epan_dissect_t);
}
extern "C" {
    #[doc = " Sets custom column"]
    pub fn epan_custom_set(
        edt: *mut epan_dissect_t,
        ids: *mut GSList,
        occurrence: gint,
        result: *mut gchar,
        expr: *mut gchar,
        size: ::std::os::raw::c_int,
    ) -> *const gchar;
}
extern "C" {
    #[doc = " Get compile-time information for libraries used by libwireshark."]
    pub fn epan_get_compiled_version_info(str: *mut GString);
}
extern "C" {
    #[doc = " Get runtime information for libraries used by libwireshark."]
    pub fn epan_get_runtime_version_info(str: *mut GString);
}
pub type column_info = epan_column_info;
#[doc = "< 0) 802.1Q vlan ID"]
pub const COL_8021Q_VLAN_ID: _bindgen_ty_1 = 0;
#[doc = "< 1) Absolute date, as YYYY-MM-DD, and time"]
pub const COL_ABS_YMD_TIME: _bindgen_ty_1 = 1;
#[doc = "< 2) Absolute date, as YYYY/DOY, and time"]
pub const COL_ABS_YDOY_TIME: _bindgen_ty_1 = 2;
#[doc = "< 3) Absolute time"]
pub const COL_ABS_TIME: _bindgen_ty_1 = 3;
#[doc = "< 4) VSAN - Cisco MDS-specific"]
pub const COL_VSAN: _bindgen_ty_1 = 4;
#[doc = "< 5) Cumulative number of bytes"]
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_1 = 5;
#[doc = "< 6) Custom column (any filter name's contents)"]
pub const COL_CUSTOM: _bindgen_ty_1 = 6;
#[doc = "< 7) DCE/RPC connection oriented call id OR datagram sequence number"]
pub const COL_DCE_CALL: _bindgen_ty_1 = 7;
#[doc = "< 8) Delta time"]
pub const COL_DELTA_TIME: _bindgen_ty_1 = 8;
#[doc = "< 9) Delta time displayed"]
pub const COL_DELTA_TIME_DIS: _bindgen_ty_1 = 9;
#[doc = "< 10) Resolved dest"]
pub const COL_RES_DST: _bindgen_ty_1 = 10;
#[doc = "< 11) Unresolved dest"]
pub const COL_UNRES_DST: _bindgen_ty_1 = 11;
#[doc = "< 12) Resolved dest port"]
pub const COL_RES_DST_PORT: _bindgen_ty_1 = 12;
#[doc = "< 13) Unresolved dest port"]
pub const COL_UNRES_DST_PORT: _bindgen_ty_1 = 13;
#[doc = "< 14) Destination address"]
pub const COL_DEF_DST: _bindgen_ty_1 = 14;
#[doc = "< 15) Destination port"]
pub const COL_DEF_DST_PORT: _bindgen_ty_1 = 15;
#[doc = "< 16) Expert Info"]
pub const COL_EXPERT: _bindgen_ty_1 = 16;
#[doc = "< 17) FW-1 monitor interface/direction"]
pub const COL_IF_DIR: _bindgen_ty_1 = 17;
#[doc = "< 18) IEEE 802.11 (and WiMax?) - Channel"]
pub const COL_FREQ_CHAN: _bindgen_ty_1 = 18;
#[doc = "< 19) Data link layer dest address"]
pub const COL_DEF_DL_DST: _bindgen_ty_1 = 19;
#[doc = "< 20) Data link layer source address"]
pub const COL_DEF_DL_SRC: _bindgen_ty_1 = 20;
#[doc = "< 21) Resolved DL dest"]
pub const COL_RES_DL_DST: _bindgen_ty_1 = 21;
#[doc = "< 22) Unresolved DL dest"]
pub const COL_UNRES_DL_DST: _bindgen_ty_1 = 22;
#[doc = "< 23) Resolved DL source"]
pub const COL_RES_DL_SRC: _bindgen_ty_1 = 23;
#[doc = "< 24) Unresolved DL source"]
pub const COL_UNRES_DL_SRC: _bindgen_ty_1 = 24;
#[doc = "< 25) IEEE 802.11 - received signal strength"]
pub const COL_RSSI: _bindgen_ty_1 = 25;
#[doc = "< 26) IEEE 802.11 - TX rate in Mbps"]
pub const COL_TX_RATE: _bindgen_ty_1 = 26;
#[doc = "< 27) IP DSCP Value"]
pub const COL_DSCP_VALUE: _bindgen_ty_1 = 27;
#[doc = "< 28) Description"]
pub const COL_INFO: _bindgen_ty_1 = 28;
#[doc = "< 29) Resolved net dest"]
pub const COL_RES_NET_DST: _bindgen_ty_1 = 29;
#[doc = "< 30) Unresolved net dest"]
pub const COL_UNRES_NET_DST: _bindgen_ty_1 = 30;
#[doc = "< 31) Resolved net source"]
pub const COL_RES_NET_SRC: _bindgen_ty_1 = 31;
#[doc = "< 32) Unresolved net source"]
pub const COL_UNRES_NET_SRC: _bindgen_ty_1 = 32;
#[doc = "< 33) Network layer dest address"]
pub const COL_DEF_NET_DST: _bindgen_ty_1 = 33;
#[doc = "< 34) Network layer source address"]
pub const COL_DEF_NET_SRC: _bindgen_ty_1 = 34;
#[doc = "< 35) Packet list item number"]
pub const COL_NUMBER: _bindgen_ty_1 = 35;
#[doc = "< 36) Packet length in bytes"]
pub const COL_PACKET_LENGTH: _bindgen_ty_1 = 36;
#[doc = "< 37) Protocol"]
pub const COL_PROTOCOL: _bindgen_ty_1 = 37;
#[doc = "< 38) Relative time"]
pub const COL_REL_TIME: _bindgen_ty_1 = 38;
#[doc = "< 39) Source address"]
pub const COL_DEF_SRC: _bindgen_ty_1 = 39;
#[doc = "< 40) Source port"]
pub const COL_DEF_SRC_PORT: _bindgen_ty_1 = 40;
#[doc = "< 41) Resolved source"]
pub const COL_RES_SRC: _bindgen_ty_1 = 41;
#[doc = "< 42) Unresolved source"]
pub const COL_UNRES_SRC: _bindgen_ty_1 = 42;
#[doc = "< 43) Resolved source port"]
pub const COL_RES_SRC_PORT: _bindgen_ty_1 = 43;
#[doc = "< 44) Unresolved source port"]
pub const COL_UNRES_SRC_PORT: _bindgen_ty_1 = 44;
#[doc = "< 45) Q.921 TEI"]
pub const COL_TEI: _bindgen_ty_1 = 45;
#[doc = "< 46) UTC date, as YYYY-MM-DD, and time"]
pub const COL_UTC_YMD_TIME: _bindgen_ty_1 = 46;
#[doc = "< 47) UTC date, as YYYY/DOY, and time"]
pub const COL_UTC_YDOY_TIME: _bindgen_ty_1 = 47;
#[doc = "< 48) UTC time"]
pub const COL_UTC_TIME: _bindgen_ty_1 = 48;
#[doc = "< 49) Command line-specified time (default relative)"]
pub const COL_CLS_TIME: _bindgen_ty_1 = 49;
#[doc = "< 50) Should always be last"]
pub const NUM_COL_FMTS: _bindgen_ty_1 = 50;
#[doc = " All of the possible columns in summary listing."]
#[doc = ""]
#[doc = " NOTE1: The entries MUST remain in this order, or else you need to reorder"]
#[doc = "        the slist[] and dlist[] arrays in column.c to match!"]
#[doc = ""]
#[doc = " NOTE2: Please add the COL_XYZ entry in the appropriate spot, such that the"]
#[doc = "        dlist[] array remains in alphabetical order!"]
pub type _bindgen_ty_1 = i32;
extern "C" {
    #[doc = " Allocate all the data structures for constructing column data, given"]
    #[doc = " the number of columns."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_setup(cinfo: *mut column_info, num_cols: gint);
}
extern "C" {
    #[doc = " Cleanup all the data structures for constructing column data;"]
    #[doc = " undoes the alocations that col_setup() does."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_cleanup(cinfo: *mut column_info);
}
extern "C" {
    #[doc = " Initialize the data structures for constructing column data."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_init(cinfo: *mut column_info, epan: *const epan_session);
}
extern "C" {
    #[doc = " Fill in all columns of the given packet which are based on values from frame_data."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_fill_in_frame_data(
        fd: *const frame_data,
        cinfo: *mut column_info,
        col: gint,
        fill_col_exprs: gboolean,
    );
}
extern "C" {
    #[doc = " Fill in all columns of the given packet."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_fill_in(pinfo: *mut packet_info, fill_col_exprs: gboolean, fill_fd_colums: gboolean);
}
extern "C" {
    #[doc = " Fill in columns if we got an error reading the packet."]
    #[doc = " We set most columns to \"???\", and set the Info column to an error"]
    #[doc = " message."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_fill_in_error(
        cinfo: *mut column_info,
        fdata: *mut frame_data,
        fill_col_exprs: gboolean,
        fill_fd_colums: gboolean,
    );
}
extern "C" {
    #[doc = " Check to see if our column data has changed, e.g. we have new request/response info."]
    #[doc = ""]
    #[doc = " Internal, don't use this in dissectors!"]
    pub fn col_data_changed() -> gboolean;
}
extern "C" {
    #[doc = " Are the columns writable?"]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the writable column, -1 for checking the state of all columns"]
    #[doc = " @return TRUE if it's writable, FALSE if not"]
    pub fn col_get_writable(cinfo: *mut column_info, col: gint) -> gboolean;
}
extern "C" {
    #[doc = " Set the columns writable."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to set, -1 for all"]
    #[doc = " @param writable TRUE if it's writable, FALSE if not"]
    pub fn col_set_writable(cinfo: *mut column_info, col: gint, writable: gboolean);
}
extern "C" {
    #[doc = " Sets a fence for the current column content,"]
    #[doc = " so this content won't be affected by further col_... function calls."]
    #[doc = ""]
    #[doc = " This can be useful if a protocol is more than once in a single packet,"]
    #[doc = " e.g. multiple HTTP calls in a single TCP packet."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    pub fn col_set_fence(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Clears a fence for the current column content"]
    #[doc = ""]
    #[doc = " This can be useful if a protocol wants to remove whatever"]
    #[doc = " a previous protocol has added to the column."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear_fence(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Gets the text of a column element."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = ""]
    #[doc = " @return the text string"]
    pub fn col_get_text(cinfo: *mut column_info, col: gint) -> *const gchar;
}
extern "C" {
    #[doc = " Clears the text of a column element."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {
    #[doc = " Set (replace) the text of a column element, the text won't be copied."]
    #[doc = ""]
    #[doc = " Usually used to set const strings!"]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to set"]
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str: *const gchar);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to add"]
    pub fn col_add_str(cinfo: *mut column_info, col: gint, str: *const gchar);
}
extern "C" {
    pub fn col_add_lstr(cinfo: *mut column_info, el: gint, str: *const gchar, ...);
}
extern "C" {
    #[doc = " Add (replace) the text of a column element, the text will be formatted and copied."]
    #[doc = ""]
    #[doc = " Same function as col_add_str() but using a printf-like format string."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param format the format string"]
    #[doc = " @param ... the variable number of parameters"]
    pub fn col_add_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn col_custom_set_edt(edt: *mut epan_dissect, cinfo: *mut column_info);
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn col_custom_prime_edt(edt: *mut epan_dissect, cinfo: *mut column_info);
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn have_custom_cols(cinfo: *mut column_info) -> gboolean;
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn have_field_extractors() -> gboolean;
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn col_has_time_fmt(cinfo: *mut column_info, col: gint) -> gboolean;
}
extern "C" {
    #[doc = " For internal Wireshark use only.  Not to be called from dissectors."]
    pub fn col_based_on_frame_data(cinfo: *mut column_info, col: gint) -> gboolean;
}
extern "C" {
    #[doc = " Append the given text to a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param str the string to append"]
    pub fn col_append_str(cinfo: *mut column_info, col: gint, str: *const gchar);
}
extern "C" {
    #[doc = " Append <abbrev>=<val> to a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param abbrev the string to append"]
    #[doc = " @param val the value to append"]
    #[doc = " @param sep an optional separator to _prepend_ to abbrev"]
    pub fn col_append_str_uint(
        cinfo: *mut column_info,
        col: gint,
        abbrev: *const gchar,
        val: guint32,
        sep: *const gchar,
    );
}
extern "C" {
    #[doc = " Append a transport port pair to a column element, the text will be copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param typ the port type to resolve, e.g. PT_UDP"]
    #[doc = " @param src the source port value to append"]
    #[doc = " @param dst the destination port value to append"]
    pub fn col_append_ports(
        cinfo: *mut column_info,
        col: gint,
        typ: port_type,
        src: guint16,
        dst: guint16,
    );
}
extern "C" {
    #[doc = " Append a frame number and signal that we have updated"]
    #[doc = " column information."]
    #[doc = ""]
    #[doc = " @param pinfo the current packet info"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param fmt_str format string, e.g. \"reassembled in %u\"."]
    #[doc = " @param frame_num frame number"]
    pub fn col_append_frame_number(
        pinfo: *mut packet_info,
        col: gint,
        fmt_str: *const gchar,
        frame_num: guint,
    );
}
extern "C" {
    pub fn col_append_lstr(cinfo: *mut column_info, el: gint, str: *const gchar, ...);
}
extern "C" {
    #[doc = " Append the given text to a column element, the text will be formatted and copied."]
    #[doc = ""]
    #[doc = " Same function as col_append_str() but using a printf-like format string."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param format the format string"]
    #[doc = " @param ... the variable number of parameters"]
    pub fn col_append_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Prepend the given text to a column element, the text will be formatted and copied."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param format the format string"]
    #[doc = " @param ... the variable number of parameters"]
    pub fn col_prepend_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = "Prepend the given text to a column element, the text will be formatted and copied."]
    #[doc = " This function is similar to col_prepend_fstr() but this function will"]
    #[doc = " unconditionally set a fence to the end of the prepended data even if there"]
    #[doc = " were no fence before."]
    #[doc = " The col_prepend_fstr() will only prepend the data before the fence IF"]
    #[doc = " there is already a fence created. This function will create a fence in case"]
    #[doc = " it does not yet exist."]
    pub fn col_prepend_fence_fstr(cinfo: *mut column_info, col: gint, format: *const gchar, ...);
}
extern "C" {
    #[doc = " Append the given text (prepended by a separator) to a column element."]
    #[doc = ""]
    #[doc = " Much like col_append_str() but will prepend the given separator if the column isn't empty."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param sep the separator string or NULL for default: \", \""]
    #[doc = " @param str the string to append"]
    pub fn col_append_sep_str(
        cinfo: *mut column_info,
        col: gint,
        sep: *const gchar,
        str: *const gchar,
    );
}
extern "C" {
    #[doc = " Append the given text (prepended by a separator) to a column element."]
    #[doc = ""]
    #[doc = " Much like col_append_fstr() but will prepend the given separator if the column isn't empty."]
    #[doc = ""]
    #[doc = " @param cinfo the current packet row"]
    #[doc = " @param col the column to use, e.g. COL_INFO"]
    #[doc = " @param sep the separator string or NULL for default: \", \""]
    #[doc = " @param format the format string"]
    #[doc = " @param ... the variable number of parameters"]
    pub fn col_append_sep_fstr(
        cinfo: *mut column_info,
        col: gint,
        sep: *const gchar,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[doc = " Set the given (relative) time to a column element."]
    #[doc = ""]
    #[doc = " Used by dissectors to set the time in a column"]
    #[doc = ""]
    #[doc = " @param cinfo\t\tthe current packet row"]
    #[doc = " @param col\t\tthe column to use, e.g. COL_INFO"]
    #[doc = " @param ts\t\tthe time to set in the column"]
    #[doc = " @param fieldname\tthe fieldname to use for creating a filter (when"]
    #[doc = "\t\t\t  applying/preparing/copying as filter)"]
    pub fn col_set_time(
        cinfo: *mut column_info,
        col: ::std::os::raw::c_int,
        ts: *const nstime_t,
        fieldname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn set_fd_time(epan: *const epan_session, fd: *mut frame_data, buf: *mut gchar);
}
#[doc = " @file"]
#[doc = " Units to append to field values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unit_name_string {
    pub singular: *mut ::std::os::raw::c_char,
    pub plural: *mut ::std::os::raw::c_char,
}
extern "C" {
    pub fn unit_name_string_get_value(
        value: guint32,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unit_name_string_get_value64(
        value: guint64,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unit_name_string_get_double(
        value: f64,
        units: *const unit_name_string,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static units_foot_feet: unit_name_string;
}
extern "C" {
    pub static units_bit_bits: unit_name_string;
}
extern "C" {
    pub static units_byte_bytes: unit_name_string;
}
extern "C" {
    pub static units_byte_bytespsecond: unit_name_string;
}
extern "C" {
    pub static units_octet_octets: unit_name_string;
}
extern "C" {
    pub static units_word_words: unit_name_string;
}
extern "C" {
    pub static units_tick_ticks: unit_name_string;
}
extern "C" {
    pub static units_meters: unit_name_string;
}
extern "C" {
    pub static units_meter_meters: unit_name_string;
}
extern "C" {
    pub static units_week_weeks: unit_name_string;
}
extern "C" {
    pub static units_day_days: unit_name_string;
}
extern "C" {
    pub static units_hour_hours: unit_name_string;
}
extern "C" {
    pub static units_hours: unit_name_string;
}
extern "C" {
    pub static units_minute_minutes: unit_name_string;
}
extern "C" {
    pub static units_minutes: unit_name_string;
}
extern "C" {
    pub static units_second_seconds: unit_name_string;
}
extern "C" {
    pub static units_seconds: unit_name_string;
}
extern "C" {
    pub static units_millisecond_milliseconds: unit_name_string;
}
extern "C" {
    pub static units_milliseconds: unit_name_string;
}
extern "C" {
    pub static units_microsecond_microseconds: unit_name_string;
}
extern "C" {
    pub static units_microseconds: unit_name_string;
}
extern "C" {
    pub static units_nanosecond_nanoseconds: unit_name_string;
}
extern "C" {
    pub static units_nanoseconds: unit_name_string;
}
extern "C" {
    pub static units_nanometers: unit_name_string;
}
extern "C" {
    pub static units_degree_degrees: unit_name_string;
}
extern "C" {
    pub static units_degree_celsius: unit_name_string;
}
extern "C" {
    pub static units_degree_bearing: unit_name_string;
}
extern "C" {
    pub static units_decibels: unit_name_string;
}
extern "C" {
    pub static units_dbm: unit_name_string;
}
extern "C" {
    pub static units_dbi: unit_name_string;
}
extern "C" {
    pub static units_mbm: unit_name_string;
}
extern "C" {
    pub static units_percent: unit_name_string;
}
extern "C" {
    pub static units_khz: unit_name_string;
}
extern "C" {
    pub static units_ghz: unit_name_string;
}
extern "C" {
    pub static units_mhz: unit_name_string;
}
extern "C" {
    pub static units_hz: unit_name_string;
}
extern "C" {
    pub static units_hz_s: unit_name_string;
}
extern "C" {
    pub static units_kbit: unit_name_string;
}
extern "C" {
    pub static units_kbps: unit_name_string;
}
extern "C" {
    pub static units_kibps: unit_name_string;
}
extern "C" {
    pub static units_pkts: unit_name_string;
}
extern "C" {
    pub static units_pkts_per_sec: unit_name_string;
}
extern "C" {
    pub static units_km: unit_name_string;
}
extern "C" {
    pub static units_kmh: unit_name_string;
}
extern "C" {
    pub static units_milliamps: unit_name_string;
}
extern "C" {
    pub static units_microwatts: unit_name_string;
}
extern "C" {
    pub static units_volt: unit_name_string;
}
extern "C" {
    pub static units_grams_per_second: unit_name_string;
}
extern "C" {
    pub static units_meter_sec: unit_name_string;
}
extern "C" {
    pub static units_meter_sec_squared: unit_name_string;
}
extern "C" {
    pub static units_bit_sec: unit_name_string;
}
extern "C" {
    pub static units_segment_remaining: unit_name_string;
}
extern "C" {
    pub static units_frame_frames: unit_name_string;
}
extern "C" {
    pub static units_revolutions_per_minute: unit_name_string;
}
extern "C" {
    pub static units_kilopascal: unit_name_string;
}
extern "C" {
    pub static units_newton_metre: unit_name_string;
}
extern "C" {
    pub static units_liter_per_hour: unit_name_string;
}
extern "C" {
    pub static units_amp: unit_name_string;
}
extern "C" {
    pub static units_watthour: unit_name_string;
}
extern "C" {
    pub static units_watt: unit_name_string;
}
extern "C" {
    pub static units_bpm: unit_name_string;
}
extern "C" {
    pub static units_calorie: unit_name_string;
}
extern "C" {
    pub fn packet_init();
}
extern "C" {
    pub fn packet_cache_proto_handles();
}
extern "C" {
    pub fn packet_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_table {
    _unused: [u8; 0],
}
pub type dissector_table_t = *mut dissector_table;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type dissector_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Type of a heuristic dissector, used in heur_dissector_add()."]
#[doc = ""]
#[doc = " @param tvb the tvbuff with the (remaining) packet data"]
#[doc = " @param pinfo the packet info of this packet (additional info)"]
#[doc = " @param tree the protocol tree to be build or NULL"]
#[doc = " @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
pub type heur_dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        arg1: *mut ::std::os::raw::c_void,
    ) -> gboolean,
>;
pub const heuristic_enable_e_HEURISTIC_DISABLE: heuristic_enable_e = 0;
pub const heuristic_enable_e_HEURISTIC_ENABLE: heuristic_enable_e = 1;
pub type heuristic_enable_e = i32;
pub type DATFunc = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        selector_type: ftenum_t,
        key: gpointer,
        value: gpointer,
        user_data: gpointer,
    ),
>;
pub type DATFunc_handle = ::std::option::Option<
    unsafe extern "C" fn(table_name: *const gchar, value: gpointer, user_data: gpointer),
>;
pub type DATFunc_table = ::std::option::Option<
    unsafe extern "C" fn(table_name: *const gchar, ui_name: *const gchar, user_data: gpointer),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtbl_entry {
    _unused: [u8; 0],
}
pub type dtbl_entry_t = dtbl_entry;
extern "C" {
    pub fn dtbl_entry_get_handle(dtbl_entry: *mut dtbl_entry_t) -> dissector_handle_t;
}
extern "C" {
    pub fn dtbl_entry_get_initial_handle(entry: *mut dtbl_entry_t) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Iterate over dissectors in a table with non-default \"decode as\" settings."]
    #[doc = ""]
    #[doc = " Walk one dissector table calling a user supplied function only on"]
    #[doc = " any entry that has been changed from its original state."]
    #[doc = ""]
    #[doc = " @param[in] table_name The name of the dissector table, e.g. \"ip.proto\"."]
    #[doc = " @param[in] func The function to call for each dissector."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach_changed(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over dissectors in a table."]
    #[doc = ""]
    #[doc = " Walk one dissector table's hash table calling a user supplied function"]
    #[doc = " on each entry."]
    #[doc = ""]
    #[doc = " @param[in] table_name The name of the dissector table, e.g. \"ip.proto\"."]
    #[doc = " @param[in] func The function to call for each dissector."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over dissectors with non-default \"decode as\" settings."]
    #[doc = ""]
    #[doc = " Walk all dissector tables calling a user supplied function only on"]
    #[doc = " any \"decode as\" entry that has been changed from its original state."]
    #[doc = ""]
    #[doc = " @param[in] func The function to call for each dissector."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    pub fn dissector_all_tables_foreach_changed(func: DATFunc, user_data: gpointer);
}
extern "C" {
    #[doc = " Iterate over dissectors in a table by handle."]
    #[doc = ""]
    #[doc = " Walk one dissector table's list of handles calling a user supplied"]
    #[doc = " function on each entry."]
    #[doc = ""]
    #[doc = " @param[in] table_name The name of the dissector table, e.g. \"ip.proto\"."]
    #[doc = " @param[in] func The function to call for each dissector."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    pub fn dissector_table_foreach_handle(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc_handle,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over all dissector tables."]
    #[doc = ""]
    #[doc = " Walk the set of dissector tables calling a user supplied function on each"]
    #[doc = " table."]
    #[doc = " @param[in] func The function to call for each table."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    #[doc = " @param[in] compare_key_func Function used to sort the set of tables before"]
    #[doc = " calling the function.  No sorting is done if NULL."]
    pub fn dissector_all_tables_foreach_table(
        func: DATFunc_table,
        user_data: gpointer,
        compare_key_func: GCompareFunc,
    );
}
extern "C" {
    pub fn register_dissector_table(
        name: *const ::std::os::raw::c_char,
        ui_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        type_: ftenum_t,
        param: ::std::os::raw::c_int,
    ) -> dissector_table_t;
}
extern "C" {
    pub fn register_custom_dissector_table(
        name: *const ::std::os::raw::c_char,
        ui_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> dissector_table_t;
}
extern "C" {
    #[doc = " Register a dissector table alias."]
    #[doc = " This is for dissectors whose original name has changed, e.g. SSL to TLS."]
    #[doc = " @param dissector_table dissector table returned by register_dissector_table."]
    #[doc = " @param alias_name alias for the dissector table name."]
    pub fn register_dissector_table_alias(
        dissector_table: dissector_table_t,
        alias_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Deregister the dissector table by table name."]
    pub fn deregister_dissector_table(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn find_dissector_table(name: *const ::std::os::raw::c_char) -> dissector_table_t;
}
extern "C" {
    pub fn get_dissector_table_ui_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_dissector_table_selector_type(name: *const ::std::os::raw::c_char) -> ftenum_t;
}
extern "C" {
    pub fn get_dissector_table_param(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_dump_dissector_tables();
}
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_with_preference(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_uint_range_with_preference(
        abbrev: *const ::std::os::raw::c_char,
        range_str: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_uint_range(
        abbrev: *const ::std::os::raw::c_char,
        range: *mut epan_range,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_all(name: *const ::std::os::raw::c_char, handle: dissector_handle_t);
}
extern "C" {
    pub fn dissector_change_uint(
        abbrev: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_uint(name: *const ::std::os::raw::c_char, pattern: guint32);
}
extern "C" {
    pub fn dissector_try_uint(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_uint_new(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given uint dissector table and, if found,"]
    #[doc = " return the current dissector handle for that value."]
    #[doc = ""]
    #[doc = " @param[in] sub_dissectors Dissector table to search."]
    #[doc = " @param[in] uint_val Value to match, e.g. the port number for the TCP dissector."]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_uint_handle(
        sub_dissectors: dissector_table_t,
        uint_val: guint32,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Look for a given value in a given uint dissector table and, if found,"]
    #[doc = " return the default dissector handle for that value."]
    #[doc = ""]
    #[doc = " @param[in] name Dissector table name."]
    #[doc = " @param[in] uint_val Value to match, e.g. the port number for the TCP dissector."]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_default_uint_handle(
        name: *const ::std::os::raw::c_char,
        uint_val: guint32,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_delete_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_change_string(
        name: *const ::std::os::raw::c_char,
        pattern: *const gchar,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_string(name: *const ::std::os::raw::c_char, pattern: *const gchar);
}
extern "C" {
    pub fn dissector_try_string(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_string_new(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given string dissector table and, if found,"]
    #[doc = " return the current dissector handle for that value."]
    #[doc = ""]
    #[doc = " @param[in] sub_dissectors Dissector table to search."]
    #[doc = " @param[in] string Value to match, e.g. the OID for the BER dissector."]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_string_handle(
        sub_dissectors: dissector_table_t,
        string: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Look for a given value in a given string dissector table and, if found,"]
    #[doc = " return the default dissector handle for that value."]
    #[doc = ""]
    #[doc = " @param[in] name Dissector table name."]
    #[doc = " @param[in] string Value to match, e.g. the OID for the BER dissector."]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_default_string_handle(
        name: *const ::std::os::raw::c_char,
        string: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_custom_table_handle(
        name: *const ::std::os::raw::c_char,
        pattern: *mut ::std::os::raw::c_void,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Look for a given key in a given \"custom\" dissector table and, if found,"]
    #[doc = " return the current dissector handle for that key."]
    #[doc = ""]
    #[doc = " @param[in] sub_dissectors Dissector table to search."]
    #[doc = " @param[in] key Value to match, e.g. RPC key for its subdissectors"]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_custom_table_handle(
        sub_dissectors: dissector_table_t,
        key: *mut ::std::os::raw::c_void,
    ) -> dissector_handle_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _guid_key {
    pub guid: e_guid_t,
    pub ver: guint16,
}
pub type guid_key = _guid_key;
extern "C" {
    pub fn dissector_add_guid(
        name: *const ::std::os::raw::c_char,
        guid_val: *mut guid_key,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_try_guid(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_guid_new(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look for a given value in a given guid dissector table and, if found,"]
    #[doc = " return the current dissector handle for that value."]
    #[doc = ""]
    #[doc = " @param[in] sub_dissectors Dissector table to search."]
    #[doc = " @param[in] guid_val Value to match, e.g. the GUID number for the GUID dissector."]
    #[doc = " @return The matching dissector handle on success, NULL if no match is found."]
    pub fn dissector_get_guid_handle(
        sub_dissectors: dissector_table_t,
        guid_val: *mut guid_key,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_try_payload(
        sub_dissectors: dissector_table_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_try_payload_new(
        sub_dissectors: dissector_table_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        add_proto_name: gboolean,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dissector_change_payload(
        abbrev: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_reset_payload(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dissector_get_payload_handle(dissector_table: dissector_table_t) -> dissector_handle_t;
}
extern "C" {
    pub fn dissector_add_for_decode_as(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    pub fn dissector_add_for_decode_as_with_preference(
        name: *const ::std::os::raw::c_char,
        handle: dissector_handle_t,
    );
}
extern "C" {
    #[doc = " Get the list of handles for a dissector table"]
    pub fn dissector_table_get_dissector_handles(dissector_table: dissector_table_t)
        -> *mut GSList;
}
extern "C" {
    #[doc = " Get a handle to dissector out of a dissector table"]
    pub fn dissector_table_get_dissector_handle(
        dissector_table: dissector_table_t,
        short_name: *const gchar,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Get a dissector table's type"]
    pub fn dissector_table_get_type(dissector_table: dissector_table_t) -> ftenum_t;
}
extern "C" {
    #[doc = " Mark a dissector table as allowing \"Decode As\""]
    pub fn dissector_table_allow_decode_as(dissector_table: dissector_table_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heur_dissector_list {
    _unused: [u8; 0],
}
pub type heur_dissector_list_t = *mut heur_dissector_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heur_dtbl_entry {
    pub dissector: heur_dissector_t,
    pub protocol: *mut protocol_t,
    pub list_name: *mut gchar,
    pub display_name: *const gchar,
    pub short_name: *mut gchar,
    pub enabled: gboolean,
}
pub type heur_dtbl_entry_t = heur_dtbl_entry;
extern "C" {
    #[doc = " A protocol uses this function to register a heuristic sub-dissector list."]
    #[doc = "  Call this in the parent dissectors proto_register function."]
    #[doc = ""]
    #[doc = " @param name the name of this protocol"]
    #[doc = " @param proto the value obtained when regestering the protocol"]
    pub fn register_heur_dissector_list(
        name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
    ) -> heur_dissector_list_t;
}
pub type DATFunc_heur = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const gchar,
        entry: *mut heur_dtbl_entry,
        user_data: gpointer,
    ),
>;
pub type DATFunc_heur_table = ::std::option::Option<
    unsafe extern "C" fn(
        table_name: *const ::std::os::raw::c_char,
        table: *mut heur_dissector_list,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[doc = " Iterate over heuristic dissectors in a table."]
    #[doc = ""]
    #[doc = " Walk one heuristic dissector table's list calling a user supplied function"]
    #[doc = " on each entry."]
    #[doc = ""]
    #[doc = " @param[in] table_name The name of the dissector table, e.g. \"tcp\"."]
    #[doc = " @param[in] func The function to call for each dissector."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    pub fn heur_dissector_table_foreach(
        table_name: *const ::std::os::raw::c_char,
        func: DATFunc_heur,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " Iterate over all heuristic dissector tables."]
    #[doc = ""]
    #[doc = " Walk the set of heuristic dissector tables calling a user supplied function"]
    #[doc = " on each table."]
    #[doc = " @param[in] func The function to call for each table."]
    #[doc = " @param[in] user_data User data to pass to the function."]
    #[doc = " @param[in] compare_key_func Function used to sort the set of tables before"]
    #[doc = " calling the function.  No sorting is done if NULL."]
    pub fn dissector_all_heur_tables_foreach_table(
        func: DATFunc_heur_table,
        user_data: gpointer,
        compare_key_func: GCompareFunc,
    );
}
extern "C" {
    pub fn has_heur_dissector_list(name: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " Try all the dissectors in a given heuristic dissector list. This is done,"]
    #[doc = "  until we find one that recognizes the protocol."]
    #[doc = "  Call this while the parent dissector running."]
    #[doc = ""]
    #[doc = " @param sub_dissectors the sub-dissector list"]
    #[doc = " @param tvb the tvbuff with the (remaining) packet data"]
    #[doc = " @param pinfo the packet info of this packet (additional info)"]
    #[doc = " @param tree the protocol tree to be build or NULL"]
    #[doc = " @param hdtbl_entry returns the last tried dissectors hdtbl_entry."]
    #[doc = " @param data parameter to pass to subdissector"]
    #[doc = " @return TRUE if the packet was recognized by the sub-dissector (stop dissection here)"]
    pub fn dissector_try_heuristic(
        sub_dissectors: heur_dissector_list_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        hdtbl_entry: *mut *mut heur_dtbl_entry_t,
        data: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Find a heuristic dissector table by table name."]
    #[doc = ""]
    #[doc = " @param name name of the dissector table"]
    #[doc = " @return pointer to the table on success, NULL if no such table exists"]
    pub fn find_heur_dissector_list(name: *const ::std::os::raw::c_char) -> heur_dissector_list_t;
}
extern "C" {
    #[doc = " Find a heuristic dissector by the unique short protocol name provided during registration."]
    #[doc = ""]
    #[doc = " @param short_name short name of the protocol to look at"]
    #[doc = " @return pointer to the heuristic dissector entry, NULL if not such dissector exists"]
    pub fn find_heur_dissector_by_unique_short_name(
        short_name: *const ::std::os::raw::c_char,
    ) -> *mut heur_dtbl_entry_t;
}
extern "C" {
    #[doc = " Add a sub-dissector to a heuristic dissector list."]
    #[doc = "  Call this in the proto_handoff function of the sub-dissector."]
    #[doc = ""]
    #[doc = " @param name the name of the \"parent\" protocol, e.g. \"tcp\""]
    #[doc = " @param dissector the sub-dissector to be registered"]
    #[doc = " @param display_name the string used to present heuristic to user, e.g. \"HTTP over TCP\""]
    #[doc = " @param short_name the string used for \"internal\" use to identify heuristic, e.g. \"http_tcp\""]
    #[doc = " @param proto the protocol id of the sub-dissector"]
    #[doc = " @param enable initially enabled or not"]
    pub fn heur_dissector_add(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        display_name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        proto: ::std::os::raw::c_int,
        enable: heuristic_enable_e,
    );
}
extern "C" {
    #[doc = " Remove a sub-dissector from a heuristic dissector list."]
    #[doc = "  Call this in the prefs_reinit function of the sub-dissector."]
    #[doc = ""]
    #[doc = " @param name the name of the \"parent\" protocol, e.g. \"tcp\""]
    #[doc = " @param dissector the sub-dissector to be unregistered"]
    #[doc = " @param proto the protocol id of the sub-dissector"]
    pub fn heur_dissector_delete(
        name: *const ::std::os::raw::c_char,
        dissector: heur_dissector_t,
        proto: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Register a new dissector."]
    pub fn register_dissector(
        name: *const ::std::os::raw::c_char,
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Register a new dissector with a callback pointer."]
    pub fn register_dissector_with_data(
        name: *const ::std::os::raw::c_char,
        dissector: dissector_cb_t,
        proto: ::std::os::raw::c_int,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Deregister a dissector."]
    pub fn deregister_dissector(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the long name of the protocol for a dissector handle."]
    pub fn dissector_handle_get_long_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the short name of the protocol for a dissector handle."]
    pub fn dissector_handle_get_short_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the index of the protocol for a dissector handle."]
    pub fn dissector_handle_get_protocol_index(handle: dissector_handle_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a GList of all registered dissector names."]
    pub fn get_dissector_names() -> *mut GList;
}
extern "C" {
    #[doc = " Find a dissector by name."]
    pub fn find_dissector(name: *const ::std::os::raw::c_char) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Find a dissector by name and add parent protocol as a depedency"]
    pub fn find_dissector_add_dependency(
        name: *const ::std::os::raw::c_char,
        parent_proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Get a dissector name from handle."]
    pub fn dissector_handle_get_dissector_name(
        handle: dissector_handle_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an anonymous handle for a dissector."]
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn create_dissector_handle_with_name(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> dissector_handle_t;
}
extern "C" {
    #[doc = " Call a dissector through a handle and if no dissector was found"]
    #[doc = " pass it over to the \"data\" dissector instead."]
    #[doc = ""]
    #[doc = "   @param handle The dissector to call."]
    #[doc = "   @param  tvb The buffer to dissect."]
    #[doc = "   @param  pinfo Packet Info."]
    #[doc = "   @param  tree The protocol tree."]
    #[doc = "   @param  data parameter to pass to dissector"]
    #[doc = "   @return  If the protocol for that handle isn't enabled call the data"]
    #[doc = "   dissector. Otherwise, if the handle refers to a new-style"]
    #[doc = "   dissector, call the dissector and return its return value, otherwise call"]
    #[doc = "   it and return the length of the tvbuff pointed to by the argument."]
    pub fn call_dissector_with_data(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn call_dissector(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn call_data_dissector(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a dissector through a handle but if no dissector was found"]
    #[doc = " just return 0 and do not call the \"data\" dissector instead."]
    #[doc = ""]
    #[doc = "   @param handle The dissector to call."]
    #[doc = "   @param  tvb The buffer to dissect."]
    #[doc = "   @param  pinfo Packet Info."]
    #[doc = "   @param  tree The protocol tree."]
    #[doc = "   @param  data parameter to pass to dissector"]
    #[doc = "   @return  If the protocol for that handle isn't enabled, return 0 without"]
    #[doc = "   calling the dissector. Otherwise, if the handle refers to a new-style"]
    #[doc = "   dissector, call the dissector and return its return value, otherwise call"]
    #[doc = "   it and return the length of the tvbuff pointed to by the argument."]
    pub fn call_dissector_only(
        handle: dissector_handle_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "   @param heur_dtbl_entry The heur_dtbl_entry of the dissector to call."]
    #[doc = "   @param  tvb The buffer to dissect."]
    #[doc = "   @param  pinfo Packet Info."]
    #[doc = "   @param  tree The protocol tree."]
    #[doc = "   @param  data parameter to pass to dissector"]
    pub fn call_heur_dissector_direct(
        heur_dtbl_entry: *mut heur_dtbl_entry_t,
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct depend_dissector_list {
    _unused: [u8; 0],
}
pub type depend_dissector_list_t = *mut depend_dissector_list;
extern "C" {
    #[doc = " Register a protocol dependency"]
    #[doc = " This is done automatically when registering with a dissector or"]
    #[doc = " heuristic table.  This is for \"manual\" registration when a dissector"]
    #[doc = " ends up calling another through call_dissector (or similar) so"]
    #[doc = " dependencies can be determined"]
    #[doc = ""]
    #[doc = "   @param parent \"Parent\" protocol short name"]
    #[doc = "   @param dependent \"Dependent\" protocol short name"]
    #[doc = "   @return  return TRUE if dependency was successfully registered"]
    pub fn register_depend_dissector(
        parent: *const ::std::os::raw::c_char,
        dependent: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Unregister a protocol dependency"]
    #[doc = " This is done automatically when removing from a dissector or"]
    #[doc = " heuristic table.  This is for \"manual\" deregistration for things"]
    #[doc = " like Lua"]
    #[doc = ""]
    #[doc = "   @param parent \"Parent\" protocol short name"]
    #[doc = "   @param dependent \"Dependent\" protocol short name"]
    #[doc = "   @return  return TRUE if dependency was successfully unregistered"]
    pub fn deregister_depend_dissector(
        parent: *const ::std::os::raw::c_char,
        dependent: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[doc = " Find the list of protocol dependencies"]
    #[doc = ""]
    #[doc = "   @param name Protocol short name to search for"]
    #[doc = "   @return  return list of dependent was successfully registered"]
    pub fn find_depend_dissector_list(
        name: *const ::std::os::raw::c_char,
    ) -> depend_dissector_list_t;
}
extern "C" {
    pub fn dissect_init();
}
extern "C" {
    pub fn dissect_cleanup();
}
extern "C" {
    pub fn set_actual_length(tvb: *mut tvbuff_t, specified_len: guint);
}
extern "C" {
    #[doc = " Allow protocols to register \"init\" routines, which are called before"]
    #[doc = " we make a pass through a capture file and dissect all its packets"]
    #[doc = " (e.g., when we read in a new capture file, or run a \"filter packets\""]
    #[doc = " or \"colorize packets\" pass over the current capture file or when the"]
    #[doc = " preferences are changed)."]
    pub fn register_init_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " Allows protocols to register \"cleanup\" routines which are called"]
    #[doc = " after closing a capture file (or when preferences are changed, in"]
    #[doc = " that case these routines are called before the init routines are"]
    #[doc = " executed). It can be used to release resources that are allocated in"]
    #[doc = " register_init_routine."]
    pub fn register_cleanup_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn register_shutdown_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn init_dissection();
}
extern "C" {
    pub fn cleanup_dissection();
}
extern "C" {
    pub fn register_postseq_cleanup_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn postseq_cleanup_all_protocols();
}
extern "C" {
    pub fn register_final_registration_routine(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn final_registration_all_protocols();
}
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn remove_last_data_source(pinfo: *mut packet_info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct data_source {
    _unused: [u8; 0],
}
extern "C" {
    pub fn get_data_source_name(src: *const data_source) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_data_source_tvb(src: *const data_source) -> *mut tvbuff_t;
}
extern "C" {
    pub fn get_data_source_tvb_by_name(
        pinfo: *mut packet_info,
        name: *const ::std::os::raw::c_char,
    ) -> *mut tvbuff_t;
}
extern "C" {
    pub fn free_data_sources(pinfo: *mut packet_info);
}
extern "C" {
    pub fn mark_frame_as_depended_upon(pinfo: *mut packet_info, frame_num: guint32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frame_data_s {
    pub file_type_subtype: ::std::os::raw::c_int,
    #[doc = "< NULL if not available"]
    pub pkt_comment: *const gchar,
    pub color_edt: *mut epan_dissect,
}
pub type frame_data_t = frame_data_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_data_s {
    #[doc = "< NULL if not available"]
    pub pkt_comment: *const gchar,
    pub color_edt: *mut epan_dissect,
}
pub type file_data_t = file_data_s;
extern "C" {
    pub fn dissect_record(
        edt: *mut epan_dissect,
        file_type_subtype: ::std::os::raw::c_int,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut column_info,
    );
}
extern "C" {
    pub fn dissect_file(
        edt: *mut epan_dissect,
        rec: *mut wtap_rec,
        tvb: *mut tvbuff_t,
        fd: *mut frame_data,
        cinfo: *mut column_info,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethertype_data_s {
    pub etype: guint16,
    pub offset_after_ethertype: ::std::os::raw::c_int,
    pub fh_tree: *mut proto_tree,
    pub etype_id: ::std::os::raw::c_int,
    pub trailer_id: ::std::os::raw::c_int,
    pub fcs_len: ::std::os::raw::c_int,
}
pub type ethertype_data_t = ethertype_data_s;
extern "C" {
    pub fn dissector_dump_decodes();
}
extern "C" {
    pub fn dissector_dump_heur_decodes();
}
extern "C" {
    pub fn register_postdissector(handle: dissector_handle_t);
}
extern "C" {
    pub fn set_postdissector_wanted_hfids(handle: dissector_handle_t, wanted_hfids: *mut GArray);
}
extern "C" {
    pub fn deregister_postdissector(handle: dissector_handle_t);
}
extern "C" {
    pub fn have_postdissector() -> gboolean;
}
extern "C" {
    pub fn call_all_postdissectors(
        tvb: *mut tvbuff_t,
        pinfo: *mut packet_info,
        tree: *mut proto_tree,
    );
}
extern "C" {
    pub fn postdissectors_want_hfids() -> gboolean;
}
extern "C" {
    pub fn prime_epan_dissect_with_postdissector_wanted_hfids(edt: *mut epan_dissect_t);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
